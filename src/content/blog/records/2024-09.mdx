---
author: ajn404
pubDatetime: 2024-09-04T05:44:43Z
title: 2024年9月
postSlug: 2024-09
tags:
  - "2024"
  - "2024-09"
  - driver
  - english
description: 上个月不算，八月公司的活有点多，这个月重来
---

import DriverNoText from "@components/react/little/driverNoText.tsx";
import Tag from "@components/astro/UI/Tag.astro";

<blockquote class="xing-cao p-0 m-0 leading-none text-right">
  目击众神死亡的草原上野花一片
  <br />
  　　远在远方的风比远方更远
  <br />
  　　我的琴声呜咽泪水全无
  <br />
  　　我把这远方的远归还草原
  <br />
  　　一个叫木头一个叫马尾
  <br />
  　　我的琴声呜咽泪水全无
  <br />
  　　远方只有在死亡中凝聚野花一片
  <br />
  　　明月如镜高悬草原映照千年岁月
  <br />
  　　我的琴声呜咽泪水全无
  <br />
  　　只身打马过草原
  <br />
</blockquote>

## 目录

## 2024-09-04 14:06:14

<Tag name="ts" className="max-w-[100px]" />

[ts5.6 RC 新特性](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6-rc/#disallowed-nullish-and-truthy-checks)

## 2024-09-18 10:32:06

<details>
<summary>view transition api</summary>
**View Transition API** 是一个新兴的 Web API，用于在 Web 应用中创建无缝的页面或组件过渡动画。它通过浏览器级别的渲染技术，简化了在单页应用（SPA）或多页应用（MPA）中实现平滑过渡动画的过程，使页面内容的变化更流畅和自然。

### 主要特性

- **无缝过渡**：允许在页面切换、组件状态变化时，提供平滑的视觉过渡效果。
- **元素的关联**：可以标记页面中变化的元素，浏览器会自动计算和动画化它们在两个状态之间的过渡。
- **简化过渡动画的编写**：开发者无需手动管理复杂的动画逻辑，只需要声明哪些元素需要过渡，浏览器会自动计算和应用动画。
- **适用于多种场景**：可以用于单页应用（SPA）中的路由切换，也可以用于多页应用（MPA）中的页面切换。

### 工作原理

View Transition API 利用了浏览器的渲染机制，通过快照（snapshot）页面的前后状态，然后计算和应用过渡动画，使页面切换或元素变化更加流畅。

### 基本使用方式

1. **启动过渡**：在页面状态变化时，可以通过 JavaScript 调用 `document.startViewTransition()` 来触发视图的过渡。
2. **标记过渡元素**：使用 `view-transition-name` 属性标记你想要过渡的元素，浏览器将跟踪这些元素，并应用过渡效果。

### 示例

#### 1. 单页应用中的过渡

```html
<style>
  .box {
    width: 100px;
    height: 100px;
    background-color: lightblue;
    margin: 20px;
    transition: all 0.5s ease;
  }

  .new-state {
    width: 200px;
    background-color: lightcoral;
  }
</style>

<div class="box" class="box" view-transition-name="box"></div>

<script>
  const box = document.getElementById("box");

  // 启动视图过渡
  document.getElementById("box").addEventListener("click", () => {
    document.startViewTransition(() => {
      box.classList.toggle("new-state");
    });
  });
</script>
```

在这个例子中，`startViewTransition()` 被用来启动过渡动画，当点击 `box` 时，它会在两种状态（原始状态和 `new-state`）之间进行平滑的过渡。

#### 2. 多页应用中的过渡

View Transition API 还可以在页面导航时用于多页应用，确保页面切换动画也同样流畅。

```javascript
document.startViewTransition(() => {
  window.location.href = "/new-page";
});
```

当你导航到新的页面时，`startViewTransition` 将确保旧页面与新页面之间的切换是平滑的，并且浏览器会自动生成过渡动画。

### 优点

- **简化动画开发**：开发者不再需要手动处理动画的复杂细节，View Transition API 会自动管理动画的开始和结束。
- **提高性能**：由于动画由浏览器本地处理，因此能够获得更高的性能和流畅度。
- **统一过渡**：可以在页面切换、元素变化等多种场景下统一实现过渡动画效果。

### 浏览器支持

目前，View Transition API 处于实验性阶段，支持度正在逐渐提升。现代浏览器如 Chrome 110+ 已经开始支持该 API，不过其他浏览器如 Firefox 和 Safari 可能仍在开发中。可以通过 `feature-detection` 检查当前浏览器是否支持该功能。

### 总结

View Transition API 是 Web 动画开发的一个强大工具，能够大幅简化页面过渡效果的实现，尤其适用于需要在前后状态间提供平滑过渡的场景。它提升了 Web 应用的用户体验，让页面切换、状态变化更加流畅自然。

</details>

## 2024-09-18 21:09:59

决定重新学习ts

### 新增字体 Whisper

签名字体 <span class="font-whisper">Whisper</span>

<blockquote>
  <div class="font-whisper m-0 p-0 leading-none">
    From fairest creatures we desire increase,
    <br />
    That thereby beauty's rose might never die,
    <br />
    But as the riper should by time decease,
    <br />
    His tender heir might bear his memory:
    <br />
    But thou, contending with old age and death,
    <br />
    To hide thyself, diedst not leave me so.
    <br />
    Thy self thy foe, to thy sweet self too cruel,
    <br />
    Thou that art now the world's fresh ornament,
    <br />
    And only herald of the gaudy spring,
    <br />
    Wilt thou, upon the high and giddy mast,
    <br />
    Seal up thy lips, and drown the whole world in tears?
    <br />
    O, let me not be made a fool of thee,
    <br />
    To be so cruel, and yet so fair!
    <br />
  </div>
</blockquote>

### show code

<details>
<summary>今天写了一个还有点不错的代码</summary>

```js
socket = new WebSocket(`ws://${host}/websocket/position/ajn404`);
let lastExecutionTime = 0; // 上次执行时间
let cache = [];
let processing = false;
const cacheMap = new Map();

socket.addEventListener("message", function (event) {
  const parsedData = JSON.parse(event.data);

  // 处理警告通知
  if (parsedData.method === "warning") {
    showNotification(parsedData);
    return;
  }

  const currentTime = Date.now(); // 获取当前时间
  // 如果距离上次执行时间小于 100ms，则继续缓存数据
  if (currentTime - lastExecutionTime < 100) {
    cacheMap.set(parsedData.params.tagId, parsedData.params); // 用 tagId 作为键，去重存储数据
    return;
  }
  lastExecutionTime = currentTime; // 更新上次执行时间
  cacheMap.set(parsedData.params.tagId, parsedData.params); // 用 tagId 作为键，去重存储数据

  // 如果正在处理缓存中的数据，则不再处理
  if (processing) return;
  processing = true; // 标记为正在处理

  setTimeout(() => {
    // 将 Map 转换为数组，取出所有的缓存数据
    cache = Array.from(cacheMap.values());

    // 过滤并获取车辆和人员的更新数据
    const updateData = getGraphicData(
      cache.filter(item => item.entityType === "car"),
      "car"
    );

    const updateDataMember = getGraphicData(
      cache.filter(item => item.entityType === "staff"),
      "member"
    );

    // 更新车辆位置
    if (updateData && updateData.length > 0) {
      vehicleLocation.locationView.update(updateData);
    }

    // 更新人员位置
    if (updateDataMember && updateDataMember.length > 0) {
      memberLocation.locationView.update(updateDataMember);
    }

    cacheMap.clear(); // 清空 Map 以保证缓存不重复

    if (!memberLocation.positionGroupGraphics) {
      cache = [...updateDataMember];
    }

    if (!vehicleLocation.positionGroupGraphics) {
      cache = [...cache, ...updateData];
    }

    // 处理完成后清空缓存并重置标记

    processing = false;

    console.log(cache, updateDataMember, updateData);
  }, 0); // 异步处理，保证不会阻塞消息接收
});
```

</details>

### Visual Viewport API

<details>
<summary>什么是Visual Viewport API</summary>

Visual Viewport API 是一种机制，允许开发者查询和修改窗口可视区域的属性。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) 可视区域是指屏幕上除去屏幕键盘、缩放区域外以及其他不随页面缩放的屏幕元素后，实际可见的部分。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)

移动网页包含两个视口：布局视口和可视视口。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) 布局视口涵盖页面上的所有元素，而可视视口是屏幕上实际可见的部分。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)[6](https://github.com/WICG/visual-viewport) 当用户放大页面时，可视视口会缩小，但布局视口保持不变。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) 用户界面功能（如屏幕键盘）可以缩小可视视口，而不会影响布局视口。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) Visual Viewport API 允许开发者相对于屏幕上显示的内容定位元素，从而解决布局视口和可视视口不一致的问题。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)

</details>

## 2024-09-23 14:15:19

### 今日英语

<div class="second">
  I <span class="use">use</span> <span class="nestjs">Nest.Js</span> at work but{" "}
  <span class="dislike">don’t like it</span>, too much{" "}
  <span class="boilerplate">boilerplate</span>. I like{" "}
  <span class="express">express</span> more, very <span class="easy">easy</span>{" "}
  to use with <span class="ts">TS</span> too.
</div>

## 2024-09-24 14:27:16

### 今日类型体操

- Get Return Type

```ts
type MyReturnType<T extends (...args: unknown[]) => unknown> = T extends (
  ...args: unknown[]
) => infer R
  ? R
  : never;
```

<details>
<summary>解释</summary>

这个问题涉及到 TypeScript 中的条件类型和推断类型。让我们逐行解析这段代码，看看它是如何工作的，以及它的主要目标是什么。

### 代码解析

```typescript
type MyReturnType<T extends (...args: unknown[]) => unknown> = T extends (
  ...args: unknown[]
) => infer R
  ? R
  : never;
```

1. **`type MyReturnType<T extends (...args: unknown[]) => unknown>`**:

   - 这里定义了一个类型别名 `MyReturnType`，它接受一个类型参数 `T`。
   - `T` 被约束为一个函数类型，函数可以接受任意数量的参数（`...args: unknown[]`），并且返回一个未知类型的值（`=> unknown`）。

2. **`T extends (...args: unknown[]) => infer R`**:

   - 这是一个条件类型，检查 `T` 是否符合函数类型的结构。
   - `infer R` 是 TypeScript 的一种类型推断机制，它会从 `T` 中推断出返回值的类型，并将其命名为 `R`。

3. **`? R : never`**:
   - 如果 `T` 符合函数类型的结构，那么 `MyReturnType` 的结果就是 `R`（即函数的返回值类型）。
   - 如果 `T` 不符合这个结构，则返回 `never`，表示这个类型是不可用的。

### 主要目标

`MyReturnType` 的主要目标是从给定的函数类型 `T` 中提取出其返回值的类型。这在 TypeScript 中非常有用，尤其是在处理高阶函数或需要根据函数类型动态生成类型的场景中。

### 示例

让我们看一个简单的示例，帮助你更好地理解这个类型的用法：

```typescript
function exampleFunction(): number {
  return 42;
}

type ResultType = MyReturnType<typeof exampleFunction>; // ResultType 将被推断为 number
```

在这个例子中，`exampleFunction` 是一个返回 `number` 的函数。通过 `MyReturnType`，我们可以提取出它的返回值类型，`ResultType` 将被推断为 `number`。

### 总结

`MyReturnType` 是一个非常强大的工具，可以帮助你在 TypeScript 中更好地处理函数类型，提取返回值类型。它利用了条件类型和类型推断的特性，使得类型系统更加灵活和强大。希望这个解释能帮助你更好地理解这段代码的功能和效果！如果还有其他问题，随时问我哦！😄

</details>

### 今日英语

<blockquote>
  Fabric is a <span class="fabric">JSON schema</span> for describing{" "}
  <span class="cesiumjs">materials in CesiumJS </span>.Materials represent the
  appearance of an object such as <span class="polygons">polygons</span> ,
  <span class="polylines">polylines</span>,{" "}
  <span class="ellipsoids">ellipsoids</span>, and{" "}
  <span class="sensors">sensors</span>.<br />
  Note: For details about applying{" "}
  <span class="custom-materials">custom materials</span> to{" "}
  <span class="d_models">3D models</span>or{" "}
  <span class="d_tiles">3D Tiles</span>, use the{" "}
  <span class="custom-shader-guide">Custom Shader Guide</span> instead.
  <br />
  Materials can be as simple as draping an image over an object, or applying a
  pattern such as <span class="stripes">stripes</span>or a{" "}
  <span class="checkerboard">checkerboard</span>. Using Fabric and{" "}
  <span class="glsl"> GLSL </span>, new materials can be scripted from scratch
  or created by combining existing materials in a hierarchy; for example,{" "}
  <span class="wet-bricks"> wet crumbling bricks </span> can be created with a
  combination of <span class="procedural-brick"> procedural brick </span> ,{" "}
  <span class="bump-map">bump map</span>, and{" "}
  <span class="specular-map"> specular map </span> materials.
</blockquote>

<blockquote>
Fabric是一个用于描述CesiumJS中材料的JSON架构。材料表示对象的外观，例如多边形、折线、椭球体和传感器。

注意：有关将自定义材料应用于3D模型或3D Tiles的详细信息，请使用自定义着色器指南。

材料可以简单到仅仅是将图像覆盖在对象上，或者应用如条纹或棋盘格等图案。使用Fabric和GLSL，可以从头开始编写新的材料，或者通过组合现有材料创建层次结构的新材料；例如，可以通过程序生成的砖块、凹凸贴图和高光贴图材料的组合来创建湿润的破碎砖块。

</blockquote>

### 今日发现

之前总想着在vscode里放浏览器，没想到...

<img src="/assets/gif/workspace.gif" class="3/4" />

### 今日cesium

- 自定义shader

<details>
<summary>[相关文档](https://github.com/CesiumGS/cesium/blob/main/Documentation/CustomShaderGuide/README.md)</summary>

import CustomShaderDemo from "@components/react/cesium/customShader/demo.tsx";

<CustomShaderDemo client:visible />

</details>

## 2024-09-25 09:20:52

### 今日类型体操

- 手写<span class="Omit">Omit</span>\<T,K>

<details>
<summary>`type MyOmit<T, K extends keyof T> = {[P in keyof T as P extends K ? never : P]: T[P]}`</summary>

好的，让我们来深入理解这个 `MyOmit` 类型的定义。

### `MyOmit` 类型的目的

`MyOmit` 是一个自定义的 TypeScript 类型，用于从一个对象类型 `T` 中排除指定的键 `K`。换句话说，它会返回一个新类型，该类型与 `T` 相同，但不包含 `K` 中指定的属性。

### 代码解析

```typescript
type MyOmit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};
```

#### 逐行解析

1. **`type MyOmit<T, K extends keyof T>`**:

   - 这里定义了一个类型 `MyOmit`，它接受两个类型参数：
     - `T`：表示要操作的对象类型。
     - `K`：表示要排除的键，`K` 必须是 `T` 的键之一（`K extends keyof T`）。

2. **`{ [P in keyof T as P extends K ? never : P]: T[P] }`**:
   - 这是一个映射类型（Mapped Type），用于构建新类型。
   - `P in keyof T`：遍历 `T` 的所有键。
   - `as P extends K ? never : P`：这是一个条件类型，用于决定是否保留当前键 `P`。
     - 如果 `P` 是 `K` 中的一个键（即要排除的键），则返回 `never`，表示不保留这个键。
     - 否则，保留这个键 `P`。
   - `T[P]`：表示新类型中对应键 `P` 的值类型。

### 整体效果

通过这个定义，`MyOmit` 会创建一个新类型，包含 `T` 中所有的键，除了那些在 `K` 中指定的键。例如：

```typescript
type Person = {
  name: string;
  age: number;
  address: string;
};

type OmittedPerson = MyOmit<Person, "age" | "address">;
// OmittedPerson 的类型为 { name: string }
```

在这个例子中，`OmittedPerson` 类型将只包含 `name` 属性，因为 `age` 和 `address` 被排除了。

### 总结

`MyOmit` 是一个非常实用的工具类型，可以帮助你在 TypeScript 中灵活地处理对象类型，排除不需要的属性。通过使用映射类型和条件类型，`MyOmit` 提供了一种优雅的方式来创建新的类型。希望这个解释能帮助你更好地理解 TypeScript 的类型系统！如果还有其他问题，随时问我哦！

</details>

### 今日英语

<details>
<summary>wasm intro</summary>

WebAssembly, or WASM for short, is a new technology for running portable programs in a safe and efficient manner <span class="primarily">primarily</span> aimed at the web platform. Similarly to ASM.js, WASM aims at a low level-of abstraction suitable as an intermediate representation of a higher-level program — i.e. WebAssembly code is intended to be generated by compilers rather than being written by humans. The W3C community group includes representatives from the largest web-browser companies, including Google, Microsoft, Apple and Mozilla making this whole thing rather exciting.

WebAssembly（简称 WASM）是一种新技术，旨在以安全和高效的方式在网络平台上运行可移植程序。与 ASM.js 类似，WASM 旨在提供一种低抽象级别的表示，适合作为更高层次程序的中间表示——即 WebAssembly 代码主要是由编译器生成，而不是由人手动编写的。

WASM 的设计目标是实现接近原生的执行速度，同时保持与现有 Web 技术的兼容性。WASM 的开发得到了 W3C 社区小组的支持，该小组包括来自 Google、Microsoft、Apple 和 Mozilla 等主要浏览器公司的代表，这使得这一技术的发展充满了期待。

通过 WebAssembly，开发者可以使用 C、C++、Rust 等语言编写高性能的代码，并将其编译为 WebAssembly 格式，从而在浏览器中运行。这种方式不仅提高了 Web 应用的性能，还扩展了 Web 平台的能力，使得开发者能够构建更复杂的应用程序，如游戏、图形处理和科学计算等。

If you’re reading this chances are you’re already familiar with WASM to some extent. If you aren’t, this would be a good time to check out webassembly.org. At the time of publishing this article, WebAssembly has just reached the Browser Preview milestone, meaning that version 1 of WebAssembly will very likely be what the current draft describes. The specifics of this article are for version mvp-13.

如果你正在阅读这篇文章，那么你很可能对 WebAssembly（WASM）已经有一定的了解。如果你还不熟悉，这正是一个很好的时机去查看 webassembly.org。在本文发布时，WebAssembly 刚刚达到了浏览器预览的里程碑，这意味着 WebAssembly 的第一个版本很可能就是当前草案所描述的内容。本文的具体内容是针对版本 mvp-13 的。

WebAssembly really has no dependencies on anything “web” and its module and bytecode format is at such a low level that it can be used to represent any other higher-level program.
There are several high-quality VMs being implemented, many of them in web browser, which can execute WASM programs efficiently, making distribution a bliss (the web!)
WASM code can be translated to machine code.
WASM can be interpreted and emulated which makes debugging a whole lot more pleasant than debugging programs which only run natively. How about we stop the world and interactively inspect the stack? How about we play back an interpreted recording that reproduces a bug deterministically?

WebAssembly（WASM）确实是一个非常强大的技术，它的设计使其能够独立于任何特定的“网络”环境。WASM 的模块和字节码格式非常低级，这意味着它可以用来表示任何其他更高级的程序。这种灵活性使得它在各种应用场景中都能发挥作用，尤其是在 Web 开发中。

目前，有许多高质量的虚拟机（VM）正在实现，许多都在网页浏览器中运行，这使得执行 WASM 程序变得高效且简单。由于 WASM 的可移植性，开发者可以轻松地将其分发到不同的平台上，这无疑是 Web 开发的一大福音。

WASM 代码可以被翻译成机器代码，这意味着它可以在不同的硬件上高效运行。此外，WASM 还支持解释和仿真，这使得调试过程变得更加愉快。开发者可以通过交互式地检查堆栈，甚至可以回放一个解释的记录，以确定性地重现一个 bug，这在传统的本地程序调试中是很难实现的。

这种调试能力的提升，结合 WASM 的高效执行和广泛的兼容性，使得它成为现代 Web 开发中不可或缺的工具。通过 WASM，开发者可以更轻松地构建复杂的应用程序，同时享受更好的性能和更简化的调试过程。

</details>

## 2024-09-28 16:53:22

今日加班

### 今日阅读

- [bad css-dad jokes](https://alvaromontoro.com/blog/68063/bad-css-dad-jokes-ii)
- [css render reference](https://nolanlawson.com/2024/09/18/improving-rendering-performance-with-css-content-visibility/)
- [设计一个APP](https://ishadeed.com/work/tuhoon/)
- [前端开发现状](https://polotek.net/posts/the-frontend-treadmill/)

<blockquote>

文章讨论了前端开发的现状，作者认为许多开发者陷入了一个循环，总是在学习新的框架、库和工具，但实际上并没有真正提高自己的技能。

文章指出，前端开发的知识半衰期很短，很多开发者花太多时间学习新的东西，而没有真正掌握基础知识。作者称之为 “前端跑步机”，因为开发者总是在跑步，但实际上并没有前进。

文章还提到了 React 的例子，作者认为 React 的生态系统非常庞大和复杂，很多开发者花太多时间学习 React 的各种库和工具，而没有真正理解 React 的核心概念。

总的来说，文章鼓励开发者不要陷入 “前端跑步机” 的陷阱，而是应该专注于学习和掌握基础知识，真正提高自己的技能。

</blockquote>

- [CSS Almanac](https://css-tricks.com/almanac/)

<DriverNoText
  client:load
  elements='[
          {"element":".fabric","popover":{"title":"JSON schema","description":"用于描述数据结构的格式，便于数据的交换和存储。"}},
          {"element":".cesiumjs","popover":{"title":"materials in CesiumJS","description":"CesiumJS中的材料，用于定义3D对象的外观。"}},
          {"element":".polygons","popover":{"title":"polygons","description":"多边形，表示二维平面上的封闭形状。"}},
          {"element":".polylines","popover":{"title":"polylines","description":"折线，由多个线段连接而成的图形。"}},
          {"element":".ellipsoids","popover":{"title":"ellipsoids","description":"椭球体，三维空间中的一种曲面。"}},
          {"element":".sensors","popover":{"title":"sensors","description":"传感器，用于收集环境数据的设备。"}},
          {"element":".custom-materials","popover":{"title":"custom materials","description":"自定义材料，用户定义的材料类型。"}},
          {"element":".d_models","popover":{"title":"3D models","description":"三维模型，表示物体的三维形态。"}},
          {"element":".d_tiles","popover":{"title":"3D Tiles","description":"用于高效传输和渲染大规模3D城市和建筑数据的格式。"}},
          {"element":".custom-shader-guide","popover":{"title":"Custom Shader Guide","description":"自定义着色器指南，提供如何创建和应用自定义着色器的详细信息。"}},
          {"element":".stripes","popover":{"title":"stripes","description":"条纹图案，交替的颜色或纹理。"}},
          {"element":".checkerboard","popover":{"title":"checkerboard","description":"棋盘格图案，交替的黑白方块。"}},
          {"element":".glsl","popover":{"title":"GLSL","description":"OpenGL着色语言，用于编写图形渲染的着色器。"}},
          {"element":".wet-bricks","popover":{"title":"wet crumbling bricks","description":"湿润的破碎砖块，表示一种特定的材料效果。"}},
          {"element":".procedural-brick","popover":{"title":"procedural brick","description":"程序生成的砖块材料，用于创建复杂的表面效果。"}},
          {"element":".bump-map","popover":{"title":"bump map","description":"凹凸贴图，用于在不增加几何体的情况下添加表面细节。"}},
          {"element":".specular-map","popover":{"title":"specular map","description":"高光贴图，用于定义表面反射光的强度。"}},
          {"element":".use","popover":{"title":"use","description":"表示应用或使用某物，通常指工作或开发中的实践。"}},
          {"element":".nestjs","popover":{"title":"Nest.Js","description":"一种渐进式的Node.js框架，专为构建可扩展的服务器端应用而设计，结合了面向对象和函数式编程。"}},
          {"element":".dislike","popover":{"title":"don’t like it","description":"表达对某事物的反感或不满。此处指作者不喜欢Nest.Js。"}},
          {"element":".boilerplate","popover":{"title":"boilerplate","description":"指重复的、冗余的代码，通常是开发者认为不必要或繁琐的部分。"}},
          {"element":".express","popover":{"title":"express","description":"一个简洁且灵活的Node.js框架，用于构建服务器端应用，开发者常称其为轻量、快速。"}},
          {"element":".easy","popover":{"title":"easy","description":"表示简单、方便，此处指Express.js比Nest.Js更加容易使用。"}},
          {"element":".ts","popover":{"title":"TS","description":"TypeScript的简称，是JavaScript的超集，添加了静态类型支持。"}},
          {"element":".primarily","popover":{"title":"primarily","description":"Primarily的中文翻译是“主要”或“首要地”。它通常用于强调某事物的主要目的或功能。在讨论 WebAssembly 的背景时，可以这样使用：英文： WebAssembly, or WASM for short, is a new technology for running portable programs in a safe and efficient manner primarily aimed at the web platform.中文翻译： WebAssembly（简称 WASM）是一种新技术，旨在以安全和高效的方式运行可移植程序，主要面向网络平台。在这个例子中，“primarily” 强调了 WebAssembly 的主要目标是为网络平台服务。"}}
        ]'
/>

### 今日探索

> [lume](https://lume.io/)

> [lume demo page](https://docs.lume.io/examples/disco-helmet/example.html)

> [yew](https://yew.rs/)

## 2024-09-29 15:46:28

### 今日ui库

- [daisyui](https://github.com/saadeghi/daisyui)

## 2024-09-30 08:57:15

> 九月最后一天

### 今日知识

<details>
<summary>盘前竞价</summary>

- by mata-liama-3.1-75B-Instruct

盘前竞价（盘前交易）是指在正常交易时间之前进行的股票交易。具体来说，盘前交易通常在美国东部时间上午4:00至9:30之间进行。在这个时间段里，投资者可以根据需求买卖股票。然而，由于交易者较少，股票流动性较差，买卖价差较大，影响了股票价格。许多交易者发现，在盘前交易会产生更多的价格波动，上涨和下跌的幅度更大，因此需要使用限价订单。

- by chatgpt-4o mini

盘前竞价是指在正式交易开始之前，投资者可以进行股票买卖的交易时段。通常，盘前交易时间是在市场正式开盘之前的一段时间，具体时间因交易所而异。例如，在美国股市，盘前交易一般从早上4:00到9:30（东部时间）进行。
在盘前竞价期间，投资者可以根据市场新闻、财报发布等信息提前进行交易。这一阶段的交易量通常较低，价格波动可能较大，因为参与者相对较少，流动性不足。因此，投资者在进行盘前交易时需要特别注意价格的波动和潜在的风险。
盘前竞价的主要目的是让投资者在市场开盘前能够对即将到来的市场动态做出反应，从而更好地管理自己的投资策略。

</details>

## 2024-09-30 16:43:13

<details>
<summary>转融通归还股票</summary>

转融通归还股票是指在转融通业务中，投资者将借入的股票归还给证券公司或金融机构的过程。转融通是指证券公司通过融资融券的方式，将其客户的股票借出给其他投资者，以获取一定的利息或费用。

### 归还股票的流程：

1. **通知归还**：投资者在决定归还股票时，需要提前通知证券公司，通常可以通过交易软件或客服进行操作。
2. **确认归还数量**：投资者需要确认要归还的股票数量，并确保账户中有足够的股票。
3. **提交归还申请**：在交易软件中提交归还申请，系统会自动处理归还的相关事务。
4. **完成归还**：证券公司确认归还申请后，会将相应的股票从投资者的账户中扣除，并将其归还给出借方。

### 注意事项：

- **归还时间**：投资者需要注意归还的时间限制，通常在借入股票的合约中会有明确的归还期限。
- **费用问题**：归还股票可能会涉及到一定的费用，投资者需要提前了解相关费用标准。
- **市场风险**：在归还股票之前，投资者应考虑市场行情，以免在不利的市场条件下进行归还。

通过以上流程，投资者可以顺利地完成转融通归还股票的操作。

</details>

[<div class="p-10 m-10 text-lg indent-3.5 text-center stroke-card-foreground hover:no-underline">更多内容,请看下月记录</div>](/posts/2024-10)
