---
author: ajn404
pubDatetime: 2024-09-04T05:44:43Z
title: 2024年9月
postSlug: 2024-09
tags:
  - "2024"
  - "2024-09"
description: 上个月不算，八月公司的活有点多，这个月重来
---

import Driver from "@components/react/little/driver.tsx";
import DriverNoText from "@components/react/little/driverNoText.tsx";
import Tag from "@components/astro/UI/Tag.astro";

## 目录

## 2024-09-04 14:06:14

<Tag name="ts" className="max-w-[100px]" />

[ts5.6 RC 新特性](https://devblogs.microsoft.com/typescript/announcing-typescript-5-6-rc/#disallowed-nullish-and-truthy-checks)

## 2024-09-18 10:32:06

<details open>
<summary>view transition api</summary>
**View Transition API** 是一个新兴的 Web API，用于在 Web 应用中创建无缝的页面或组件过渡动画。它通过浏览器级别的渲染技术，简化了在单页应用（SPA）或多页应用（MPA）中实现平滑过渡动画的过程，使页面内容的变化更流畅和自然。

### 主要特性

- **无缝过渡**：允许在页面切换、组件状态变化时，提供平滑的视觉过渡效果。
- **元素的关联**：可以标记页面中变化的元素，浏览器会自动计算和动画化它们在两个状态之间的过渡。
- **简化过渡动画的编写**：开发者无需手动管理复杂的动画逻辑，只需要声明哪些元素需要过渡，浏览器会自动计算和应用动画。
- **适用于多种场景**：可以用于单页应用（SPA）中的路由切换，也可以用于多页应用（MPA）中的页面切换。

### 工作原理

View Transition API 利用了浏览器的渲染机制，通过快照（snapshot）页面的前后状态，然后计算和应用过渡动画，使页面切换或元素变化更加流畅。

### 基本使用方式

1. **启动过渡**：在页面状态变化时，可以通过 JavaScript 调用 `document.startViewTransition()` 来触发视图的过渡。
2. **标记过渡元素**：使用 `view-transition-name` 属性标记你想要过渡的元素，浏览器将跟踪这些元素，并应用过渡效果。

### 示例

#### 1. 单页应用中的过渡

```html
<style>
  .box {
    width: 100px;
    height: 100px;
    background-color: lightblue;
    margin: 20px;
    transition: all 0.5s ease;
  }

  .new-state {
    width: 200px;
    background-color: lightcoral;
  }
</style>

<div class="box" id="box" view-transition-name="box"></div>

<script>
  const box = document.getElementById("box");

  // 启动视图过渡
  document.getElementById("box").addEventListener("click", () => {
    document.startViewTransition(() => {
      box.classList.toggle("new-state");
    });
  });
</script>
```

在这个例子中，`startViewTransition()` 被用来启动过渡动画，当点击 `box` 时，它会在两种状态（原始状态和 `new-state`）之间进行平滑的过渡。

#### 2. 多页应用中的过渡

View Transition API 还可以在页面导航时用于多页应用，确保页面切换动画也同样流畅。

```javascript
document.startViewTransition(() => {
  window.location.href = "/new-page";
});
```

当你导航到新的页面时，`startViewTransition` 将确保旧页面与新页面之间的切换是平滑的，并且浏览器会自动生成过渡动画。

### 优点

- **简化动画开发**：开发者不再需要手动处理动画的复杂细节，View Transition API 会自动管理动画的开始和结束。
- **提高性能**：由于动画由浏览器本地处理，因此能够获得更高的性能和流畅度。
- **统一过渡**：可以在页面切换、元素变化等多种场景下统一实现过渡动画效果。

### 浏览器支持

目前，View Transition API 处于实验性阶段，支持度正在逐渐提升。现代浏览器如 Chrome 110+ 已经开始支持该 API，不过其他浏览器如 Firefox 和 Safari 可能仍在开发中。可以通过 `feature-detection` 检查当前浏览器是否支持该功能。

### 总结

View Transition API 是 Web 动画开发的一个强大工具，能够大幅简化页面过渡效果的实现，尤其适用于需要在前后状态间提供平滑过渡的场景。它提升了 Web 应用的用户体验，让页面切换、状态变化更加流畅自然。

</details>

## 2024-09-18 21:09:59

决定重新学习ts

## 2024-09-20 10:30:54

token🧑‍🏫失效，很烦

### add github api

- 获取基本信息

<details>
<summary>https://api.github.com/user</summary>

import Demo from "@components/astro/github/demo.astro";

<Demo />

</details>

- 获取action状态

<details>
<summary>Click to expand</summary>

import Action from "@components/astro/github/action.astro";

<Action />{" "}

</details>

### 新增字体 Whisper

签名字体 <span class="font-whisper">Whisper</span>

<blockquote>
  <div class="font-whisper m-0 p-0 leading-none">
    From fairest creatures we desire increase,
    <br />
    That thereby beauty's rose might never die,
    <br />
    But as the riper should by time decease,
    <br />
    His tender heir might bear his memory:
    <br />
    But thou, contending with old age and death,
    <br />
    To hide thyself, diedst not leave me so.
    <br />
    Thy self thy foe, to thy sweet self too cruel,
    <br />
    Thou that art now the world's fresh ornament,
    <br />
    And only herald of the gaudy spring,
    <br />
    Wilt thou, upon the high and giddy mast,
    <br />
    Seal up thy lips, and drown the whole world in tears?
    <br />
    O, let me not be made a fool of thee,
    <br />
    To be so cruel, and yet so fair!
    <br />
  </div>
</blockquote>

### show code

<details>
<summary>今天写了一个还有点不错的代码</summary>

```js
socket = new WebSocket(`ws://${host}/websocket/position/ajn404`);
let lastExecutionTime = 0; // 上次执行时间
let cache = [];
let processing = false;
const cacheMap = new Map();

socket.addEventListener("message", function (event) {
  const parsedData = JSON.parse(event.data);

  // 处理警告通知
  if (parsedData.method === "warning") {
    showNotification(parsedData);
    return;
  }

  const currentTime = Date.now(); // 获取当前时间
  // 如果距离上次执行时间小于 100ms，则继续缓存数据
  if (currentTime - lastExecutionTime < 100) {
    cacheMap.set(parsedData.params.tagId, parsedData.params); // 用 tagId 作为键，去重存储数据
    return;
  }
  lastExecutionTime = currentTime; // 更新上次执行时间
  cacheMap.set(parsedData.params.tagId, parsedData.params); // 用 tagId 作为键，去重存储数据

  // 如果正在处理缓存中的数据，则不再处理
  if (processing) return;
  processing = true; // 标记为正在处理

  setTimeout(() => {
    // 将 Map 转换为数组，取出所有的缓存数据
    cache = Array.from(cacheMap.values());

    // 过滤并获取车辆和人员的更新数据
    const updateData = getGraphicData(
      cache.filter(item => item.entityType === "car"),
      "car"
    );

    const updateDataMember = getGraphicData(
      cache.filter(item => item.entityType === "staff"),
      "member"
    );

    // 更新车辆位置
    if (updateData && updateData.length > 0) {
      vehicleLocation.locationView.update(updateData);
    }

    // 更新人员位置
    if (updateDataMember && updateDataMember.length > 0) {
      memberLocation.locationView.update(updateDataMember);
    }

    cacheMap.clear(); // 清空 Map 以保证缓存不重复

    if (!memberLocation.positionGroupGraphics) {
      cache = [...updateDataMember];
    }

    if (!vehicleLocation.positionGroupGraphics) {
      cache = [...cache, ...updateData];
    }

    // 处理完成后清空缓存并重置标记

    processing = false;

    console.log(cache, updateDataMember, updateData);
  }, 0); // 异步处理，保证不会阻塞消息接收
});
```

</details>

### Visual Viewport API

<details>
<summary>什么是Visual Viewport API</summary>

Visual Viewport API 是一种机制，允许开发者查询和修改窗口可视区域的属性。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) 可视区域是指屏幕上除去屏幕键盘、缩放区域外以及其他不随页面缩放的屏幕元素后，实际可见的部分。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)

移动网页包含两个视口：布局视口和可视视口。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) 布局视口涵盖页面上的所有元素，而可视视口是屏幕上实际可见的部分。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)[6](https://github.com/WICG/visual-viewport) 当用户放大页面时，可视视口会缩小，但布局视口保持不变。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) 用户界面功能（如屏幕键盘）可以缩小可视视口，而不会影响布局视口。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API) Visual Viewport API 允许开发者相对于屏幕上显示的内容定位元素，从而解决布局视口和可视视口不一致的问题。 [1](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)

</details>

## 2024-09-23 14:15:19

### 今日英语

<div id="second">
  I <span id="use">use</span> <span id="nestjs">Nest.Js</span> at work but{" "}
  <span id="dislike">don’t like it</span>, too much{" "}
  <span id="boilerplate">boilerplate</span>. I like{" "}
  <span id="express">express</span> more, very <span id="easy">easy</span> to
  use with <span id="ts">TS</span> too.
</div>

<DriverNoText
  client:load
  elements='[
          {"element":"#use","popover":{"title":"use","description":"表示应用或使用某物，通常指工作或开发中的实践。","side":"top","align":"start"}},
          {"element":"#nestjs","popover":{"title":"Nest.Js","description":"一种渐进式的Node.js框架，专为构建可扩展的服务器端应用而设计，结合了面向对象和函数式编程。","side":"top","align":"start"}},
          {"element":"#dislike","popover":{"title":"don’t like it","description":"表达对某事物的反感或不满。此处指作者不喜欢Nest.Js。","side":"top","align":"start"}},
          {"element":"#boilerplate","popover":{"title":"boilerplate","description":"指重复的、冗余的代码，通常是开发者认为不必要或繁琐的部分。","side":"top","align":"start"}},
          {"element":"#express","popover":{"title":"express","description":"一个简洁且灵活的Node.js框架，用于构建服务器端应用，开发者常称其为轻量、快速。","side":"top","align":"start"}},
          {"element":"#easy","popover":{"title":"easy","description":"表示简单、方便，此处指Express.js比Nest.Js更加容易使用。","side":"top","align":"start"}},
          {"element":"#ts","popover":{"title":"TS","description":"TypeScript的简称，是JavaScript的超集，添加了静态类型支持。","side":"top","align":"start"}}
        ]'
/>

## 2024-09-24 14:27:16

### 今日类型体操

- Get Return Type

```ts
type MyReturnType<T extends (...args: unknown[]) => unknown> = T extends (
  ...args: unknown[]
) => infer R
  ? R
  : never;
```

<details>
<summary>解释</summary>

这个问题涉及到 TypeScript 中的条件类型和推断类型。让我们逐行解析这段代码，看看它是如何工作的，以及它的主要目标是什么。

### 代码解析

```typescript
type MyReturnType<T extends (...args: unknown[]) => unknown> = T extends (
  ...args: unknown[]
) => infer R
  ? R
  : never;
```

1. **`type MyReturnType<T extends (...args: unknown[]) => unknown>`**:

   - 这里定义了一个类型别名 `MyReturnType`，它接受一个类型参数 `T`。
   - `T` 被约束为一个函数类型，函数可以接受任意数量的参数（`...args: unknown[]`），并且返回一个未知类型的值（`=> unknown`）。

2. **`T extends (...args: unknown[]) => infer R`**:

   - 这是一个条件类型，检查 `T` 是否符合函数类型的结构。
   - `infer R` 是 TypeScript 的一种类型推断机制，它会从 `T` 中推断出返回值的类型，并将其命名为 `R`。

3. **`? R : never`**:
   - 如果 `T` 符合函数类型的结构，那么 `MyReturnType` 的结果就是 `R`（即函数的返回值类型）。
   - 如果 `T` 不符合这个结构，则返回 `never`，表示这个类型是不可用的。

### 主要目标

`MyReturnType` 的主要目标是从给定的函数类型 `T` 中提取出其返回值的类型。这在 TypeScript 中非常有用，尤其是在处理高阶函数或需要根据函数类型动态生成类型的场景中。

### 示例

让我们看一个简单的示例，帮助你更好地理解这个类型的用法：

```typescript
function exampleFunction(): number {
  return 42;
}

type ResultType = MyReturnType<typeof exampleFunction>; // ResultType 将被推断为 number
```

在这个例子中，`exampleFunction` 是一个返回 `number` 的函数。通过 `MyReturnType`，我们可以提取出它的返回值类型，`ResultType` 将被推断为 `number`。

### 总结

`MyReturnType` 是一个非常强大的工具，可以帮助你在 TypeScript 中更好地处理函数类型，提取返回值类型。它利用了条件类型和类型推断的特性，使得类型系统更加灵活和强大。希望这个解释能帮助你更好地理解这段代码的功能和效果！如果还有其他问题，随时问我哦！😄

</details>

### 今日英语

Fabric is a <span id="fabric">JSON schema</span> for describing <span id="cesiumjs">materials in CesiumJS</span>.
Materials represent the appearance of an object such as <span id="polygons">polygons</span>,

{" "}
<span id="polylines">polylines</span>, <span id="ellipsoids">ellipsoids</span>,
and <span id="sensors">sensors</span>.
<br />
Note: For details about applying <span id="custom-materials">
  custom materials
</span> to <span id="d_models">3D models</span>
or <span id="d_tiles">3D Tiles</span>, use the <span id="custom-shader-guide">
  Custom Shader Guide
</span> instead.
<br />
Materials can be as simple as draping an image over an object, or applying a
pattern such as <span id="stripes">stripes</span>
or a <span id="checkerboard">checkerboard</span>. Using Fabric and <span id="glsl">
  GLSL
</span>
, new materials can be scripted from scratch or created by combining existing
materials in a hierarchy; for example, <span id="wet-bricks">
  wet crumbling bricks
</span>
can be created with a combination of <span id="procedural-brick">
  procedural brick
</span>
, <span id="bump-map">bump map</span>, and <span id="specular-map">
  specular map
</span> materials.

<blockquote>
Fabric是一个用于描述CesiumJS中材料的JSON架构。材料表示对象的外观，例如多边形、折线、椭球体和传感器。

注意：有关将自定义材料应用于3D模型或3D Tiles的详细信息，请使用自定义着色器指南。

材料可以简单到仅仅是将图像覆盖在对象上，或者应用如条纹或棋盘格等图案。使用Fabric和GLSL，可以从头开始编写新的材料，或者通过组合现有材料创建层次结构的新材料；例如，可以通过程序生成的砖块、凹凸贴图和高光贴图材料的组合来创建湿润的破碎砖块。

</blockquote>

<DriverNoText
  client:load
  elements='[
          {"element":"#fabric","popover":{"title":"JSON schema","description":"用于描述数据结构的格式，便于数据的交换和存储。","side":"top","align":"start"}},
          {"element":"#cesiumjs","popover":{"title":"materials in CesiumJS","description":"CesiumJS中的材料，用于定义3D对象的外观。","side":"top","align":"start"}},
          {"element":"#polygons","popover":{"title":"polygons","description":"多边形，表示二维平面上的封闭形状。","side":"top","align":"start"}},
          {"element":"#polylines","popover":{"title":"polylines","description":"折线，由多个线段连接而成的图形。","side":"top","align":"start"}},
          {"element":"#ellipsoids","popover":{"title":"ellipsoids","description":"椭球体，三维空间中的一种曲面。","side":"top","align":"start"}},
          {"element":"#sensors","popover":{"title":"sensors","description":"传感器，用于收集环境数据的设备。","side":"top","align":"start"}},
          {"element":"#custom-materials","popover":{"title":"custom materials","description":"自定义材料，用户定义的材料类型。","side":"top","align":"start"}},
          {"element":"#d_models","popover":{"title":"3D models","description":"三维模型，表示物体的三维形态。","side":"top","align":"start"}},
          {"element":"#d_tiles","popover":{"title":"3D Tiles","description":"用于高效传输和渲染大规模3D城市和建筑数据的格式。","side":"top","align":"start"}},
          {"element":"#custom-shader-guide","popover":{"title":"Custom Shader Guide","description":"自定义着色器指南，提供如何创建和应用自定义着色器的详细信息。","side":"top","align":"start"}},
          {"element":"#stripes","popover":{"title":"stripes","description":"条纹图案，交替的颜色或纹理。","side":"top","align":"start"}},
          {"element":"#checkerboard","popover":{"title":"checkerboard","description":"棋盘格图案，交替的黑白方块。","side":"top","align":"start"}},
          {"element":"#glsl","popover":{"title":"GLSL","description":"OpenGL着色语言，用于编写图形渲染的着色器。","side":"top","align":"start"}},
          {"element":"#wet-bricks","popover":{"title":"wet crumbling bricks","description":"湿润的破碎砖块，表示一种特定的材料效果。","side":"top","align":"start"}},
          {"element":"#procedural-brick","popover":{"title":"procedural brick","description":"程序生成的砖块材料，用于创建复杂的表面效果。","side":"top","align":"start"}},
          {"element":"#bump-map","popover":{"title":"bump map","description":"凹凸贴图，用于在不增加几何体的情况下添加表面细节。","side":"top","align":"start"}},
          {"element":"#specular-map","popover":{"title":"specular map","description":"高光贴图，用于定义表面反射光的强度。","side":"top","align":"start"}}
        ]'
/>

### 今日发现

之前总想着在vscode里放浏览器，没想到...

<img src="/assets/gif/workspace.gif" class="3/4" />
