---
author: ajn404
pubDatetime: 2024-10-01T21:04:32Z
title: 2024年10月
postSlug: 2024-10
tags:
  - "2024"
  - "2024-10"
  - "calender"
  - "股票"
  - ts challenge
  - ts
description: 又是10月，写这份博客整整1年，1年，人生有几个1年
---

<blockquote>
但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布散烈烈朝晖之时。

那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。

当然，那不是我。

但是，那不是我吗？

<cite class="text-right w-full">《我与地坛》</cite>
</blockquote>

## 感慨

他跨越了我二十多岁的两个阶段，从上海到北京，从悠闲到忙碌，从《生死疲劳》和《悉达多》到《沉默的大多数》,《被讨厌的勇气》,《剑来》，从cordova,vue2到jecloud,vue3,cesium,webrtc

## 目录

## 2024-10-01 22:45:16

在归途，动车上写一些代码，看一些书，观察一些群，看看一些股票，了解一些新闻

## 2024-10-02 05:03:40

创造力比公司上班多很多，虽然身体非常之疲惫

## 2024-10-04 09:14:35

早起于山间，代码和数学，哇咔咔咔咔

和平万岁，祖国万岁，共产党万岁

## 2024-10-05 18:30:38

<details>
<summary>非农数据表示什么</summary>

非农数据，全称是“非农业就业人数变动”，指的是美国每月新增的非农业就业人口数量。 它是由美国劳工统计局 (Bureau of Labor Statistics, BLS) 每月发布的一项重要经济指标。

这个数据**不包含**以下几种就业人口：

- **农业就业人口:** 从事农业生产相关工作的人员。
- **政府雇员:** 联邦政府雇员（例如，军队人员）。
- **私人家庭雇员:** 例如保姆、家政人员等。
- **非营利组织雇员:** 例如慈善机构、宗教组织的雇员。
- **自雇人士:** 自己经营生意的人员。

非农数据反映的是美国就业市场的整体状况，是衡量美国经济健康程度的重要指标之一。 它通常被用来预测经济增长、通货膨胀和利率变化等。

**非农数据对市场的影响：**

非农数据公布后，通常会对金融市场产生显著影响，尤其是在外汇市场和股票市场。 如果非农数据好于预期（新增就业人数多于预期），通常被认为是经济向好信号，美元汇率可能上涨，股市也可能上涨。 反之，如果非农数据差于预期，则可能导致美元汇率下跌，股市下跌。 当然，市场反应也受到其他因素的影响，并非完全取决于非农数据本身。

总而言之，非农数据是一个综合性的经济指标，它反映了美国就业市场的状况，并对金融市场产生重要的影响。 投资者和经济学家密切关注非农数据，以预测经济走势并做出相应的投资决策。

</details>

## 2024-10-09 15:15:58

<details>
<summary>A股可以做空吗</summary>

A股市场目前允许一定程度的做空，但与成熟市场相比，机制和渠道相对有限。主要有以下几种方式:

1. 融券做空: 这是A股市场最主要的做空方式。投资者可以向券商借入股票，然后在市场上卖出，等待股价下跌后再买回股票归还给券商，从而赚取差价。 [1](https://www.investopedia.com/terms/s/shortselling.asp)[2](https://www.nerdwallet.com/article/investing/shorting-a-stock)[3](https://www.bankrate.com/investing/short-selling-how-to-short-a-stock/) 融券做空需要投资者具备一定的资格条件，并且需要支付一定的利息和费用。

2. 股指期货: 通过股指期货，投资者可以押注股市指数的涨跌。如果预期市场下跌，可以卖出股指期货合约，待指数下跌后再买回平仓，从而获利。[6](<https://en.wikipedia.org/wiki/Short_(finance)>) 股指期货交易的杠杆效应较高，风险也相对较大。

3. 上证50ETF期权: 与股指期货类似，ETF期权也提供了做空市场的工具。投资者可以买入看跌期权，或者卖出看涨期权，从而在市场下跌时获利。

需要注意的是，A股市场做空机制仍不够完善，存在一些限制，例如：

- 融券券源有限：并非所有股票都可以融券，且可融券的股票数量有限，这限制了做空者的操作空间。[1](https://www.investopedia.com/terms/s/shortselling.asp)
- 做空成本较高：融券利息、交易佣金等成本会降低做空的收益。[1](https://www.investopedia.com/terms/s/shortselling.asp)
- 制度限制：A股市场对做空交易有一些限制，例如禁止裸卖空等。[2](https://www.nerdwallet.com/article/investing/shorting-a-stock)

总而言之，虽然A股可以做空，但操作难度和风险都比较高，投资者需要谨慎操作，深入研究市场，并控制好风险。 [5](https://www.mfaalts.org/issue/short-selling-is-essential-for-healthy-markets) 毕竟，做空就像刀尖上跳舞，高收益伴随着高风险。

</details>

## 2024-10-09 15:41:29

### 用`p5js`,提供一个酒瓶的3d模版,实现贴图和贴文字

<details class="relative">
<summary>[bottle](/fantastic/bottle)</summary>

[查看页面](/fantastic/bottle)

```tsx
import type p5 from "p5";
import Basic from "@components/react/p5/index.tsx";
import { useCallback, useRef, useState } from "react";

let img;
let bottleModel;
let font;
let canvas;
let button: p5.Element;
const colors = [
  { background: "#FF5733", text: "#FFFFFF" }, // 背景：红色，字体：白色
  { background: "#33FF57", text: "#000000" }, // 背景：绿色，字体：黑色
  { background: "#3357FF", text: "#FFFFFF" }, // 背景：蓝色，字体：白色
  { background: "#F1C40F", text: "#000000" }, // 背景：黄色，字体：黑色
  { background: "#8E44AD", text: "#FFFFFF" }, // 背景：紫色，字体：白色
  { background: "#E67E22", text: "#FFFFFF" }, // 背景：橙色，字体：白色
  { background: "#2ECC71", text: "#FFFFFF" }, // 背景：亮绿色，字体：白色
  { background: "#3498DB", text: "#FFFFFF" }, // 背景：亮蓝色，字体：白色
  { background: "#9B59B6", text: "#FFFFFF" }, // 背景：淡紫色，字体：白色
  { background: "#F39C12", text: "#FFFFFF" }, // 背景：金色，字体：白色
];
export default () => {
  const container = useRef(null);
  const fileInput = useRef(null);
  const [imgUrl, setImgUrl] = useState(8);

  const randomImg = () => {
    let num = ((Math.random() * 11) % 11) + 1;
    num = Number(num.toFixed(0));
    setImgUrl(num);
  };

  const sketch = useCallback(
    (p: p5) => {
      const setup = () => {
        canvas = p.createCanvas(p.windowWidth, p.windowHeight - 200, p.WEBGL);
        canvas.drop(gotFile);
        p.textFont(font);
        button = p
          .createButton("切换背景颜色")
          .position(20, 100)
          .mousePressed(randomColor);

        fileInput.current.addEventListener(
          "change",
          e => {
            let file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = event => {
              const fileData = event.target.result;
              gotFile({
                type: "image",
                data: fileData,
              });
            };
            reader.onerror = error => {
              console.error("读取文件时出错:", error);
            };
            reader.readAsDataURL(file);
          },
          false
        );
      };

      function randomColor() {
        let c = Math.floor(Math.random() * colors.length);
        button.value(c);
      }

      const preload = () => {
        img = p.loadImage(
          `/assets/bg/${imgUrl}${Math.random() > 0.5 ? ".jpg" : ".png"}`
        );
        font = p.loadFont("/assets/font/Xingcao.ttf");
        bottleModel = p.loadModel(
          "/assets/models/obj/up_glucose_bottle.obj",
          true,
          () => {},
          () => {},
          ".obj"
        );
      };

      const gotFile = (file: Pick<p5.File, "type" | "data">) => {
        if (file.type === "image") {
          img = p.createImg(file.data, "").hide();
          img.elt.onload = () => {
            randomColor();
            p.redraw();
          };
        }
      };

      const draw = () => {
        p.textureMode(p.IMAGE);
        p.background(colors[(button.value() as number) || 0].background);
        p.orbitControl();
        p.push();
        p.scale(2);
        p.rotateZ(p.PI);
        p.rotateY(-p.PI / 2);
        if (bottleModel) {
          p.texture(img); // 应用贴图
          p.model(bottleModel); // 绘制模型
        } else {
          console.error("Bottle model is not loaded");
        }
        p.push();
        p.translate(-100, 0, 0); // 将文字放置在模型旁边

        p.rotateY(-p.PI / 2);
        p.rotateX(-p.PI);

        p.fill(colors[(button.value() as number) || 0].text);
        p.text("尝试拖动图片进场景或者点击上传", 0, 0);
        p.pop();
      };
      const resize = () => {
        p.resizeCanvas(p.windowWidth, p.windowHeight - 200);
        p.redraw();
      };
      p.setup = setup;
      p.draw = draw;
      p.preload = preload;
      p.windowResized = resize;
    },
    [imgUrl]
  );

  return (
    <div ref={container} className="absolute inset-0 w-full h-full">
      <Basic
        sketch={sketch}
        className="min-h-[80%] flex justify-center items-center"
      ></Basic>
      <input
        type="file"
        id="input"
        accept="image/*"
        className="hidden"
        ref={fileInput}
      />

      <label
        htmlFor="input"
        className="block cursor-pointer text-center self-center p-4 m-auto font-semibold text-2xl xing-cao"
      >
        点击上传材质
      </label>

      <p
        onClick={randomImg}
        className="block cursor-pointer text-center self-center p-4 m-auto font-semibold text-2xl xing-cao"
      >
        或者点击使用随机图片
      </p>
    </div>
  );
};
```

</details>

## 2024-10-10 09:28:50

`loadScript`

```js
const loadScript = (src, callback) => {
  try {
    const script = document.createElement("script");
    script.src = src;
    script.onload = callback;
    script.onerror = () => alert(`Failed to load script: ${src}`);
    document.head.appendChild(script);
  } catch (e) {
    alert(e.message);
  }
};
loadScript("https://cdn.jsdelivr.net/npm/eruda@3.4.0/eruda.min.js", () =>
  eruda.init()
);
```

## 2024-10-10 15:51:33

### 今日ts代码分析

import TsCodeEqual from "@shadcn/demo/codeEqual.tsx";

<TsCodeEqual client:visible />

### calendar汇总

这些个日历样式有些问题，和博客的主题冲突了

<details>
<summary>react-big-calendar</summary>

import BigCalendar from "@components/react/little/bigCalendar";

<BigCalendar client:only="react" />

</details>

<details>
<summary>Click to expand</summary>

import ScheduleX from "@components/react/little/scheduleX.tsx";

<ScheduleX client:visible />

</details>

## 2024-10-11 09:34:21

### 今日类型体操

#### 实现`Pick<T, K extends keyof T>`

```ts
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P];
};
```

使用示例

```ts
type Person = {
  name: string;
  age: number;
  email: string;
};

// 使用 MyPick 从 Person 中选择 name 和 email 属性
type PickedPerson = MyPick<Person, "name" | "email">;

// PickedPerson 的类型为 { name: string; email: string; }
```

#### 实现`Readonly<T>`

```ts
type MyReadonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

`MyReadonly<T>` 只会对第一层属性生效。如果对象的属性本身是一个对象，嵌套的属性仍然是可写的。

```ts
type User = {
  name: string;
  address: {
    city: string;
    country: string;
  };
};

type ReadonlyUser = MyReadonly<User>;

const user: ReadonlyUser = {
  name: "Alice",
  address: {
    city: "New York",
    country: "USA",
  },
};

// 下面的操作会导致编译错误
user.name = "Bob"; // 错误: Cannot assign to 'name' because it is a read-only property.

// 但是可以修改嵌套对象的属性
user.address.city = "Los Angeles"; // 这是允许的
```

[ts文档](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)中推荐使用`Object.freeze`

```ts
function freeze<Type>(obj: Type): Readonly<Type>;
```

### 今日金融小知识

<details>
<summary>股票市场是否要跟涨杀跌</summary>

在股票市场中，"跟涨杀跌" 是一种常见的投资策略，指的是在市场上涨时跟随买入，而在市场下跌时则选择卖出或回避。这种策略的核心思想是顺应市场趋势，利用市场情绪来获取收益。以下是一些关于这一策略的分析：

### 1. 趋势跟随

跟涨杀跌的策略基于趋势跟随的原则。许多投资者相信，市场在短期内会持续其趋势，因此在上涨时买入，能够在价格进一步上涨时获利。这种策略在牛市中尤其有效，因为市场普遍情绪乐观，投资者更愿意买入。

### 2. 风险管理

尽管跟涨杀跌可以在某些情况下带来收益，但它也伴随着风险。在市场下跌时，盲目跟随可能导致更大的损失。投资者需要有良好的风险管理策略，例如设置止损点，以限制潜在的损失。

### 3. 市场情绪

股票市场受到投资者情绪的影响，跟涨杀跌策略往往依赖于市场情绪的变化。在市场情绪高涨时，投资者可能会过度乐观，导致价格泡沫；而在市场恐慌时，投资者可能会过度悲观，导致价格下跌。因此，理解市场情绪变化对于成功实施这一策略至关重要。

### 4. 基本面分析

虽然跟涨杀跌是一种短期策略，但长期投资者通常会结合基本面分析来做出决策。即使市场在上涨，投资者也应该关注公司的基本面，以确保其股票的价值是合理的。

### 5. 适合的投资者

跟涨杀跌策略适合那些能够快速反应市场变化的投资者，尤其是短线交易者。然而，对于那些更倾向于长期投资的投资者，可能更适合采用价值投资或定投策略。

### 总结

跟涨杀跌是一种基于市场趋势的投资策略，能够在特定市场环境下带来收益。然而，投资者需要谨慎对待，结合风险管理和基本面分析，以避免因市场波动而造成的损失。了解市场情绪和趋势变化是成功实施这一策略的关键。

</details>

<details>
<summary>有关交易费用</summary>

股票市场的交易费用通常由多个部分组成，具体计算方式可能因不同的券商和交易类型而异。以下是一些主要的交易费用组成部分：

### 1. **佣金费**

这是券商收取的主要费用，通常以交易金额的一定比例或固定金额的形式收取。佣金费的计算方式有几种：

- **固定佣金**：无论交易金额大小，佣金都是固定的，例如每笔交易收取20元。
- **比例佣金**：根据交易金额的一定比例收取，例如0.1%。
- **混合佣金**：有些券商可能会结合固定佣金和比例佣金，例如最低收取50元或交易金额的2%，以较高者为准。

### 2. **交易所费用**

在某些市场，交易所会收取额外的费用，这些费用通常是基于交易的数量或金额。例如，证券交易所可能会收取每笔交易的交易费。

### 3. **印花税**

在许多国家，股票交易还需支付印花税。这是一种政府征收的税费，通常在股票买卖时按交易金额的一定比例收取。例如，在中国，股票买卖的印花税通常为成交金额的0.1%。

### 4. **其他费用**

- **监管费用**：例如，证券交易委员会（SEC）可能会收取的费用。
- **结算费用**：在某些情况下，结算和交割过程可能会产生额外费用。
- **账户维护费**：一些券商可能会收取账户维护费，尤其是对于低活跃度的账户。

### 计算示例

假设你通过某券商买入价值10,000元的股票，佣金为0.1%，印花税为0.1%，交易所费用为10元，计算如下：

- **佣金费**：10,000元 \* 0.1% = 10元
- **印花税**：10,000元 \* 0.1% = 10元
- **交易所费用**：10元

总交易费用 = 佣金费 + 印花税 + 交易所费用 = 10元 + 10元 + 10元 = 30元。

### 总结

股票市场的交易费用由佣金、交易所费用、印花税及其他相关费用组成。具体费用的计算方式可能因券商和市场而异，因此在交易前了解清楚相关费用是非常重要的。

</details>

### 今日创意编程

<details>
<summary>鼠标点击黑色框框</summary>

import Wobbly from "@components/react/p5/little/wobbly.tsx";

<Wobbly client:visible />

</details>

### 今日知识

#### aab

<details>
<summary>Android App Bundle</summary>

AAB文件，即Android App Bundle，是一种Android应用程序的发布文件格式。它包含了应用程序的所有编译代码和资源，开发者在完成应用开发后，将其以AAB格式上传到Google Play商店。用户在下载应用时，实际上是从Google Play获取一个根据其设备配置生成的APK文件，而不是直接下载AAB文件[1](https://www.nextpit.com/what-is-aab-file-android)[4](https://www.appflow.ai/blog/aab-file)。

AAB文件的主要优势在于它能够根据用户设备的特定需求生成优化的APK文件。这意味着，用户只会下载适合其设备的必要资源，从而节省存储空间。例如，如果用户的设备只支持Full HD分辨率，下载的APK将不会包含4K资源[2](https://www.browserstack.com/guide/test-aab-file-on-android-device)。此外，AAB文件还提高了应用的安全性，因为APK的签名将由Google而非开发者进行，这样可以减少应用被篡改的风险[1](https://www.nextpit.com/what-is-aab-file-android)[5](https://developer.android.com/guide/app-bundle/app-bundle-format)。

</details>

### 尝试将excalidraw组件模式化

import Excalidraw from "@components/astro/UI/excalidraw.astro";

<Excalidraw file="triangle" className="w-[80vw] m-auto mt-10" />

<Excalidraw file="ffmpeg" className="w-[80vw] m-auto mt-10" />

## 2024-10-12 11:16:19

### 今日类型体操

#### MyReadonly2

```ts
type MyReadonly2<T, K extends keyof T = keyof T> = Omit<T, K> &
  Readonly<Pick<T, K>>;
```

或者

```ts
type MyReadonly2<T, K extends keyof T = keyof T> = Omit<T, K> & {
  readonly [P in K]: T[P];
};
```

#### DeepReadonly

```ts
type Primitive = string | number | boolean | bigint | symbol | undefined | null;
type Builtin = Primitive | Function | Date | Error | RegExp;

type DeepReadonly<T> = T extends Builtin
  ? T
  : T extends Map<infer K, infer V>
    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>
    : T extends ReadonlyMap<infer K, infer V>
      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>
      : T extends WeakMap<infer K, infer V>
        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>
        : T extends Set<infer U>
          ? ReadonlySet<DeepReadonly<U>>
          : T extends ReadonlySet<infer U>
            ? ReadonlySet<DeepReadonly<U>>
            : T extends WeakSet<infer U>
              ? WeakSet<DeepReadonly<U>>
              : T extends Promise<infer U>
                ? Promise<DeepReadonly<U>>
                : T extends {}
                  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
                  : Readonly<T>;
```

## 2024-10-14 10:50:00

### 今日ui

import FloatingDock from "@components/react/aceternity/demo/floating-dock.tsx";

<FloatingDock client:load />

### 今日类型体操 - 元祖转集合

```ts
type TupleToUnion<T> = T extends Array<infer ITEM> ? ITEM : never;
```

<details>
<summary>explain it</summary>

当然可以！让我们来逐行解析这段 TypeScript 代码，看看它是如何工作的。

```typescript
type TupleToUnion<T> = T extends Array<infer ITEM> ? ITEM : never;
```

### 代码解析

1. **`type TupleToUnion<T>`**:

   - 这里我们定义了一个类型别名 `TupleToUnion`，它接受一个类型参数 `T`。这个类型参数通常是一个元组（Tuple）或数组（Array）。

2. **`T extends Array<infer ITEM>`**:

   - 这一部分是一个条件类型（conditional type）。它的意思是：如果 `T` 是一个数组类型（即 `Array`），那么我们就可以从这个数组中提取出它的元素类型。
   - `infer ITEM` 是 TypeScript 的一种推断机制，它会自动推断出数组中元素的类型，并将其命名为 `ITEM`。

3. **`? ITEM : never`**:
   - 这是条件类型的结果部分。如果 `T` 是一个数组类型，那么 `TupleToUnion<T>` 的结果就是 `ITEM`（即数组中的元素类型）。
   - 如果 `T` 不是数组类型，那么 `TupleToUnion<T>` 的结果就是 `never`，表示没有有效的类型。

### 整体功能

- **目标**: `TupleToUnion` 类型的主要目标是将一个元组或数组类型转换为其元素类型的联合类型（Union Type）。如果传入的类型是一个数组，返回数组元素的类型；如果不是数组，返回 `never`。

### 示例

让我们通过一些示例来更好地理解这个类型的作用：

```typescript
type A = TupleToUnion<[1, 2, 3]>; // A 的类型是 1 | 2 | 3
type B = TupleToUnion<["a", "b", "c"]>; // B 的类型是 'a' | 'b' | 'c'
type C = TupleToUnion<number[]>; // C 的类型是 number
type D = TupleToUnion<number>; // D 的类型是 never
```

- 在这些示例中，`A` 和 `B` 是元组类型，因此 `TupleToUnion` 返回了它们的元素类型的联合类型。
- `C` 是一个数组类型，返回了 `number`，表示数组中的元素类型。
- 而 `D` 不是数组类型，所以 `TupleToUnion` 返回了 `never`，表示没有有效的类型。

### 总结

这段代码的核心在于利用 TypeScript 的条件类型和类型推断功能，帮助我们在处理类型时更加灵活和高效。通过 `TupleToUnion` 类型，我们可以轻松地将元组或数组的元素类型转换为联合类型，简化类型定义的复杂性。

</details>

主要还是`infer`的作用

## 2024-10-15 09:44:19

### 今日类型体操 - TupleToObject

```ts
type TupleToObject<T extends readonly PropertyKey[]> = {
  [k in T[number]]: k;
};
```

<details>
<summary>逐行解析</summary>

当然可以！让我们来逐行解析这段 TypeScript 代码，看看它是如何工作的。

```typescript
type TupleToObject<T extends readonly PropertyKey[]> = { [k in T[number]]: k };
```

### 代码解析

1. **`type TupleToObject<T extends readonly PropertyKey[]>`**:

   - 这里我们定义了一个类型别名 `TupleToObject`，它接受一个类型参数 `T`。
   - `T` 被限制为一个只读的数组（`readonly`），数组的元素类型是 `PropertyKey`。`PropertyKey` 是 TypeScript 中的一个内置类型，表示可以用作对象属性键的类型，包括 `string`、`number` 和 `symbol`。

2. **`{ [k in T[number]]: k }`**:
   - 这一部分是一个映射类型（Mapped Type），它的作用是将 `T` 中的每个元素转换为对象的属性。
   - `T[number]` 是一种索引访问类型，它表示 `T` 数组中的所有元素类型。换句话说，它会提取出 `T` 数组中的所有元素。
   - `k in T[number]` 表示我们要遍历 `T` 中的每一个元素，并将其赋值给 `k`。
   - `: k` 表示每个属性的值就是它的键（`k`）。因此，最终生成的对象的每个属性名和属性值都是相同的。

### 整体效果

这个类型的主要目标是将一个元组（或只读数组）转换为一个对象，其中每个元素都成为对象的一个属性，属性名和属性值相同。例如：

```typescript
type MyTuple = ["a", "b", "c"];
type MyObject = TupleToObject<MyTuple>;
// 结果是：
// type MyObject = {
//   a: 'a';
//   b: 'b';
//   c: 'c';
// }
```

### 总结

- `TupleToObject` 是一个非常有用的工具类型，可以将元组转换为对象，方便在 TypeScript 中进行类型推导和类型安全的操作。
- 这种类型转换在处理动态属性名时特别有用，比如在构建 API 响应模型或处理配置对象时。

</details>

<details>
<summary>关于`T[number]`</summary>

好的，让我们深入探讨一下 `T[number]` 中的 `number` 是从哪里来的。

在 TypeScript 中，`T[number]` 是一种索引访问类型，它的作用是提取数组或元组 `T` 中的元素类型。这里的 `number` 是用来表示数组的索引类型。

### 详细解释

1. **`T` 是一个只读数组**:

   - 在你的代码中，`T` 被定义为 `readonly PropertyKey[]`，这意味着 `T` 是一个只读的数组，数组的元素可以是 `string`、`number` 或 `symbol`。

2. **`T[number]` 的含义**:
   - `number` 在这里并不是指某个具体的数字，而是 TypeScript 中的一个特殊类型，用于表示所有可能的数组索引。
   - 当你写 `T[number]` 时，TypeScript 会理解为“获取 `T` 数组中所有元素的类型”。换句话说，它会提取出 `T` 中的每一个元素类型。

### 举个例子

假设我们有一个元组：

```typescript
type MyTuple = ["a", "b", "c"];
```

- 当我们使用 `MyTuple[number]` 时，TypeScript 会返回 `'a' | 'b' | 'c'`，这表示 `MyTuple` 中的所有元素类型的联合。

### 总结

- `number` 在 `T[number]` 中是一个索引类型，用于提取数组或元组中的元素类型。
- 通过这种方式，我们可以动态地获取数组中的所有元素类型，从而在映射类型中使用它们。

</details>

### 今日ui

> scroll to select

import ScrollSelect from "@components/react/little/scrollSelect.tsx";

<ScrollSelect client:visible />

## 2024-10-16 10:39:07

### 今日探索

#### osm buildings

<details>
<summary>城市建筑2.5</summary>

import Osm from "@components/astro/more/osm.astro";

<Osm />

</details>

### 今日类型体操 - 可串联构造器

```ts
type Chainable<T = {}> = {
  option: <K extends string, V>(
    key: K extends keyof T ? never : K,
    value: V
  ) => Chainable<Omit<T, K> & Record<K, V>>;
  get: () => T;
};
```

<details>
<summary>explain</summary>

这段代码定义了一个 TypeScript 的类型 `Chainable`，它用于实现链式调用的接口。下面是对这段代码的逐步解释：

### 1. 类型定义

```typescript
type Chainable<T = {}> = { ... }
```

- `Chainable` 是一个泛型类型，默认参数 `T` 是一个空对象 `{}`。这个类型用于表示一个可以链式调用的方法。

### 2. `option` 方法

```typescript
option: <K extends string, V>(key: K extends keyof T ? never : K, value: V) =>
  Chainable<Omit<T, K> & Record<K, V>>;
```

- `option` 是 `Chainable` 类型的一个方法。
- `<K extends string, V>` 是一个泛型参数，`K` 是一个字符串类型，`V` 是任意类型。
- `key` 参数的类型是 `K extends keyof T ? never : K`：
  - 这意味着如果 `K` 已经是 `T` 的一个键，则 `key` 的类型为 `never`，即不允许使用已经存在的键。这确保了在链式调用中，不能重复定义相同的键。
  - 如果 `K` 不是 `T` 的键，则 `key` 的类型为 `K`。
- `value` 的类型是 `V`，表示可以传入任意类型的值。
- 返回值是 `Chainable<Omit<T, K> & Record<K, V>>`：
  - `Omit<T, K>` 会从 `T` 中移除键 `K`，确保在链式调用中不会重复定义。
  - `Record<K, V>` 创建一个新的对象类型，其中包含键 `K` 和对应的值 `V`。
  - 最终返回一个新的 `Chainable` 类型，包含了更新后的属性。

> Typescript类型语法规则：

TypeScript 有两个“顶层类型”（`any`和`unknown`），但是“底层类型”只有`never`唯一一个。
`never`类型可以赋值给其他任意类型，但是其他类型不能复制给`never`
当K在T存在，返回`never`类型，此时其他类型传入就会报错
`key: K extends keyof T ? never : K`

### 3. `get` 方法

```typescript
get: () => T;
```

- `get` 是 `Chainable` 类型的另一个方法。
- 返回值类型是 `T`，表示获取当前链式调用的结果。

### 总结

这个 `Chainable` 类型允许你通过 `option` 方法链式地添加属性，同时确保不会重复添加相同的属性。最终，通过 `get` 方法可以获取到一个包含所有添加属性的对象。

### 示例

以下是如何使用这个 `Chainable` 类型的示例：

```typescript
declare const config: Chainable;

const result = config
  .option("foo", 123)
  .option("name", "type-challenges")
  .option("bar", { value: "Hello World" })
  .get();

// result 的类型为 { foo: number, name: string, bar: { value: string } }
```

在这个示例中，`result` 将会是一个包含所有通过 `option` 方法添加的属性的对象。

</details>

## 链接
