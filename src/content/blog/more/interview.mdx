---
title: interview
pubDatetime: 2023-10-19 14:05:00
postSlug: interview
featured: false
draft: false
tags:
  - 八股
  - interview
  - 面经
  - 面试准备
description: "在前端面试过程中，对于记录面试经历是很有帮助的，这样可以更好地总结经验、查漏补缺，并在以后的面试中有所提升"
---

## 目录

## basic

### Hydration

<details>
<summary>Hydration</summary>

</details>

Hydration（即“水合”）在前端框架和库中是一个重要的概念。它主要与服务器渲染（Server-Side Rendering，SSR）和客户端渲染（Client-Side Rendering，CSR）相结合。下面我将详细解释它的意义和应用：

服务器渲染 (SSR)：
当一个页面首次加载时，如果使用服务器渲染，服务器会生成一个完整的 HTML 文档，并将其发送到客户端。这意味着浏览器可以立即看到内容，而不需要等待 JavaScript 下载和执行。

客户端渲染 (CSR)：
在客户端渲染中，页面的大部分或全部内容由 JavaScript 在浏览器中动态生成。这意味着浏览器首先需要下载和执行 JavaScript，然后才能看到完整的内容。

水合 (Hydration)：
当使用服务器渲染（SSR）并且随后启动客户端渲染（CSR）时，需要确保两者之间的内容一致性和可交互性。这就是“水合”所起的作用。水合是指客户端 JavaScript“接管”由服务器渲染生成的静态 HTML，将其转换为可交互的动态内容，同时保持用户界面的状态和事件处理程序。

在 React、Vue 和其他一些现代前端框架中，水合是自动处理的。框架会比较服务器渲染生成的 HTML 与客户端 JavaScript 生成的内容，并确保它们之间的一致性。

为什么水合很重要？

性能优化：通过使用服务器渲染和水合，您可以提供更快的首次加载时间和更好的性能体验。

SEO 友好：服务器渲染生成的静态 HTML 对搜索引擎更友好，这有助于提高页面的搜索排名。

用户体验：通过尽快显示内容并立即添加交互性，可以提供更好的用户体验。

总之，水合是前端开发中一个关键的概念，它结合了服务器渲染和客户端渲染的优点，为用户提供了更好的性能和体验。

### Closure

**闭包是对外部作用域变量的实时引用，而非复制**

<details>

<summary>2024/01/08 js闭包以及应用</summary>

闭包（Closure）是JavaScript中的一个重要概念，它与作用域、变量生命周期等紧密相关。闭包在JavaScript中有着广泛的应用，下面我将首先简要解释闭包的概念，然后列举一些常见的闭包应用场景。

#### 什么是闭包？

闭包是指有权访问另一个函数作用域中的变量的函数。简单来说，当一个函数在另一个函数内部定义时，并且这个内部函数引用了外部函数的变量，那么就产生了一个闭包。

#### 闭包的形成条件：

1. 函数嵌套：一个函数定义在另一个函数内部。
2. 内部函数引用了外部函数的变量。

#### 闭包的应用：

1. **封装私有变量和方法**：

   ```js
   function createCounter() {
     let count = 0;
     return {
       increment: function () {
         count++;
         return count;
       },
       decrement: function () {
         count--;
         return count;
       },
     };
   }
   const counter = createCounter();
   console.log(counter.increment()); // 输出 1
   console.log(counter.decrement()); // 输出 0
   ```

2. **模块模式**：通过闭包可以创建私有变量和方法，从而实现模块化的编程。

3. **事件监听器**：

   ```js
   function attachEvent() {
     let count = 0;
     document.getElementById("btn").addEventListener("click", function () {
       count++;
       console.log(`Button clicked ${count} times.`);
     });
   }
   attachEvent();
   ```

4. **循环与闭包**：在循环中使用闭包时，需要特别注意闭包与循环变量的交互。

   ```js
   for (var i = 0; i < 5; i++) {
     setTimeout(function () {
       console.log(i); // 输出 5, 5, 5, 5, 5
     }, 1000);
   }
   ```

   上述代码会输出五次5，因为循环结束后i的值为5。为了解决这个问题，可以使用IIFE（立即调用函数表达式）。

   ```js
   for (var i = 0; i < 5; i++) {
     (function (j) {
       setTimeout(function () {
         console.log(j); // 输出 0, 1, 2, 3, 4
       }, 1000);
     })(i);
   }
   ```

5. **实现函数柯里化**：通过闭包，可以实现函数柯里化，即将多参数的函数转化为一系列使用一个参数的函数。

6. **缓存**：通过闭包缓存计算结果，提高性能。
   ```js
   function memoize(fn) {
     const cache = {};
     return function (...args) {
       const key = JSON.stringify(args);
       if (cache[key] === undefined) {
         cache[key] = fn(...args);
       }
       return cache[key];
     };
   }
   ```

总结：闭包是JavaScript中的一个强大而灵活的特性，可以用于创建私有变量和方法、实现模块化、事件监听等。但同时也需要注意闭包可能带来的内存泄漏问题，因为闭包会保留外部函数的作用域链。

</details>

## 面经

<blockquote>
  此一处陌生的地方，不过是心魂之旅中的一处景观、一次际遇，未来的路途一样还是无限之问。
</blockquote>

### 牛客1-偏算法

#### 您了解的排序算法有哪些？/这些排序算法是如何实现的？

我了解的排序算法包括但不限于以下几种：

1. **冒泡排序（Bubble Sort）：** 通过不断交换相邻元素，将最大（或最小）的元素逐步“冒泡”到最后（或最前）的位置。
2. **选择排序（Selection Sort）：** 每次从未排序的元素中选取最小（或最大）的元素，放到已排序部分的末尾。
3. **插入排序（Insertion Sort）：** 将待排序的元素逐个插入到已排序部分的合适位置，从而实现排序。
4. **快速排序（Quick Sort）：** 选择一个基准元素，将小于基准的元素放到基准的左侧，大于基准的元素放到右侧，然后递归地对左右两部分进行排序。
5. **归并排序（Merge Sort）：** 将待排序的数组不断地分割成更小的数组，直到每个数组只有一个元素，然后将这些小数组合并成一个新的有序数组。
6. **堆排序（Heap Sort）：** 将待排序的数组构建成一个二叉堆，然后不断地移除堆顶元素（最大或最小），并重新调整堆，直到所有元素都被移除。

7. **计数排序（Counting Sort）：** 统计数组中每个元素的出现次数，然后根据元素的大小顺序，将其放置到正确的位置上。

8. **桶排序（Bucket Sort）：** 将待排序的元素分配到不同的桶中，对每个桶中的元素进行排序，然后按照顺序合并所有桶。

9. **基数排序（Radix Sort）：** 将待排序的数字按照位数进行分组，然后按照每一位的顺序依次进行排序，直到所有位都排序完成。

每种排序算法都有其优缺点，适用于不同的场景。例如，对于小规模的数据集，插入排序可能更快；对于大规模的数据集，快速排序或归并排序可能更合适。选择合适的排序算法取决于数据的特点、排序的稳定性要求、内存空间等因素。

#### 分析一下冒泡排序的时间复杂度?

冒泡排序的时间复杂度取决于比较和交换的次数。在冒泡排序中，每次都会比较相邻的两个元素，并根据需要交换它们的位置，直到整个数组排序完成。

假设待排序的数组长度为 `n`，冒泡排序的基本思想是通过多次遍历数组，每次都比较相邻的两个元素，将较大的元素交换到数组的末尾。在第一次遍历结束后，最大的元素会被交换到数组的最后一个位置；在第二次遍历中，第二大的元素会被交换到倒数第二个位置，依次类推。

##### 最坏情况下的时间复杂度：

在最坏的情况下，即待排序数组是逆序排列的情况下，冒泡排序需要进行 `n-1` 轮比较和交换。在每一轮比较中，需要比较 `n-i-1` 次（其中 `i` 是当前轮数），因为每次都会将当前轮最大的元素交换到数组的末尾。因此，总的比较次数为：

$$[ (n-1) + (n-2) + ... + 1 = \frac{n \cdot (n-1)}{2} ]$$

因此，冒泡排序的最坏情况下的时间复杂度为
$$O(n^2)$$

##### 最好情况下的时间复杂度：

在最好的情况下，即待排序数组已经是有序的情况下，冒泡排序只需要进行一轮遍历，每次比较都不需要交换元素。因此，最好情况下的时间复杂度为 $$O(n)$$。

##### 平均情况下的时间复杂度：

在平均情况下，冒泡排序需要进行 $$( \frac{n \cdot (n-1)}{4} )$$ 次比较和 $$( \frac{n \cdot (n-1)}{4} )$$ 次交换，因此平均时间复杂度仍为 $$( O(n^2) )$$。

##### 总结：

冒泡排序的时间复杂度在最坏和平均情况下都是 $$( O(n^2) )$$，因此它是一种效率较低的排序算法，不适用于大规模数据的排序。然而，由于其简单易懂的实现方式，冒泡排序在学习排序算法和简单数据集的排序中仍然具有一定的价值。

#### js实现冒泡排序

```js
function bubbleSort(arr) {
  const len = arr.length;
  let swapped; // 用于标记本轮是否有元素交换的标志

  // 外层循环控制轮数
  for (let i = 0; i < len - 1; i++) {
    swapped = false; // 在每轮开始前重置标志为 false

    // 内层循环控制比较和交换
    for (let j = 0; j < len - 1 - i; j++) {
      // 如果前面的元素比后面的元素大，则交换它们的位置
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 使用解构赋值交换元素
        swapped = true; // 标记本轮有元素交换
      }
    }

    // 如果本轮没有元素交换，则数组已经有序，直接退出循环
    if (!swapped) {
      break;
    }
  }

  return arr;
}

// 示例
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log("原始数组:", arr);
console.log("排序后数组:", bubbleSort(arr));
```

#### 分析一下快速排序的时间复杂度

快速排序是一种常用且高效的排序算法，其平均时间复杂度为 $(O(n \log n))$，最坏情况下的时间复杂度为 $(O(n^2))$，其中 $(n)$ 是待排序数组的长度。以下是快速排序时间复杂度的分析：

##### 平均情况下的时间复杂度：

在平均情况下，快速排序的时间复杂度为 $(O(n \log n))$。这是因为快速排序的基本操作是通过将数组分成两部分，使得左边部分的元素都小于右边部分的元素，并且基准元素（pivot）在排序后处于正确的位置。然后，递归地对左右两部分进行排序。在每一次分割过程中，需要遍历数组一次，因此快速排序的时间复杂度是 $(O(n))$；而在平均情况下，每次分割都能将数组划分为大小相近的两部分，因此需要的递归层数为 $(O(\log n))$。因此，平均情况下快速排序的时间复杂度为 $(O(n \log n))$。

##### 最坏情况下的时间复杂度：

在最坏情况下，快速排序的时间复杂度为 $(O(n^2))$。最坏情况发生在每次分割后，基准元素选取不合适，导致左右两部分的大小差别很大，从而导致递归树呈现出极端不平衡的状态。例如，当待排序数组已经有序时，如果每次选择的基准元素都是第一个或最后一个元素，那么快速排序的时间复杂度将会退化到 $(O(n^2))$。因此，为了避免最坏情况的发生，一般采用随机选择基准元素或者三数取中法等方法来提高快速排序的性能。

##### 最好情况下的时间复杂度：

在最好情况下，快速排序的时间复杂度也是 $(O(n \log n))$。最好情况发生在每次分割后，左右两部分的大小相等，递归树呈现出平衡状态。这样，在每一层递归中，都会将数组大小缩减为原来的一半，因此需要的递归层数为 $(O(\log n))$，每次分割的时间复杂度为 $(O(n))$，因此最好情况下的时间复杂度为 $(O(n \log n))$。

综上所述，快速排序的平均时间复杂度为 $(O(n \log n))$，最坏情况下的时间复杂度为 $(O(n^2))$，最好情况下的时间复杂度为 $(O(n \log n))$。由于其平均时间复杂度较低，因此快速排序是一种高效的排序算法，常被应用于实际开发中。

#### 了解heap内部是如何实现的？构造函数和push函数的时间复杂度是多少？分别详细讲解这两个函数实现了什么，如何得到该时间复杂度？

在 JavaScript 中，通常使用数组来实现堆（Heap）。堆是一种特殊的二叉树结构，其中每个节点的值都大于等于（或小于等于）其子节点的值，根据这个特性，堆可以分为最大堆和最小堆。

##### 构造函数的实现和时间复杂度：

构造函数主要用于创建一个空的堆或者根据给定的数组构建一个堆。在构造函数中，通常会执行一次堆化操作，将无序的数组转换为满足堆的特性的数组。

构造函数的实现步骤通常如下：

1. 将给定数组赋值给堆的内部数组。
2. 从数组的中间位置开始向前遍历，对每个非叶子节点执行下沉操作（sinkDown），以确保每个节点都满足堆的特性。

构造函数的时间复杂度取决于堆化操作的复杂度，通常为 $(O(n))$，其中 $(n)$ 是数组的长度。因为堆化操作中，我们需要对每个非叶子节点执行一次下沉操作，而非叶子节点的数量约为数组长度的一半。

##### push 函数的实现和时间复杂度：

push 函数用于向堆中添加一个新的元素，并保持堆的特性。通常，push 操作是将新元素添加到数组的末尾，然后执行一次上浮操作（percolateUp）。

push 函数的实现步骤如下：

1. 将新元素添加到数组的末尾。
2. 对新添加的元素执行一次上浮操作（percolateUp），将其与父节点进行比较并交换，直到满足堆的特性。

push 函数的时间复杂度取决于上浮操作的复杂度，通常为 $(O(\log n))$，其中 $(n)$ 是堆的大小。因为上浮操作中，我们需要将新添加的元素与其父节点进行比较并交换，直到满足堆的特性。最坏情况下，新添加的元素可能需要上浮到堆的根节点位置，因此上浮操作的时间复杂度与堆的高度有关，堆的高度通常为 $(\log n)$。

##### 总结：

- 构造函数的时间复杂度为 $(O(n))$，其中 $(n)$ 是数组的长度。
- push 函数的时间复杂度为 $(O(\log n))$，其中 $(n)$ 是堆的大小。

这些时间复杂度是根据堆的特性以及 push 和构造函数的实现步骤得出的。因为堆是一种树状结构，其操作的时间复杂度通常与树的高度相关，而堆的高度通常为 $(\log n)$，因此 push 函数的时间复杂度为 $(O(\log n))$。

### 牛客2-偏框架

#### React 组件的实现原理

React 组件通过 React.createElement 创建元素，通过虚拟 DOM 维护状态变化，类组件和函数组件分别通过生命周期方法和 Hooks 处理状态和副作用。组件的渲染和更新机制包括初始化渲染、状态更新、diff 算法和 DOM 更新。

#### 不同文件在浏览器中的存放形式

<details>
<summary>请看vcr</summary>

在浏览器中，网页的不同文件类型通过不同的机制加载和存储。以下是一些常见文件类型及其在浏览器中的存放和处理方式：

##### HTML 文件

**存放形式**：

- **文档对象模型 (DOM)**：浏览器将 HTML 文件解析成 DOM 树，这是 HTML 文档的内存表示。每个 HTML 元素和属性在 DOM 中都作为节点存在。

**处理**：

- 浏览器从服务器加载 HTML 文件，将其解析为 DOM 树，然后通过 DOM API 可以动态操作这棵树。

##### CSS 文件

**存放形式**：

- **层叠样式表对象模型 (CSSOM)**：浏览器将 CSS 文件解析成 CSSOM 树，这与 DOM 树类似，是 CSS 样式的内存表示。

**处理**：

- 浏览器将 CSS 文件与 HTML 文件结合，通过 CSSOM 和 DOM 树共同决定页面的呈现样式。

##### JavaScript 文件

**存放形式**：

- **脚本引擎内存**：JavaScript 文件被浏览器加载并由 JavaScript 引擎（如 V8、SpiderMonkey 等）解析和执行。脚本内容会被保存在内存中。

**处理**：

- JavaScript 文件可以通过 `<script>` 标签内联在 HTML 文件中，或者作为外部文件通过 `<script src="...">` 引入。
- 浏览器会解析并执行这些脚本，脚本可以操作 DOM、CSSOM，以及执行其他任务。

##### 图像文件（如 JPEG、PNG、GIF 等）

**存放形式**：

- **内存中的位图**：浏览器将图像文件解码成内存中的位图，具体实现方式依赖于浏览器和操作系统。

**处理**：

- 图像文件通过 `<img>` 标签加载，或作为背景图像在 CSS 中定义。浏览器会从网络加载这些文件，并在解码后渲染到页面上。

##### 视频和音频文件（如 MP4、WebM、MP3 等）

**存放形式**：

- **媒体缓冲区**：浏览器将视频和音频文件加载到媒体缓冲区中，以便进行流式传输和播放。

**处理**：

- 这些文件通过 `<video>` 和 `<audio>` 标签加载，并由浏览器的内置媒体播放器解码和播放。

##### 字体文件（如 TTF、WOFF、WOFF2 等）

**存放形式**：

- **内存中的字体对象**：浏览器将字体文件加载并解析成内存中的字体对象。

**处理**：

- 字体文件通过 CSS 中的 `@font-face` 规则加载。加载后的字体会用于页面中的文本渲染。

##### JSON、XML 等数据文件

**存放形式**：

- **内存中的数据对象**：JSON 和 XML 文件在加载后会被解析成 JavaScript 对象或 DOM 对象，保存在内存中。

**处理**：

- 这些文件通常通过 JavaScript 的 `fetch` 或 `XMLHttpRequest` 加载，并用于 AJAX 请求的数据交换。

##### 例子：HTML 页面加载过程

当浏览器加载一个包含 HTML、CSS 和 JavaScript 的网页时，典型的过程如下：

1. **HTML 加载和解析**：

   - 浏览器请求 HTML 文件并开始解析，构建 DOM 树。
   - 在解析过程中，如果遇到 CSS 文件引用，浏览器会并行请求这些 CSS 文件。

2. **CSS 加载和解析**：

   - CSS 文件被加载和解析，构建 CSSOM 树。
   - 浏览器将 CSSOM 树与 DOM 树结合，生成渲染树。

3. **JavaScript 加载和执行**：

   - 如果 HTML 中有 `<script>` 标签，浏览器会按顺序加载和执行 JavaScript 文件。
   - JavaScript 可以操作已构建的 DOM 树和 CSSOM 树。

4. **资源加载**：

   - 图像、字体、视频等资源文件被并行加载。
   - 浏览器在资源加载完成后，将其解码并渲染到页面上。

5. **页面渲染**：
   - 浏览器根据渲染树计算每个节点的布局和样式。
   - 最终，浏览器将内容绘制到屏幕上。

##### 浏览器缓存

- **缓存机制**：浏览器会缓存已加载的文件（HTML、CSS、JavaScript、图像等），以减少重复请求，提升性能。
- **缓存位置**：文件缓存通常存储在浏览器的本地缓存中，可以通过 HTTP 头（如 `Cache-Control` 和 `ETag`）管理缓存策略。

通过理解不同文件在浏览器中的存放形式和处理方式，可以更好地优化网页性能和用户体验。

</details>

#### vuex在哪个阶段挂在在vue实例上

<blockquote>
Vuex 是一个独立的状态管理库，它并不是在 Vue 实例上挂载的，而是通过 Vue.use() 方法在 Vue 应用中进行安装。通常，Vuex 是在 Vue 根实例创建之前被安装的。

```js
import Vue from "vue";
import Vuex from "vuex";
import App from "./App.vue";

// 1. 使用 Vuex 插件
Vue.use(Vuex);

// 2. 创建 Vuex store 实例
const store = new Vuex.Store({
  state: {
    count: 0,
  },
  mutations: {
    increment(state) {
      state.count++;
    },
  },
});

// 3. 创建根 Vue 实例
new Vue({
  el: "#app",
  store, // 将 Vuex store 实例挂载到根实例上
  render: h => h(App),
});
```

</blockquote>

#### 在实际开发中shouldComponentUpdate有什么作用

- 避免在shouldComponentUpdate中进行过多或复杂的计算，以免影响性能。
- 如果shouldComponentUpdate返回false，那么render、componentDidUpdate等生命周期方法将不会被执行。
- 使用PureComponent或React.memo可以在某种程度上自动实现shouldComponentUpdate的功能，它们会对组件的属性进行浅比较，来决定是否重新渲染组件。

### 某瓣-面试（未回答上/回答不好）

#### Ts `typeof` `keyof`

- `typeof` 操作符有两个主要用途：

  1.在运行时获取变量的类型

  2.在编译时获取变量或对象的类型

```ts
interface Person {
  name: string;
  age: number;
}

const person: Person = { name: "John", age: 25 };

// 使用ts 的 typeof 获取 person 的类型
type PersonType = typeof person;

const anotherPerson: PersonType = { name: "Jane", age: 30 };
```

- `keyof`

`keyof` 操作符用于获取某种类型的所有键，并将其联合成一个联合类型。

```ts
keyof 操作符用于获取某种类型的所有键，并将其联合成一个联合类型。
```

#### ts Omit

用于创建一个新的类型，该类型从另一个类型中排除指定的键

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

示例:假设我们有一个用户类型 User，包含 id, name, 和 email 三个属性。我们希望创建一个新的类型，排除 email 属性。

```ts
type User = {
  id: number;
  name: string;
  email: string;
};

type UserWithoutEmail = Omit<User, "email">;

const user: UserWithoutEmail = {
  id: 1,
  name: "John Doe",
  // email 属性不需要包含在 UserWithoutEmail 类型中
};
```

在 React 项目中，Omit 常用于处理组件的 Props，特别是当我们需要复用一些通用 Props 并排除某些特定属性时。

```tsx
type BaseButtonProps = {
  onClick: () => void;
  label: string;
  disabled?: boolean;
};

type IconButtonProps = Omit<BaseButtonProps, "label"> & {
  icon: string;
};

const IconButton: React.FC<IconButtonProps> = ({ onClick, icon, disabled }) => (
  <button onClick={onClick} disabled={disabled}>
    <i className={`icon-${icon}`} />
  </button>
);
```

结合其他高级类型如 Partial 使用，Omit 能够大大增强 TypeScript 类型系统的表达能力，帮助开发者编写更健壮和可维护的代码

```ts
type User = {
  id: number;
  name: string;
  email: string;
  age: number;
};

type PartialUserWithoutAge = Partial<Omit<User, "age">>;

const partialUser: PartialUserWithoutAge = {
  name: "ajn404",
  email: "ajn404@example.com",
  // id 属性是可选的，并且 age 属性被排除在 PartialUserWithoutAge 类型之外
};
```

#### react redux具体流程

创建 Store：使用 createStore 函数创建 Redux store。<br/>
定义 Action：创建表示用户行为或事件的 action 对象。<br/>
编写 Reducer：根据 action 来修改 store 中的 state。<br/>
连接 React 组件：使用 Provider 和 connect，将 Redux store 与 React 组件连接起来。<br/>

#### 通用的弹窗（Modal）组件

<details>
<summary>设计一个通用的弹窗（Modal）组件</summary>

设计一个通用的弹窗（Modal）组件 API 可以让你的 React 应用更加模块化和可维护。以下是一个如何在 React 中实现通用弹窗组件的步骤和示例。

##### 1. 创建 Modal 组件

首先，我们需要创建一个基础的 Modal 组件，它可以接受不同的内容和配置。

```js
// Modal.js
import React from "react";
import "./Modal.css"; // 你可以创建一个 CSS 文件来定义 Modal 的样式

const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="modal-close-button" onClick={onClose}>
          X
        </button>
        {children}
      </div>
    </div>
  );
};

export default Modal;
```

##### 2. 创建 ModalProvider 和 useModal Hook

为了让弹窗在整个应用中可用，我们可以创建一个上下文（Context）来管理弹窗的状态和提供相关的 API。

```js
// ModalContext.js
import React, { createContext, useContext, useState, useCallback } from "react";
import Modal from "./Modal";

const ModalContext = createContext();

export const ModalProvider = ({ children }) => {
  const [modalContent, setModalContent] = useState(null);
  const [isOpen, setIsOpen] = useState(false);

  const openModal = useCallback(content => {
    setModalContent(content);
    setIsOpen(true);
  }, []);

  const closeModal = useCallback(() => {
    setModalContent(null);
    setIsOpen(false);
  }, []);

  return (
    <ModalContext.Provider value={{ openModal, closeModal }}>
      {children}
      <Modal isOpen={isOpen} onClose={closeModal}>
        {modalContent}
      </Modal>
    </ModalContext.Provider>
  );
};

export const useModal = () => {
  return useContext(ModalContext);
};
```

##### 3. 使用 ModalProvider 包裹应用

在应用的根组件中，使用 `ModalProvider` 包裹整个应用。

```js
// App.js
import React from "react";
import { ModalProvider } from "./ModalContext";
import HomePage from "./HomePage";

const App = () => {
  return (
    <ModalProvider>
      <HomePage />
    </ModalProvider>
  );
};

export default App;
```

##### 4. 使用 useModal Hook 打开和关闭弹窗

在你希望打开弹窗的任何组件中，可以使用 `useModal` Hook 来访问 `openModal` 和 `closeModal` 方法。

```js
// HomePage.js
import React from "react";
import { useModal } from "./ModalContext";

const HomePage = () => {
  const { openModal } = useModal();

  const handleOpenModal = () => {
    openModal(<div>This is the content of the modal!</div>);
  };

  return (
    <div>
      <h1>Home Page</h1>
      <button onClick={handleOpenModal}>Open Modal</button>
    </div>
  );
};

export default HomePage;
```

##### 5. 样式

为了使弹窗看起来更好，可以添加一些基本的 CSS 样式。

```css
/* Modal.css */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  position: relative;
}

.modal-close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
}
```

通过这种方式，我们创建了一个通用的弹窗 API，可以在应用的任何地方轻松打开和关闭弹窗，并且弹窗的内容可以动态变化。我们利用了 React 的 Context API 和 Hooks 来管理弹窗的状态，并确保弹窗组件是可复用的和灵活的。

这使得我们的代码更加模块化，弹窗逻辑集中管理，同时还确保了使用的方便性。如果有更多需求，例如支持多种类型的弹窗（确认弹窗、表单弹窗等），可以在 `ModalContext` 中扩展相应的逻辑和 API。

</details>

<details>
<summary>如何设计弹窗的动画，比如打开时淡入，关闭时淡出</summary>

```jsx
// Modal.js
import React from "react";
import "./Modal.css";

const Modal = ({ isOpen, onClose, children }) => {
  return (
    <div className={`modal-overlay ${isOpen ? "fade-in" : "fade-out"}`}>
      <div className={`modal-content ${isOpen ? "slide-in" : "slide-out"}`}>
        <button className="modal-close-button" onClick={onClose}>
          X
        </button>
        {children}
      </div>
    </div>
  );
};

export default Modal;
```

当然这里也可以添加一个prop来控制动画的持续时间/控制是否显示动画

```css
/* Modal.css */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  transition: opacity 0.5s;
}

.modal-overlay.fade-in {
  opacity: 1;
}

.modal-overlay.fade-out {
  opacity: 0;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  position: relative;
  transform: translateY(-50px);
  transition: transform 0.5s;
}

.modal-content.slide-in {
  transform: translateY(0);
}

.modal-content.slide-out {
  transform: translateY(-50px);
}

.modal-close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
}
```

为了确保动画完成后才移除弹窗，在 ModalProvider 中稍微修改关闭逻辑

```js
// ModalContext.js
import React, { createContext, useContext, useState, useCallback } from "react";
import Modal from "./Modal";

const ModalContext = createContext();

export const ModalProvider = ({ children }) => {
  const [modalContent, setModalContent] = useState(null);
  const [isOpen, setIsOpen] = useState(false);

  const openModal = useCallback(content => {
    setModalContent(content);
    setIsOpen(true);
  }, []);

  const closeModal = useCallback(() => {
    setIsOpen(false);
    // 延迟清理内容，等待动画完成
    setTimeout(() => setModalContent(null), 500);
  }, []);

  return (
    <ModalContext.Provider value={{ openModal, closeModal }}>
      {children}
      <Modal isOpen={isOpen} onClose={closeModal}>
        {modalContent}
      </Modal>
    </ModalContext.Provider>
  );
};

export const useModal = () => {
  return useContext(ModalContext);
};
```

</details>

#### 两数之和

哈希表

```js
function twoSum(nums, target) {
  const numIndices = {}; // 用对象代替哈希表

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];

    if (numIndices.hasOwnProperty(complement)) {
      return [numIndices[complement], i];
    }

    numIndices[nums[i]] = i;
  }

  return null;
}

// 示例
const nums = [2, 7, 11, 15];
const target = 9;
const result = twoSum(nums, target);
console.log(result); // 输出: [0, 1]
```

#### 数组拆分多个和近似的数组

贪心

```js
function splitArrayIntoApproxEqualSums(nums, k) {
  // 步骤1：对数组进行降序排序
  nums.sort((a, b) => b - a);

  // 步骤2：初始化子数组
  const result = Array.from({ length: k }, () => []);

  // 步骤3：逐个元素分配到和最小的子数组中
  const sums = Array(k).fill(0);

  for (let num of nums) {
    // 找到和最小的子数组
    let minIndex = 0;
    for (let i = 1; i < k; i++) {
      if (sums[i] < sums[minIndex]) {
        minIndex = i;
      }
    }
    // 分配当前元素到该子数组
    result[minIndex].push(num);
    sums[minIndex] += num;
  }

  return result;
}

// 示例
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const k = 3;
const result = splitArrayIntoApproxEqualSums(nums, k);
console.log(result);
```

#### ts中范型的作用

范型类允许类的属性和方法使用范型，从而可以适用于多种类型。<br/>
范型接口使得接口中的属性和方法可以使用范型，从而可以适用于多种类型。<br/>
有时你需要对范型进行约束，使其只能是某些类型的子类型。可以使用 extends 关键字来实现范型约束。<br/>
**通过范型，函数、类和接口可以适用于多种类型，而不丧失类型检查的优势。**

#### 博客项目如何实现模糊

css `blur(2px)`

#### 文字渐变

color结合animation-delay

```scss
@keyframes anim-text-flow-keys {
  @for $i from 0 through $animationSteps {
    #{percentage($i * calc(1 / $animationSteps))} {
      color: hsla(random(365), 60%, 60%, 1);
    }
  }
}

...

$totalDelayTime: $animationElementsCount * $delayBetweenLetters;

    @for $i from 1 through $animationElementsCount {
      #{$animationElement}:nth-of-type(#{$i}) {
        animation-delay: #{($i * $delayBetweenLetters) - $totalDelayTime}s;
      }
    }
```

#### react ts 设计Table组件，设计option组件,table组件中的数据可以选择，通过option组件

参考`@tanstack/react-table`的table组件设计

import Table from "@components/react/practice/table";

<Table client:load />

<details>
<summary>小小table,拿下拿下</summary>

```tsx
import { useState } from "react";

// 定义类型

export interface Column {
  header: string;
  accessor: string;
}

export interface Row {
  [key: string]: any;
}

export interface TableOptions {
  className?: string;
}

export interface OptionConfig {
  label: string;
  name: string;
  type: "text" | "number" | "select";
  value: string | number;
  options?: Array<{ label: string; value: string | number }>; // Only for select type
}

export interface TableState {
  selectedRows: Set<number>;
  allSelected: boolean;
}

interface UseTableOptions {
  columns: Column[];
  data: Row[];
}

//使用 useTable hook 来管理表格的状态和渲染逻辑。
//在 useTable Hook 中增加管理选中状态的逻辑
//通过 state 管理选中的行和全选状态。

export const useTable = ({ columns, data }: UseTableOptions) => {
  const [rows, setRows] = useState<Row[]>(data);
  const [state, setState] = useState<TableState>({
    selectedRows: new Set<number>(),
    allSelected: false,
  });

  const toggleRowSelection = (index: number) => {
    setState(prevState => {
      const selectedRows = new Set(prevState.selectedRows);
      if (selectedRows.has(index)) {
        selectedRows.delete(index);
      } else {
        selectedRows.add(index);
      }
      return {
        ...prevState,
        selectedRows,
        allSelected: selectedRows.size === rows.length,
      };
    });
  };

  const toggleAllSelection = () => {
    setState(prevState => {
      const allSelected = !prevState.allSelected;
      const selectedRows = allSelected
        ? new Set(rows.map((_, index) => index))
        : new Set<number>();
      return { ...prevState, selectedRows, allSelected };
    });
  };

  const getTableProps = () => ({
    // Add additional table props here
  });

  const getHeaderProps = () => ({
    // Add additional header props here
  });

  const getRowProps = (row: Row, index: number) => ({
    // Add additional row props here
    key: index,
  });

  const getCellProps = (cell: any) => ({
    // Add additional cell props here
  });

  return {
    rows,
    columns,
    state,
    toggleRowSelection,
    toggleAllSelection,
    getTableProps,
    getHeaderProps,
    getRowProps,
    getCellProps,
  };
};

// 在表头和每一行中添加复选框。
// 使用 toggleAllSelection 方法处理全选逻辑。
// 使用 toggleRowSelection 方法处理行选中逻辑。

interface TableProps {
  columns: Column[];
  data: Row[];
  options: TableOptions;
}

const Table: React.FC<TableProps> = ({ columns, data, options }) => {
  const {
    rows,
    state,
    toggleRowSelection,
    toggleAllSelection,
    getTableProps,
    getHeaderProps,
    getRowProps,
    getCellProps,
  } = useTable({ columns, data });

  return (
    <table className={options?.className || ""} {...getTableProps()}>
      <thead>
        <tr {...getHeaderProps()}>
          <th>
            <input
              type="checkbox"
              checked={state.allSelected}
              onChange={toggleAllSelection}
            />
          </th>
          {columns.map((col, index) => (
            <th key={index}>{col.header}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {rows.map((row, rowIndex) => (
          <tr key={rowIndex} {...getRowProps(row, rowIndex)}>
            <td>
              <input
                type="checkbox"
                checked={state.selectedRows.has(rowIndex)}
                onChange={() => toggleRowSelection(rowIndex)}
              />
            </td>
            {columns.map((col, colIndex) => (
              <td key={colIndex} {...getCellProps(row[col.accessor])}>
                {row[col.accessor]}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};

// 管理表格数据和选项的状态。
// 将初始数据和列配置传递给 Table 组件。
// 通过 Option 组件来实现数据的选择和过滤，并将结果传递给 Table 组件进行渲染。

const App: React.FC = () => {
  const initialData: Row[] = [
    { name: "John Doe", age: 28, country: "USA" },
    { name: "Jane Smith", age: 34, country: "UK" },
    { name: "Sam Green", age: 23, country: "Canada" },
  ];

  const columns: Column[] = [
    { header: "Name", accessor: "name" },
    { header: "Age", accessor: "age" },
    { header: "Country", accessor: "country" },
  ];

  const [data, setData] = useState<Row[]>(initialData);
  const [tableOptions, setTableOptions] = useState({ className: "my-table" });
  const [filterOptions, setFilterOptions] = useState<OptionConfig[]>([
    {
      label: "Filter by Country",
      name: "country",
      type: "select",
      value: "",
      options: [
        { label: "All", value: "" },
        { label: "USA", value: "USA" },
        { label: "UK", value: "UK" },
        { label: "Canada", value: "Canada" },
      ],
    },
  ]);

  const handleOptionChange = (name: string, value: string | number) => {
    setFilterOptions(prevOptions =>
      prevOptions.map(option =>
        option.name === name ? { ...option, value } : option
      )
    );

    if (name === "country") {
      setData(
        value ? initialData.filter(row => row.country === value) : initialData
      );
    }
  };

  return (
    <div>
      <Table columns={columns} data={data} options={tableOptions} />
    </div>
  );
};

export default App;
```

</details>

#### Webpack项目实现按需引入

关键在于 Babel 的 import 插件配置，它使得 Webpack 只打包实际使用的组件及其依赖，而不是整个库：

```json
{
  "plugins": [
    [
      "import",
      {
        "libraryName": "antd",
        "libraryDirectory": "es",
        "style": "css"
      }
    ]
  ]
}
```

#### React高阶组件及应用场景

<details >
<summary>简介</summary>

React高阶组件（Higher Order Components，HOC）是一种设计模式，用于在React应用中复用组件逻辑。它们本质上是函数，接受一个组件作为参数，并返回一个新的组件。

##### 应用场景：

1. **逻辑复用**：当多个组件需要共享相同的逻辑时，可以将该逻辑封装在高阶组件中，并在需要时应用于其他组件。

2. **渲染劫持**：高阶组件可以拦截并修改组件的props，state或渲染结果，以达到特定的目的。比如，认证组件可以拦截未登录用户的请求并重定向到登录页面。

3. **渲染助手**：高阶组件可以提供一些辅助函数或渲染逻辑，使得组件更容易使用或更加灵活。

##### 示例：

```js
// 高阶组件示例：为组件添加日志记录功能
function withLogger(WrappedComponent) {
  return class extends React.Component {
    componentDidMount() {
      console.log(`Component ${WrappedComponent.name} mounted`);
    }
    render() {
      return <WrappedComponent {...this.props} />;
    }
  };
}

// 使用高阶组件包装组件
const LoggedComponent = withLogger(MyComponent);

// 使用LoggedComponent渲染
ReactDOM.render(<LoggedComponent />, document.getElementById("root"));
```

在这个例子中，`withLogger`是一个高阶组件，它接受一个组件作为参数，并返回一个新的组件，该新组件在挂载时会输出日志信息。通过将`MyComponent`传递给`withLogger`，我们创建了一个具有日志功能的新组件`LoggedComponent`。

##### 注意事项：

- **命名约定**：高阶组件的命名约定是以"With"开头，以便清晰地表明它是一个高阶组件。

- **不要窃取props**：在高阶组件内部，应该避免直接修改传入的props，而是应该使用props传递给包装组件。

- **组件树修改**：高阶组件可能会更改组件树的结构，因此要谨慎使用，并确保不会破坏组件的预期行为。

高阶组件是React中非常强大和灵活的工具，但也需要谨慎使用，以避免复杂化组件树和降低可维护性。

</details>

<details open>
<summary>具体应用场景</summary>

当涉及到特定的应用场景时，高阶组件可以提供一些具体的解决方案：

1. **认证和授权**：在需要认证用户才能访问的页面中，可以使用高阶组件来包装需要授权的组件。这个高阶组件可以检查用户的登录状态，并根据需要进行重定向或显示相应的UI。

```js
function withAuth(WrappedComponent) {
  return class extends React.Component {
    render() {
      if (isUserAuthenticated()) {
        return <WrappedComponent {...this.props} />;
      } else {
        return <Redirect to="/login" />;
      }
    }
  };
}
```

2. **数据获取和状态管理**：在需要获取和管理数据的组件中，可以使用高阶组件来处理数据的获取和状态管理逻辑。这可以使组件更加专注于UI渲染，而将数据逻辑与UI分离。

```js
function withDataFetching(WrappedComponent, dataURL) {
  return class extends React.Component {
    state = {
      data: null,
      isLoading: true,
      error: null,
    };

    componentDidMount() {
      fetchData(dataURL)
        .then(data => this.setState({ data, isLoading: false }))
        .catch(error => this.setState({ error, isLoading: false }));
    }

    render() {
      const { data, isLoading, error } = this.state;
      return (
        <WrappedComponent
          data={data}
          isLoading={isLoading}
          error={error}
          {...this.props}
        />
      );
    }
  };
}
```

3. **性能优化**：在需要进行性能优化的组件中，可以使用高阶组件来封装一些性能相关的逻辑，比如数据的缓存或者懒加载等。

```js
function withCache(WrappedComponent) {
  const cache = new Map();
  return class extends React.Component {
    render() {
      const cacheKey = JSON.stringify(this.props);
      if (cache.has(cacheKey)) {
        return cache.get(cacheKey);
      } else {
        const result = <WrappedComponent {...this.props} />;
        cache.set(cacheKey, result);
        return result;
      }
    }
  };
}
```

这些是一些常见的高阶组件应用场景，但实际上，高阶组件的应用范围非常广泛，可以根据具体的需求进行灵活使用和定制。

</details>

### 36\*面试准备

#### js合并两个数组

```js
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const mergedArray = array1.concat(array2);
console.log(mergedArray); // 输出: [1, 2, 3, 4, 5, 6]
```

```js
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const mergedArray = [...array1, ...array2];
console.log(mergedArray); // 输出: [1, 2, 3, 4, 5, 6]
```

#### 内存泄漏

<details>
<summary>Click to expand</summary>

前端内存泄漏是指在应用程序运行过程中，一些不再需要使用的内存没有被正确释放，从而导致内存占用不断增加，最终可能导致应用程序性能下降甚至崩溃。以下是一些常见的前端内存泄漏问题及其解决方法：

#### 常见的前端内存泄漏问题

1. **未清理的事件监听器**

   - 当给DOM元素添加事件监听器，但没有在元素被移除时移除这些监听器，可能导致内存泄漏。

2. **未清理的定时器**

   - 使用`setInterval`或`setTimeout`创建定时器，但没有在不需要时清除它们，也会导致内存泄漏。

3. **闭包**

   - 闭包可以导致某些变量被引用而无法被垃圾回收器回收，从而导致内存泄漏。

4. **DOM引用**

   - 保留对已经从DOM中移除的元素的引用，导致这些元素不能被垃圾回收。

5. **全局变量**
   - 全局变量或挂在全局对象（如`window`）上的属性不会自动释放，可能会导致内存泄漏。

##### 解决方法

1. **清理事件监听器**
   - 在元素被移除前移除相关的事件监听器，或者使用像`addEventListener`和`removeEventListener`来动态管理监听器。

```js
function handleClick() {
  // 事件处理逻辑
}
element.addEventListener("click", handleClick);
// 当不再需要时移除监听器
element.removeEventListener("click", handleClick);
```

2. **清理定时器**
   - 在组件卸载或不再需要时，使用`clearInterval`或`clearTimeout`清除定时器。

```js
const timerId = setInterval(() => {
  // 定时器逻辑
}, 1000);
// 当不再需要时清除定时器
clearInterval(timerId);
```

3. **正确使用闭包**
   - 尽量避免不必要的闭包，或在闭包内部确保没有多余的引用保留。

```js
function createClosure() {
  let largeData = new Array(1000000).fill("*");
  return function () {
    console.log(largeData.length);
  };
}
let closure = createClosure();
// 当不再需要时可以显式地清理大对象
closure = null;
```

4. **移除不必要的DOM引用**
   - 当从DOM中移除元素时，确保也删除相关的JavaScript引用。

```js
let element = document.getElementById("myElement");
document.body.removeChild(element);
// 删除JavaScript引用
element = null;
```

5. **避免使用全局变量**
   - 尽量避免使用全局变量，可以使用模块化的方法来组织代码，或者使用闭包来限制变量的作用域。

```js
(function () {
  let localVar = "I am a local variable";
  // 代码逻辑
})();
```

##### 检测工具

1. **浏览器开发者工具**

   - Chrome和Firefox的开发者工具中都包含用于内存分析的工具，如Heap snapshots、Allocation profiler等。

2. **第三方库**
   - 使用像`leakage`、`memlab`等库来检测内存泄漏。

##### 示例

以下是一个简单的示例，展示如何可能产生内存泄漏以及如何解决它。

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Memory Leak Example</title>
  </head>
  <body>
    <button id="leakButton">Click me</button>
    <script>
      function createLeak() {
        const element = document.getElementById("leakButton");
        element.addEventListener("click", function onClick() {
          console.log("Button clicked");
        });
        // 内存泄漏：即使元素被移除，事件监听器仍然存在
      }

      createLeak();

      // 解决方法：在元素被移除前移除事件监听器
      function removeLeak() {
        const element = document.getElementById("leakButton");
        element.removeEventListener("click", onClick);
      }

      // 模拟移除元素
      document.getElementById("leakButton").remove();
      removeLeak();
    </script>
  </body>
</html>
```

通过上述步骤和方法，可以有效地避免和解决前端内存泄漏问题，从而提高应用程序的性能和稳定性。

</details>

#### 二分查找的时间复杂度分析

<blockquote>
  初始查找范围为n。
  <br />
  每次查找后，范围减半，即变为n/2, n/4, n/8, ...。
  <br />
  经过k次查找后，查找范围缩小到1，即n / 2^k = 1。
  <br />
  通过方程求解得出k = log_2(n)，因此时间复杂度为O(log n)
  <br />
</blockquote>

#### http建立连接过程，为什么不是四次或两次握手

<details open>
<summary>Click to expand</summary>

HTTP协议本身是基于TCP协议的。TCP协议使用三次握手（Three-Way Handshake）来建立连接，这一过程确保了客户端和服务器之间的连接是可靠的，并且双方都准备好进行数据传输。以下是TCP三次握手建立连接的详细过程，以及为什么不是四次或两次握手。

##### TCP三次握手过程

1. **第一次握手：客户端发送SYN**

   - 客户端向服务器发送一个SYN（Synchronize）报文段，其中包含一个初始序列号（Sequence Number），表示客户端请求建立连接。
   - 客户端进入SYN_SENT状态。

2. **第二次握手：服务器发送SYN-ACK**

   - 服务器收到SYN报文段后，向客户端发送一个SYN-ACK（Synchronize-Acknowledge）报文段，其中包含服务器的初始序列号，以及对客户端SYN报文段的确认（ACK = 客户端的序列号 + 1）。
   - 服务器进入SYN_RCVD状态。

3. **第三次握手：客户端发送ACK**
   - 客户端收到SYN-ACK报文段后，向服务器发送一个ACK（Acknowledgement）报文段，确认接收到服务器的SYN报文段（ACK = 服务器的序列号 + 1）。
   - 客户端和服务器都进入ESTABLISHED状态，连接建立完成。

##### 为什么不是四次握手？

四次握手会显得多余，因为在三次握手中已经可以确认双方的通信能力：

- 第一次握手：客户端发起连接请求，服务器知道了客户端想要建立连接。
- 第二次握手：服务器同意连接请求并确认了客户端的序列号，同时提供了自己的序列号。
- 第三次握手：客户端确认了服务器的序列号，并且通知服务器，客户端的连接请求被确认。

在这三次交互中，客户端和服务器已经成功同步了初始序列号，并确认了彼此的通信能力，多一次握手并不能提供额外的可靠性保证。

##### 为什么不是两次握手？

两次握手不能确保连接的可靠性，无法防止历史连接请求的干扰。假设使用两次握手：

1. **第一次握手：客户端发送SYN**

   - 客户端向服务器发送SYN报文段。

2. **第二次握手：服务器发送SYN-ACK**
   - 服务器收到SYN报文段后，发送SYN-ACK报文段。

在这种情况下，客户端无法确认服务器是否收到了SYN报文段并且愿意建立连接。假设由于网络问题，服务器的SYN-ACK报文段丢失，那么客户端会一直等待，导致资源浪费。同时，如果有旧的SYN报文段被服务器误认为是新的连接请求，也可能导致意外的连接建立。

##### 三次握手的优势

三次握手通过以下方式确保了连接的可靠性和有效性：

1. **确认双方通信能力**：确保双方都能发送和接收数据。
2. **防止旧的重复连接请求**：通过序列号，能够区分不同的连接请求，防止由于网络延迟导致的历史报文干扰。
3. **同步初始序列号**：确保双方都能够正确地接收和处理数据包。

因此，TCP选择三次握手作为建立连接的过程，以确保连接的可靠性和有效性。

</details>

#### 对rust的了解程度

<blockquote>
  我对Rust有一定的了解和使用经验。Rust是一种系统编程语言，注重安全性和性能。它的主要特点包括内存安全性、所有权模型和无数据竞争的并发编程。我曾在项目中使用Rust开发过高性能的服务器应用，利用其所有权系统来管理内存，避免常见的内存泄漏和并发问题。此外，我还熟悉Rust的包管理工具Cargo和其生态系统中的一些常用库，如Serde用于序列化和反序列化，以及Tokio用于异步编程
</blockquote>

<details>
<summary>rust基础</summary>

当然，介绍Rust的基础知识可以帮助你在面试中展示对这门语言的了解。以下是一些关键的基础概念和示例代码，能够帮助你更好地理解Rust，并准备面试中的相关问题。

##### Rust基础概念

###### 1. 所有权与借用

- **所有权（Ownership）**: Rust的核心特性之一，每个值在任意时刻都有一个所有者。
- **借用（Borrowing）**: 可以通过引用借用值，但不能改变所有权。

示例代码：

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = &s1; // 借用 s1
    println!("{}", s2);
    // s1 仍然可以使用
    println!("{}", s1);
}
```

###### 2. 生命周期（Lifetimes）

- 生命周期确保引用的有效性，防止悬空引用。

示例代码：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

###### 3. 模式匹配（Pattern Matching）

- 使用`match`表达式处理不同的模式。

示例代码：

```rust
fn main() {
    let number = 7;
    match number {
        1 => println!("One!"),
        2 => println!("Two!"),
        3 => println!("Three!"),
        _ => println!("Not one, two, or three!"),
    }
}
```

###### 4. 结果类型与错误处理（Result and Error Handling）

- 使用`Result`类型处理可能的错误。

示例代码：

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");
    let f = match f {
        Ok(file) => file,
        Err(ref error) if error.kind() == ErrorKind::NotFound => {
            match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Tried to create file but there was a problem: {:?}", e),
            }
        },
        Err(error) => {
            panic!("There was a problem opening the file: {:?}", error)
        },
    };
}
```

###### 5. 结构体（Structs）与枚举（Enums）

- 使用结构体定义自定义类型，使用枚举定义可能的值集合。

结构体示例：

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    println!("User: {}", user1.username);
}
```

枚举示例：

```rust
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    println!("{:?}, {:?}", four, six);
}
```

###### 6. 泛型（Generics）

- 使用泛型来编写能够处理不同数据类型的代码。

示例代码：

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

###### 总结

Rust语言通过其独特的所有权系统、严格的类型检查和模式匹配等特性，提供了高效、安全和可靠的编程体验。即使你刚开始学习Rust，这些基础概念和示例代码可以帮助你在面试中展示对Rust的理解和兴趣。如果你有更多时间，可以进一步了解Rust的异步编程、错误处理和并发模型等高级特性。

</details>

#### node bff

<details>
<summary>Click to expand</summary>

BFF（Backend for Frontend）是一种后端架构模式，旨在为每个前端应用程序（如移动端、Web端等）提供专门的后端服务。Node.js在实现BFF模式方面有许多优点，以下是其中的一些主要优点：

##### 1. 单线程非阻塞I/O

Node.js基于单线程非阻塞I/O模型，能够高效处理大量并发请求。BFF通常需要处理来自多个前端的高并发请求，Node.js的这一特性使其非常适合用于构建BFF。

##### 2. JavaScript全栈开发

Node.js使用JavaScript，这意味着开发者可以使用同一种语言进行前端和后端的开发。这种一致性带来了以下好处：

- **代码重用**：可以在前端和后端共享一些代码库和工具。
- **开发效率**：开发团队只需掌握一种编程语言即可，减少了学习和维护成本。

##### 3. 丰富的生态系统

Node.js拥有庞大的包管理器npm，提供了丰富的库和工具，可以快速实现各种功能，例如：

- **请求处理**：如Express.js、Koa等轻量级框架，使开发BFF变得简单。
- **数据处理**：如Lodash、Moment.js等库，简化数据处理操作。
- **API集成**：如Axios、Request等库，方便进行第三方API集成。

##### 4. 高效的JSON处理

Node.js天然支持JavaScript对象和JSON格式的数据处理，这与大多数前端应用的数据交换格式（JSON）高度契合，使得数据的序列化和反序列化操作非常高效。

##### 5. 实时功能

Node.js对WebSocket等实时通信协议有良好的支持，可以轻松实现实时数据推送和双向通信，这对于需要实时交互的前端应用非常重要。

##### 6. 微服务架构

Node.js适合构建微服务架构，可以将BFF作为多个独立的微服务之一。这种架构可以带来更好的可扩展性和灵活性，并且每个微服务可以独立部署和扩展。

##### 7. 开发和部署速度

Node.js的轻量级和高效特性使得开发和部署BFF服务非常快速：

- **快速启动**：Node.js应用通常启动速度很快，适合频繁的开发和部署迭代。
- **轻量级**：Node.js应用占用资源较少，可以快速部署在各种环境中，包括云服务和容器中。

##### 8. 社区支持和文档

Node.js拥有强大的社区支持和丰富的文档，开发者可以轻松找到各种问题的解决方案和最佳实践，从而提高开发效率。

##### 总结

使用Node.js作为BFF的实现技术具有许多优点，包括单线程非阻塞I/O模型、高效的JSON处理、JavaScript全栈开发、丰富的生态系统、强大的实时功能支持、适合微服务架构、高效的开发和部署速度，以及良好的社区支持。这些优点使得Node.js成为构建BFF的理想选择。

</details>

#### http3/http2

<details >
<summary>Click to expand</summary>

HTTP的下一代是HTTP/2和HTTP/3，它们在HTTP/1.1的基础上进行了改进，以解决一些性能和效率方面的问题。以下是HTTP/2和HTTP/3分别解决的主要问题：

##### HTTP/2

HTTP/2于2015年正式发布，是对HTTP/1.1的重大升级，主要解决了以下问题：

1. **多路复用（Multiplexing）**

   - **问题**：HTTP/1.1中，每个请求都需要建立一个单独的TCP连接，容易导致连接的数量和资源的浪费。浏览器通常限制同一域名下并发TCP连接的数量。
   - **解决方案**：HTTP/2通过多路复用允许在一个TCP连接中同时发送多个请求和响应，从而提高了传输效率。

2. **头部压缩（Header Compression）**

   - **问题**：HTTP/1.1中，头部信息在每个请求中都是冗余的，尤其是在使用Cookies等情况时，这会导致额外的开销。
   - **解决方案**：HTTP/2引入了HPACK头部压缩算法，可以有效地压缩头部信息，减少传输的数据量。

3. **服务器推送（Server Push）**

   - **问题**：在HTTP/1.1中，服务器只能响应客户端的请求，无法主动推送数据到客户端。
   - **解决方案**：HTTP/2允许服务器在客户端请求前主动推送资源（如CSS、JavaScript文件），减少了请求的往返次数，提高了页面加载速度。

4. **二进制分帧（Binary Framing）**
   - **问题**：HTTP/1.1使用文本格式传输数据，解析起来相对复杂且效率较低。
   - **解决方案**：HTTP/2使用二进制格式传输数据，解析和处理起来更加高效和可靠。

##### HTTP/3

HTTP/3是基于QUIC协议的，它在HTTP/2的基础上进一步优化，主要解决以下问题：

1. **基于UDP的QUIC协议**

   - **问题**：TCP连接建立时间较长（三次握手），以及丢包重传机制容易导致延迟增加。
   - **解决方案**：HTTP/3基于UDP传输协议的QUIC，通过减少连接建立时间（零次握手或一次握手）和改进丢包处理机制（丢包只影响单个流而非整个连接），大大减少了延迟，提高了传输效率。

2. **连接迁移**

   - **问题**：在TCP连接中，客户端IP地址或网络变化会导致连接中断，需要重新建立连接。
   - **解决方案**：QUIC支持连接迁移，即使客户端的IP地址或网络发生变化，也能保持连接的持续性，避免重新建立连接的开销。

3. **内置加密**
   - **问题**：在HTTP/1.1和HTTP/2中，安全性主要通过TLS层提供，但这引入了额外的复杂性和握手延迟。
   - **解决方案**：QUIC协议内置加密机制，简化了加密的实现，并且由于是设计之初就考虑到安全性，因此性能和安全性都得到了优化。

##### 总结

HTTP/2和HTTP/3分别通过多路复用、头部压缩、服务器推送、二进制分帧等技术，以及基于QUIC协议的低延迟连接、连接迁移和内置加密等特性，解决了HTTP/1.1中的性能、效率和安全性问题。这些改进旨在提升网络传输的速度、可靠性和用户体验，特别是在现代Web应用程序中，HTTP/2和HTTP/3的应用越来越广泛。

</details>

#### restful接口架构的优缺点

<blockquote>
  RESTful接口架构具有简单性、可扩展性、统一接口、状态无关性和可缓存性等优点，但也存在一些缺点，如过度网络传输、安全性、灵活性、性能和不适用于所有场景等问题。在选择API设计风格时，需要根据具体的业务需求和系统要求进行综合考虑，并灵活选择合适的API设计风格
</blockquote>

#### 前端个人规划

不断提升自己的技能水平和竞争力，才能在不断变化的行业中保持领先并实现个人价值

#### mvvm

<details>
<summary>Click to expand</summary>

MVVM（Model-View-ViewModel）是一种前端架构模式，旨在将应用程序的用户界面（View）、业务逻辑（ViewModel）和数据模型（Model）进行分离，以提高代码的可维护性和可测试性。下面是MVVM结构的主要组成部分和工作原理：

##### 1. Model（模型）

- **定义**：Model代表应用程序的数据模型，负责处理数据的存储、获取和处理。
- **责任**：负责与服务器端通信、数据库交互、数据校验、业务逻辑等操作，提供数据给ViewModel。
- **特点**：通常是纯数据对象，不包含任何业务逻辑。

##### 2. View（视图）

- **定义**：View是应用程序的用户界面，负责展示数据给用户，并接收用户的输入和操作。
- **责任**：负责展示ViewModel提供的数据，以及将用户的操作反馈给ViewModel。
- **特点**：通常是由HTML、CSS和JavaScript构成的页面或组件，负责展示数据和处理用户交互。

##### 3. ViewModel（视图模型）

- **定义**：ViewModel是View和Model之间的连接器，负责处理View和Model之间的通信和交互。
- **责任**：负责从Model中获取数据，并将数据转换成View可以展示的格式，同时监听View的用户交互事件，将用户操作转发给Model。
- **特点**：通常包含业务逻辑、数据格式化、数据转换和状态管理等功能，但不涉及具体的DOM操作。

### MVVM工作原理：

1. **初始化**：View加载时，ViewModel会初始化，并开始与Model进行交互，获取初始数据。
2. **数据绑定**：ViewModel将数据绑定到View上，使得View能够动态展示ViewModel提供的数据。
3. **用户交互**：ViewModel监听View上的用户交互事件（如点击、输入等），并根据用户的操作更新内部状态或者向Model发送请求。
4. **数据更新**：当Model的数据发生变化时，ViewModel会及时地将新的数据更新到View上，保持View的显示与数据的同步。
5. **数据传递**：ViewModel负责将用户的操作转换成Model能够理解的数据格式，并将数据传递给Model进行处理。
6. **状态管理**：ViewModel负责管理View的状态（如显示/隐藏、可用/禁用等），并响应用户的操作来更新状态。

### 优点：

- **分离关注点**：将UI逻辑和业务逻辑分离，使得代码更易于理解和维护。
- **可测试性**：ViewModel通常是纯JavaScript对象，便于编写单元测试。
- **重用性**：ViewModel可以在不同的View中重用，增加了代码的复用性。

### 缺点：

- **学习成本**：相比传统的MVC结构，MVVM需要学习额外的概念和技术，可能会增加学习曲线。
- **复杂性**：对于简单的应用程序，引入MVVM可能会增加不必要的复杂性。
- **性能开销**：MVVM框架通常会增加一些性能开销，如数据绑定、依赖追踪等。

### 总结：

MVVM是一种将数据、UI和业务逻辑进行分离的前端架构模式，通过ViewModel实现数据的双向绑定和交互，提高了代码的可维护性和可测试性，但也需要在学习成本和性能开销上进行权衡。

</details>

#### vue v-model

<blockquote>
  v-model
  的原理是通过在表单元素上绑定数据属性，并监听元素的输入事件，实现了视图与数据之间的双向绑定，使得数据的变化能够实时反映到视图上，同时用户的操作也能够同步更新到数据层。
</blockquote>

#### 监控

<details>
<summary>Click to expand</summary>

前端项目监控是指对前端项目的性能、错误、用户行为等进行监控和分析，以便及时发现和解决问题，提高用户体验和系统稳定性。以下是一些常见的前端项目监控内容：

##### 1. 性能监控

- **页面加载时间**：监控页面的加载时间，包括DNS解析、TCP连接、DOM渲染等各个环节的耗时。
- **资源加载时间**：监控各种资源（如图片、脚本、样式表）的加载时间，以及资源的缓存命中率。
- **页面性能指标**：监控关键性能指标，如首次内容渲染时间（FCP）、首次有效渲染时间（FMP）、可交互时间（TTI）等。

##### 2. 错误监控

- **JavaScript错误**：监控页面中的JavaScript错误，包括语法错误、运行时错误、跨域错误等。
- **资源加载错误**：监控页面中资源加载失败的情况，如404错误、跨域加载限制等。
- **API请求错误**：监控与后端接口的请求错误，包括网络错误、超时错误、服务端错误等。

##### 3. 用户行为监控

- **页面PV/UV**：统计页面的访问量（PV）和独立访客数（UV），了解页面的流量情况。
- **用户行为分析**：监控用户在页面上的操作行为，如点击、滚动、输入等，以及用户的停留时长和转化路径。
- **设备信息**：收集用户的设备信息，包括浏览器类型、操作系统、分辨率等，以优化页面的兼容性和性能。

##### 4. 实时监控和报警

- **实时监控**：及时收集和展示监控数据，以便开发者实时了解项目的运行情况。
- **异常报警**：设置异常阈值和报警规则，当监控数据超出设定范围时，及时发送报警通知，以便开发者及时处理问题。

##### 5. 数据分析和可视化

- **数据统计**：对监控数据进行统计和分析，生成报表和趋势图，以便开发者了解项目的运行趋势和性能瓶颈。
- **可视化展示**：将监控数据以可视化的方式展示，如图表、地图、仪表盘等，使得数据更加直观和易于理解。

##### 6. 安全监控

- **XSS攻击**：监控页面中的跨站脚本攻击（XSS），防止恶意脚本对页面进行篡改和窃取用户信息。
- **CSRF攻击**：监控页面中的跨站请求伪造攻击（CSRF），防止恶意请求对用户数据进行操作和篡改。

综合以上内容，前端项目监控旨在全面了解项目的性能、错误和用户行为情况，及时发现和解决问题，提升用户体验和项目稳定性。可以借助各种监控工具和服务来实现监控需求，如Google Analytics、Sentry、New Relic、Datadog等。

</details>

#### 微服务

<blockquote>
  微服务是一种软件架构风格，它将应用程序构建为一组小型、独立的服务，每个服务都围绕着特定的业务功能进行构建，并通过轻量级通信机制（通常是HTTP
  API）进行通信
</blockquote>

#### 自动化

<details>
<summary>Click to expand</summary>

前端自动化开发和测试是一种提高开发效率和软件质量的重要手段，通常包括自动化构建、自动化测试、持续集成和持续交付等流程。将这些自动化过程产品化，可以进一步提高开发团队的工作效率和软件质量。下面是一些常见的前端自动化开发/测试过程产品化的步骤和方法：

### 1. 自动化构建

- **产品化步骤**：
  1. 设计和实现统一的构建工具链，如Webpack、Parcel等，以实现前端资源的打包、压缩和优化。
  2. 定制化构建流程，根据项目需求和团队规范配置构建任务，包括编译、打包、代码检查、资源合并等。
  3. 集成自动化构建到版本控制系统中，并配置持续集成工具，如Jenkins、Travis CI等，实现代码提交后自动触发构建。

### 2. 自动化测试

- **产品化步骤**：
  1. 设计和实现自动化测试框架，如Jest、Mocha、Cypress等，用于编写和运行单元测试、集成测试和端到端测试。
  2. 编写和维护自动化测试用例，覆盖项目的各个功能模块和边界情况，保证代码的稳定性和可靠性。
  3. 集成自动化测试到持续集成流程中，确保每次代码提交都会触发自动化测试，及时发现和修复问题。

### 3. 持续集成和持续交付

- **产品化步骤**：
  1. 设计和实现持续集成和持续交付流水线，通过配置CI/CD工具实现自动化构建、测试、部署和发布。
  2. 配置自动化测试和静态代码检查任务，确保每次代码提交都会自动进行测试和代码质量检查。
  3. 实现自动化部署和发布，将构建好的代码自动部署到测试环境、预生产环境和生产环境，实现快速迭代和持续交付。

### 4. 监控和反馈

- **产品化步骤**：
  1. 配置监控和告警系统，监控项目的构建、测试、部署和运行状态，及时发现和处理异常情况。
  2. 实现持续反馈机制，定期汇总和分析自动化测试和构建的结果，生成报告和可视化数据，为团队提供决策支持和持续改进。

### 5. 文档和培训

- **产品化步骤**：
  1. 编写和维护自动化开发/测试流程的文档和手册，包括工具的使用方法、流程的配置步骤、常见问题解答等内容。
  2. 定期组织培训和分享会议，向团队成员介绍和演示自动化开发/测试工具和流程，提高团队的技术水平和工作效率。

通过以上产品化的步骤和方法，可以将前端自动化开发/测试过程标准化和规范化，提高团队的工作效率和软件质量，从而实现快速迭代和持续交付。

</details>

#### 聊聊缓存

<details>
<summary>Click to expand</summary>

缓存是指将数据临时存储在计算机内存或磁盘中，以便在后续访问时能够更快地获取数据。在Web开发中，缓存是提高网站性能和用户体验的重要手段之一。下面是与缓存相关的一些重要概念：

### 1. ETag（实体标签）

- **作用**：ETag是由服务器为每个资源分配的唯一标识符，用于标识资源的版本号或内容是否发生变化。
- **工作原理**：当客户端请求一个资源时，服务器会生成该资源的ETag，并在响应头中返回给客户端。客户端在后续请求时，可以将该ETag通过请求头的If-None-Match字段发送给服务器，用于验证资源是否发生变化。
- **优点**：可以更精确地判断资源是否发生变化，减少不必要的数据传输。
- **示例**：`ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"`

### 2. Expires（过期时间）

- **作用**：Expires是指定资源的过期时间，告诉客户端该资源在何时过期，需要重新获取新的资源。
- **工作原理**：服务器在响应头中返回Expires字段，告诉客户端该资源的过期时间。客户端在收到资源后，将会在过期时间后重新请求该资源。
- **示例**：`Expires: Wed, 21 Oct 2026 07:28:00 GMT`

### 3. Cache-Control（缓存控制）

- **作用**：Cache-Control是用来指定客户端和代理服务器对缓存进行控制的指令，包括缓存的存储方式、过期时间、验证方式等。
- **常用指令**：
  - `max-age=<seconds>`：指定缓存存储的最长时间。
  - `no-cache`：强制客户端对资源进行重新验证，不直接使用缓存。
  - `no-store`：不缓存资源的任何内容。
  - `public`：表示响应可以被任何缓存所缓存。
  - `private`：表示响应只能被单个用户缓存。
- **示例**：`Cache-Control: max-age=3600, public`

这些缓存相关的概念在Web开发中经常被使用，可以通过设置合适的缓存策略来提高网站性能、减少服务器负载，并改善用户体验。

</details>

#### 栈与堆

<details open>
<summary>Click to expand</summary>

栈和堆是计算机内存中用于存储数据的两种不同的区域，它们在内存管理和存储方式上有一些重要的区别。

### 栈（Stack）

- **特点**：

  - 栈是一种线性的数据结构，遵循后进先出（LIFO）的原则。
  - 栈的操作通常包括入栈（push）和出栈（pop）。
  - 栈的大小通常是固定的，由操作系统提前分配好内存空间。

- **应用场景**：

  - 存储局部变量和函数调用的上下文信息。
  - 存储函数的调用参数、返回地址和临时变量。

- **特点**：
  - 栈的分配和释放都是自动的，由编译器负责管理，无需手动释放内存。
  - 栈的分配速度比较快，因为只需要移动栈指针即可。
  - 栈的空间相对较小，通常只能存储局部变量和函数调用信息，不能存储大型对象。

### 堆（Heap）

- **特点**：

  - 堆是一种动态分配的内存区域，大小不固定。
  - 堆的数据存储没有特定的顺序，分配和释放的顺序由程序员控制。
  - 堆的内存空间通常比栈大，可以存储大型对象和数据结构。

- **应用场景**：

  - 存储动态分配的对象、数组和数据结构。
  - 存储全局变量和静态变量。

- **特点**：
  - 堆的分配和释放需要手动管理，程序员负责申请内存和释放内存，否则会出现内存泄漏。
  - 堆的分配速度相对较慢，因为需要考虑内存碎片和地址分配的问题。
  - 堆的空间相对较大，可以存储大型对象和数据结构，但也容易出现内存碎片问题。

总的来说，栈和堆是计算机内存中两种不同的数据存储区域，它们在内存管理、分配方式和存储内容上有着明显的区别。在编程中，栈通常用于存储局部变量和函数调用信息，而堆用于存储动态分配的对象和数据结构。

</details>

#### 水平垂直居中

<details open>
<summary>Click to expand</summary>
在CSS中实现内容水平垂直居中有多种方案，下面列举了一些常用的方法：

### 1. 使用 Flexbox 布局

利用 Flexbox 可以轻松实现内容的水平和垂直居中。

```css
.container {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
}
```

### 2. 使用 Grid 布局

同样，Grid 布局也提供了简单的方式来实现内容的水平和垂直居中。

```css
.container {
  display: grid;
  place-items: center; /* 同时水平和垂直居中 */
}
```

### 3. 使用绝对定位和负边距

将内容设置为绝对定位，并利用负边距的方式实现水平和垂直居中。

```css
.container {
  position: relative;
}

.content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

### 4. 使用表格布局

利用表格布局的特性，可以将内容轻松地水平和垂直居中。

```css
.container {
  display: table;
}

.content {
  display: table-cell;
  text-align: center; /* 水平居中 */
  vertical-align: middle; /* 垂直居中 */
}
```

### 5. 使用 line-height

如果内容只有一行文本，可以利用 line-height 实现垂直居中。

```css
.container {
  line-height:  /* 和容器高度相同的值 *;
  text-align: center; /* 水平居中 */
}
```

以上这些方法都可以实现内容的水平和垂直居中，具体使用哪种方法取决于项目的需求和个人偏好。

</details>

#### js写一个快排

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr.splice(pivotIndex, 1)[0];
  const left = [];
  const right = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return quickSort(left).concat([pivot], quickSort(right));
}

// 示例
const array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
console.log(quickSort(array)); // 输出 [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
```

#### ts内置工具类

<details open>
<summary>Click to expand</summary>

```
Partial<T>
将类型 T 中的所有属性设置为可选属性。
Required<T>
将类型 T 中的所有属性设置为必选属性。
Readonly<T>
将类型 T 中的所有属性设置为只读属性。
Record<K, T>
创建一个由类型 K 中的键和类型 T 中的值组成的对象类型。
Pick<T, K>
从类型 T 中选取部分属性，组成一个新的类型。
Omit<T, K>
从类型 T 中排除指定的属性，组成一个新的类型。
```

</details>

#### iframe页面通信

<details open>
<summary>Click to expand</summary>

在 Web 开发中，如果在一个页面（父页面）中嵌入了另一个页面（子页面）的 iframe，通常会涉及到两个页面之间的通信问题。下面是一些常见的 iframe 页面通信方法：

### 1. Window.postMessage()

`postMessage()` 方法允许安全地实现跨域通信。通过在父页面中使用 `postMessage()` 方法向子页面发送消息，或者在子页面中使用 `postMessage()` 方法向父页面发送消息，可以实现双向通信。

**父页面中发送消息：**

```javascript
const iframeWindow = document.getElementById("myIframe").contentWindow;
iframeWindow.postMessage("Hello from parent!", "https://example.com");
```

**子页面中接收消息：**

```javascript
window.addEventListener("message", event => {
  if (event.origin === "https://example.com") {
    console.log("Message from parent:", event.data);
  }
});
```

### 2. Window.parent

子页面可以通过 `window.parent` 属性直接访问父页面的 `window` 对象，从而进行通信。

**子页面向父页面发送消息：**

```javascript
window.parent.postMessage("Hello from iframe!", "https://example.com");
```

**父页面接收消息：**

```javascript
window.addEventListener("message", event => {
  if (event.origin === "https://example.com") {
    console.log("Message from iframe:", event.data);
  }
});
```

### 3. Window.frames

父页面可以通过 `window.frames` 属性访问到子页面的 `window` 对象，从而进行通信。

**父页面向子页面发送消息：**

```javascript
const iframeWindow = window.frames["myIframe"];
iframeWindow.postMessage("Hello from parent!", "https://example.com");
```

**子页面接收消息：**

```javascript
window.addEventListener("message", event => {
  if (event.origin === "https://example.com") {
    console.log("Message from parent:", event.data);
  }
});
```

通过以上方法，父页面和子页面可以实现跨域的安全通信，实现双向通信，从而实现更丰富的交互体验。在实际使用中，需要注意安全性和数据的有效性，以防止恶意攻击和信息泄露。

</details>

#### async && defer

<details>
<summary>Click to expand</summary>

`defer` 和 `async` 是用于优化脚本加载和执行顺序的 HTML `<script>` 标签的属性。

### 1. defer 属性

`defer` 属性告诉浏览器，脚本在执行的过程中不会影响文档的解析，即脚本会被延迟执行，直到文档解析完成后再执行。多个带有 defer 属性的脚本会按照它们在文档中出现的顺序依次执行。

```html
<script src="script.js" defer></script>
```

**特点**：

- 脚本会在文档解析完成后执行，但在 DOMContentLoaded 事件之前执行。
- 多个带有 defer 属性的脚本会按照它们在文档中出现的顺序依次执行。
- 适合用于不需要立即执行的脚本，可以减少页面加载时间。

### 2. async 属性

`async` 属性告诉浏览器立即下载脚本文件，但不阻塞文档解析，一旦脚本下载完成，立即开始执行。多个带有 async 属性的脚本在下载完成后会并行执行，不会按照它们在文档中出现的顺序依次执行。

```html
<script src="script.js" async></script>
```

**特点**：

- 脚本会在下载完成后立即执行，不会阻塞文档解析。
- 多个带有 async 属性的脚本会并行下载，并且在下载完成后立即执行，执行顺序不确定。
- 适合用于不依赖于文档内容的脚本，可以提高页面加载的并行度。

### 选择使用场景

- 如果脚本依赖于文档中的 DOM 结构，应该使用 defer 属性，以确保脚本在 DOMContentLoaded 事件之前执行。
- 如果脚本不依赖于文档内容，且可以在任何时候执行，可以使用 async 属性，以提高脚本的并行下载和执行效率。

在选择使用 defer 还是 async 属性时，需要根据脚本的具体需求和依赖关系来决定，以确保脚本能够正确加载和执行，并且不会影响页面性能和用户体验。

</details>

#### url到页面呈现的过程

<details open>
<summary>Click to expand</summary>

将 URL 输入到浏览器地址栏并按下回车键后，浏览器开始加载并呈现页面的过程通常包括以下几个步骤：

### 1. URL 解析

浏览器首先会对输入的 URL 进行解析，提取出协议、主机名、端口号、路径和查询参数等信息。

### 2. DNS 解析

浏览器需要将主机名解析成对应的 IP 地址，这个过程称为 DNS 解析。浏览器会首先检查本地 DNS 缓存，如果找不到对应的 IP 地址，则向 DNS 服务器发送查询请求，获取对应的 IP 地址。

### 3. 建立 TCP 连接

浏览器通过获取到的 IP 地址和端口号与服务器建立 TCP 连接。这个过程包括三次握手，即客户端向服务器发送 SYN 报文，服务器回复 SYN+ACK 报文，最后客户端发送 ACK 报文，建立起 TCP 连接。

### 4. 发送 HTTP 请求

建立好 TCP 连接后，浏览器向服务器发送 HTTP 请求。请求中包含请求方法、URL、请求头和请求体等信息。服务器接收到请求后开始处理，并返回响应。

### 5. 接收响应并解析

浏览器接收到服务器返回的响应后，开始解析响应头和响应体。根据响应头中的 Content-Type 等信息确定响应的类型，如 HTML、CSS、JavaScript 或者其他资源类型。

### 6. 渲染页面

如果响应的内容为 HTML 文档，则浏览器开始解析 HTML，构建 DOM 树；接着解析 CSS 样式文件，构建 CSSOM 树；然后将 DOM 树和 CSSOM 树结合，生成渲染树（Render Tree）；最后根据渲染树进行布局和绘制，将页面内容显示在浏览器窗口中。

### 7. 下载并执行 JavaScript

如果响应中包含 JavaScript 文件，浏览器会下载并执行 JavaScript 代码。JavaScript 的执行可能会改变 DOM 结构和样式，影响页面的渲染。

### 8. 加载其他资源

页面中可能包含其他的资源，如图片、字体、视频等。浏览器会根据 HTML 和 CSS 中的引用下载这些资源，并在需要时进行渲染。

### 9. 页面加载完成

当所有的资源都加载完成，页面渲染完成后，浏览器触发 `DOMContentLoaded` 事件，表示 HTML 文档已经完全加载和解析；如果页面中包含图片等外部资源，当这些资源都加载完成后，浏览器触发 `load` 事件，表示页面已经全部加载完成。

</details>

### 36\*一面总结

#### vuex中mutation和action的区别

#### js冒泡排序

#### js手写防抖

#### 将get参数转对象

#### 代码混淆的原理

#### vue单向数据流

#### react hoc

#### webp的优缺点

#### spa应用的优缺点及改进方案

#### 自我介绍

#### 详细讲讲vue3重构vue2的过程及技术难点
