---
title: interview
pubDatetime: 2023-10-19 14:05:00
postSlug: interview
featured: false
draft: false
tags:
  - 八股
  - interview
  - 面经
description: "在前端面试过程中，对于记录面试经历是很有帮助的，这样可以更好地总结经验、查漏补缺，并在以后的面试中有所提升"
---

## 目录

## basic

### Hydration

<details>
<summary>Hydration</summary>

</details>

Hydration（即“水合”）在前端框架和库中是一个重要的概念。它主要与服务器渲染（Server-Side Rendering，SSR）和客户端渲染（Client-Side Rendering，CSR）相结合。下面我将详细解释它的意义和应用：

服务器渲染 (SSR)：
当一个页面首次加载时，如果使用服务器渲染，服务器会生成一个完整的 HTML 文档，并将其发送到客户端。这意味着浏览器可以立即看到内容，而不需要等待 JavaScript 下载和执行。

客户端渲染 (CSR)：
在客户端渲染中，页面的大部分或全部内容由 JavaScript 在浏览器中动态生成。这意味着浏览器首先需要下载和执行 JavaScript，然后才能看到完整的内容。

水合 (Hydration)：
当使用服务器渲染（SSR）并且随后启动客户端渲染（CSR）时，需要确保两者之间的内容一致性和可交互性。这就是“水合”所起的作用。水合是指客户端 JavaScript“接管”由服务器渲染生成的静态 HTML，将其转换为可交互的动态内容，同时保持用户界面的状态和事件处理程序。

在 React、Vue 和其他一些现代前端框架中，水合是自动处理的。框架会比较服务器渲染生成的 HTML 与客户端 JavaScript 生成的内容，并确保它们之间的一致性。

为什么水合很重要？

性能优化：通过使用服务器渲染和水合，您可以提供更快的首次加载时间和更好的性能体验。

SEO 友好：服务器渲染生成的静态 HTML 对搜索引擎更友好，这有助于提高页面的搜索排名。

用户体验：通过尽快显示内容并立即添加交互性，可以提供更好的用户体验。

总之，水合是前端开发中一个关键的概念，它结合了服务器渲染和客户端渲染的优点，为用户提供了更好的性能和体验。

### Closure

**闭包是对外部作用域变量的实时引用，而非复制**

<details>

<summary>2024/01/08 js闭包以及应用</summary>

闭包（Closure）是JavaScript中的一个重要概念，它与作用域、变量生命周期等紧密相关。闭包在JavaScript中有着广泛的应用，下面我将首先简要解释闭包的概念，然后列举一些常见的闭包应用场景。

#### 什么是闭包？

闭包是指有权访问另一个函数作用域中的变量的函数。简单来说，当一个函数在另一个函数内部定义时，并且这个内部函数引用了外部函数的变量，那么就产生了一个闭包。

#### 闭包的形成条件：

1. 函数嵌套：一个函数定义在另一个函数内部。
2. 内部函数引用了外部函数的变量。

#### 闭包的应用：

1. **封装私有变量和方法**：

   ```javascript
   function createCounter() {
     let count = 0;
     return {
       increment: function () {
         count++;
         return count;
       },
       decrement: function () {
         count--;
         return count;
       },
     };
   }
   const counter = createCounter();
   console.log(counter.increment()); // 输出 1
   console.log(counter.decrement()); // 输出 0
   ```

2. **模块模式**：通过闭包可以创建私有变量和方法，从而实现模块化的编程。

3. **事件监听器**：

   ```javascript
   function attachEvent() {
     let count = 0;
     document.getElementById("btn").addEventListener("click", function () {
       count++;
       console.log(`Button clicked ${count} times.`);
     });
   }
   attachEvent();
   ```

4. **循环与闭包**：在循环中使用闭包时，需要特别注意闭包与循环变量的交互。

   ```javascript
   for (var i = 0; i < 5; i++) {
     setTimeout(function () {
       console.log(i); // 输出 5, 5, 5, 5, 5
     }, 1000);
   }
   ```

   上述代码会输出五次5，因为循环结束后i的值为5。为了解决这个问题，可以使用IIFE（立即调用函数表达式）。

   ```javascript
   for (var i = 0; i < 5; i++) {
     (function (j) {
       setTimeout(function () {
         console.log(j); // 输出 0, 1, 2, 3, 4
       }, 1000);
     })(i);
   }
   ```

5. **实现函数柯里化**：通过闭包，可以实现函数柯里化，即将多参数的函数转化为一系列使用一个参数的函数。

6. **缓存**：通过闭包缓存计算结果，提高性能。
   ```javascript
   function memoize(fn) {
     const cache = {};
     return function (...args) {
       const key = JSON.stringify(args);
       if (cache[key] === undefined) {
         cache[key] = fn(...args);
       }
       return cache[key];
     };
   }
   ```

总结：闭包是JavaScript中的一个强大而灵活的特性，可以用于创建私有变量和方法、实现模块化、事件监听等。但同时也需要注意闭包可能带来的内存泄漏问题，因为闭包会保留外部函数的作用域链。

</details>

## 面经

### 牛客1-偏算法

#### 您了解的排序算法有哪些？/这些排序算法是如何实现的？

我了解的排序算法包括但不限于以下几种：

1. **冒泡排序（Bubble Sort）：** 通过不断交换相邻元素，将最大（或最小）的元素逐步“冒泡”到最后（或最前）的位置。
2. **选择排序（Selection Sort）：** 每次从未排序的元素中选取最小（或最大）的元素，放到已排序部分的末尾。
3. **插入排序（Insertion Sort）：** 将待排序的元素逐个插入到已排序部分的合适位置，从而实现排序。
4. **快速排序（Quick Sort）：** 选择一个基准元素，将小于基准的元素放到基准的左侧，大于基准的元素放到右侧，然后递归地对左右两部分进行排序。
5. **归并排序（Merge Sort）：** 将待排序的数组不断地分割成更小的数组，直到每个数组只有一个元素，然后将这些小数组合并成一个新的有序数组。
6. **堆排序（Heap Sort）：** 将待排序的数组构建成一个二叉堆，然后不断地移除堆顶元素（最大或最小），并重新调整堆，直到所有元素都被移除。

7. **计数排序（Counting Sort）：** 统计数组中每个元素的出现次数，然后根据元素的大小顺序，将其放置到正确的位置上。

8. **桶排序（Bucket Sort）：** 将待排序的元素分配到不同的桶中，对每个桶中的元素进行排序，然后按照顺序合并所有桶。

9. **基数排序（Radix Sort）：** 将待排序的数字按照位数进行分组，然后按照每一位的顺序依次进行排序，直到所有位都排序完成。

每种排序算法都有其优缺点，适用于不同的场景。例如，对于小规模的数据集，插入排序可能更快；对于大规模的数据集，快速排序或归并排序可能更合适。选择合适的排序算法取决于数据的特点、排序的稳定性要求、内存空间等因素。

#### 分析一下冒泡排序的时间复杂度?

冒泡排序的时间复杂度取决于比较和交换的次数。在冒泡排序中，每次都会比较相邻的两个元素，并根据需要交换它们的位置，直到整个数组排序完成。

假设待排序的数组长度为 `n`，冒泡排序的基本思想是通过多次遍历数组，每次都比较相邻的两个元素，将较大的元素交换到数组的末尾。在第一次遍历结束后，最大的元素会被交换到数组的最后一个位置；在第二次遍历中，第二大的元素会被交换到倒数第二个位置，依次类推。

##### 最坏情况下的时间复杂度：

在最坏的情况下，即待排序数组是逆序排列的情况下，冒泡排序需要进行 `n-1` 轮比较和交换。在每一轮比较中，需要比较 `n-i-1` 次（其中 `i` 是当前轮数），因为每次都会将当前轮最大的元素交换到数组的末尾。因此，总的比较次数为：

$$[ (n-1) + (n-2) + ... + 1 = \frac{n \cdot (n-1)}{2} ]$$

因此，冒泡排序的最坏情况下的时间复杂度为
$$O(n^2)$$

##### 最好情况下的时间复杂度：

在最好的情况下，即待排序数组已经是有序的情况下，冒泡排序只需要进行一轮遍历，每次比较都不需要交换元素。因此，最好情况下的时间复杂度为 $$O(n)$$。

##### 平均情况下的时间复杂度：

在平均情况下，冒泡排序需要进行 $$( \frac{n \cdot (n-1)}{4} )$$ 次比较和 $$( \frac{n \cdot (n-1)}{4} )$$ 次交换，因此平均时间复杂度仍为 $$( O(n^2) )$$。

##### 总结：

冒泡排序的时间复杂度在最坏和平均情况下都是 $$( O(n^2) )$$，因此它是一种效率较低的排序算法，不适用于大规模数据的排序。然而，由于其简单易懂的实现方式，冒泡排序在学习排序算法和简单数据集的排序中仍然具有一定的价值。

#### js实现冒泡排序

```js
function bubbleSort(arr) {
  const len = arr.length;
  let swapped; // 用于标记本轮是否有元素交换的标志

  // 外层循环控制轮数
  for (let i = 0; i < len - 1; i++) {
    swapped = false; // 在每轮开始前重置标志为 false

    // 内层循环控制比较和交换
    for (let j = 0; j < len - 1 - i; j++) {
      // 如果前面的元素比后面的元素大，则交换它们的位置
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 使用解构赋值交换元素
        swapped = true; // 标记本轮有元素交换
      }
    }

    // 如果本轮没有元素交换，则数组已经有序，直接退出循环
    if (!swapped) {
      break;
    }
  }

  return arr;
}

// 示例
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log("原始数组:", arr);
console.log("排序后数组:", bubbleSort(arr));
```

#### 分析一下快速排序的时间复杂度

快速排序是一种常用且高效的排序算法，其平均时间复杂度为 $(O(n \log n))$，最坏情况下的时间复杂度为 $(O(n^2))$，其中 $(n)$ 是待排序数组的长度。以下是快速排序时间复杂度的分析：

##### 平均情况下的时间复杂度：

在平均情况下，快速排序的时间复杂度为 $(O(n \log n))$。这是因为快速排序的基本操作是通过将数组分成两部分，使得左边部分的元素都小于右边部分的元素，并且基准元素（pivot）在排序后处于正确的位置。然后，递归地对左右两部分进行排序。在每一次分割过程中，需要遍历数组一次，因此快速排序的时间复杂度是 $(O(n))$；而在平均情况下，每次分割都能将数组划分为大小相近的两部分，因此需要的递归层数为 $(O(\log n))$。因此，平均情况下快速排序的时间复杂度为 $(O(n \log n))$。

##### 最坏情况下的时间复杂度：

在最坏情况下，快速排序的时间复杂度为 $(O(n^2))$。最坏情况发生在每次分割后，基准元素选取不合适，导致左右两部分的大小差别很大，从而导致递归树呈现出极端不平衡的状态。例如，当待排序数组已经有序时，如果每次选择的基准元素都是第一个或最后一个元素，那么快速排序的时间复杂度将会退化到 $(O(n^2))$。因此，为了避免最坏情况的发生，一般采用随机选择基准元素或者三数取中法等方法来提高快速排序的性能。

##### 最好情况下的时间复杂度：

在最好情况下，快速排序的时间复杂度也是 $(O(n \log n))$。最好情况发生在每次分割后，左右两部分的大小相等，递归树呈现出平衡状态。这样，在每一层递归中，都会将数组大小缩减为原来的一半，因此需要的递归层数为 $(O(\log n))$，每次分割的时间复杂度为 $(O(n))$，因此最好情况下的时间复杂度为 $(O(n \log n))$。

综上所述，快速排序的平均时间复杂度为 $(O(n \log n))$，最坏情况下的时间复杂度为 $(O(n^2))$，最好情况下的时间复杂度为 $(O(n \log n))$。由于其平均时间复杂度较低，因此快速排序是一种高效的排序算法，常被应用于实际开发中。

#### 了解heap内部是如何实现的？构造函数和push函数的时间复杂度是多少？分别详细讲解这两个函数实现了什么，如何得到该时间复杂度？

在 JavaScript 中，通常使用数组来实现堆（Heap）。堆是一种特殊的二叉树结构，其中每个节点的值都大于等于（或小于等于）其子节点的值，根据这个特性，堆可以分为最大堆和最小堆。

##### 构造函数的实现和时间复杂度：

构造函数主要用于创建一个空的堆或者根据给定的数组构建一个堆。在构造函数中，通常会执行一次堆化操作，将无序的数组转换为满足堆的特性的数组。

构造函数的实现步骤通常如下：

1. 将给定数组赋值给堆的内部数组。
2. 从数组的中间位置开始向前遍历，对每个非叶子节点执行下沉操作（sinkDown），以确保每个节点都满足堆的特性。

构造函数的时间复杂度取决于堆化操作的复杂度，通常为 $(O(n))$，其中 $(n)$ 是数组的长度。因为堆化操作中，我们需要对每个非叶子节点执行一次下沉操作，而非叶子节点的数量约为数组长度的一半。

##### push 函数的实现和时间复杂度：

push 函数用于向堆中添加一个新的元素，并保持堆的特性。通常，push 操作是将新元素添加到数组的末尾，然后执行一次上浮操作（percolateUp）。

push 函数的实现步骤如下：

1. 将新元素添加到数组的末尾。
2. 对新添加的元素执行一次上浮操作（percolateUp），将其与父节点进行比较并交换，直到满足堆的特性。

push 函数的时间复杂度取决于上浮操作的复杂度，通常为 $(O(\log n))$，其中 $(n)$ 是堆的大小。因为上浮操作中，我们需要将新添加的元素与其父节点进行比较并交换，直到满足堆的特性。最坏情况下，新添加的元素可能需要上浮到堆的根节点位置，因此上浮操作的时间复杂度与堆的高度有关，堆的高度通常为 $(\log n)$。

##### 总结：

- 构造函数的时间复杂度为 $(O(n))$，其中 $(n)$ 是数组的长度。
- push 函数的时间复杂度为 $(O(\log n))$，其中 $(n)$ 是堆的大小。

这些时间复杂度是根据堆的特性以及 push 和构造函数的实现步骤得出的。因为堆是一种树状结构，其操作的时间复杂度通常与树的高度相关，而堆的高度通常为 $(\log n)$，因此 push 函数的时间复杂度为 $(O(\log n))$。

### 牛客2-偏框架

#### React 组件的实现原理

React 组件通过 React.createElement 创建元素，通过虚拟 DOM 维护状态变化，类组件和函数组件分别通过生命周期方法和 Hooks 处理状态和副作用。组件的渲染和更新机制包括初始化渲染、状态更新、diff 算法和 DOM 更新。

#### 不同文件在浏览器中的存放形式

<details open>
<summary></summary>

在浏览器中，网页的不同文件类型通过不同的机制加载和存储。以下是一些常见文件类型及其在浏览器中的存放和处理方式：

##### HTML 文件

**存放形式**：

- **文档对象模型 (DOM)**：浏览器将 HTML 文件解析成 DOM 树，这是 HTML 文档的内存表示。每个 HTML 元素和属性在 DOM 中都作为节点存在。

**处理**：

- 浏览器从服务器加载 HTML 文件，将其解析为 DOM 树，然后通过 DOM API 可以动态操作这棵树。

##### CSS 文件

**存放形式**：

- **层叠样式表对象模型 (CSSOM)**：浏览器将 CSS 文件解析成 CSSOM 树，这与 DOM 树类似，是 CSS 样式的内存表示。

**处理**：

- 浏览器将 CSS 文件与 HTML 文件结合，通过 CSSOM 和 DOM 树共同决定页面的呈现样式。

##### JavaScript 文件

**存放形式**：

- **脚本引擎内存**：JavaScript 文件被浏览器加载并由 JavaScript 引擎（如 V8、SpiderMonkey 等）解析和执行。脚本内容会被保存在内存中。

**处理**：

- JavaScript 文件可以通过 `<script>` 标签内联在 HTML 文件中，或者作为外部文件通过 `<script src="...">` 引入。
- 浏览器会解析并执行这些脚本，脚本可以操作 DOM、CSSOM，以及执行其他任务。

##### 图像文件（如 JPEG、PNG、GIF 等）

**存放形式**：

- **内存中的位图**：浏览器将图像文件解码成内存中的位图，具体实现方式依赖于浏览器和操作系统。

**处理**：

- 图像文件通过 `<img>` 标签加载，或作为背景图像在 CSS 中定义。浏览器会从网络加载这些文件，并在解码后渲染到页面上。

##### 视频和音频文件（如 MP4、WebM、MP3 等）

**存放形式**：

- **媒体缓冲区**：浏览器将视频和音频文件加载到媒体缓冲区中，以便进行流式传输和播放。

**处理**：

- 这些文件通过 `<video>` 和 `<audio>` 标签加载，并由浏览器的内置媒体播放器解码和播放。

##### 字体文件（如 TTF、WOFF、WOFF2 等）

**存放形式**：

- **内存中的字体对象**：浏览器将字体文件加载并解析成内存中的字体对象。

**处理**：

- 字体文件通过 CSS 中的 `@font-face` 规则加载。加载后的字体会用于页面中的文本渲染。

##### JSON、XML 等数据文件

**存放形式**：

- **内存中的数据对象**：JSON 和 XML 文件在加载后会被解析成 JavaScript 对象或 DOM 对象，保存在内存中。

**处理**：

- 这些文件通常通过 JavaScript 的 `fetch` 或 `XMLHttpRequest` 加载，并用于 AJAX 请求的数据交换。

##### 例子：HTML 页面加载过程

当浏览器加载一个包含 HTML、CSS 和 JavaScript 的网页时，典型的过程如下：

1. **HTML 加载和解析**：

   - 浏览器请求 HTML 文件并开始解析，构建 DOM 树。
   - 在解析过程中，如果遇到 CSS 文件引用，浏览器会并行请求这些 CSS 文件。

2. **CSS 加载和解析**：

   - CSS 文件被加载和解析，构建 CSSOM 树。
   - 浏览器将 CSSOM 树与 DOM 树结合，生成渲染树。

3. **JavaScript 加载和执行**：

   - 如果 HTML 中有 `<script>` 标签，浏览器会按顺序加载和执行 JavaScript 文件。
   - JavaScript 可以操作已构建的 DOM 树和 CSSOM 树。

4. **资源加载**：

   - 图像、字体、视频等资源文件被并行加载。
   - 浏览器在资源加载完成后，将其解码并渲染到页面上。

5. **页面渲染**：
   - 浏览器根据渲染树计算每个节点的布局和样式。
   - 最终，浏览器将内容绘制到屏幕上。

##### 浏览器缓存

- **缓存机制**：浏览器会缓存已加载的文件（HTML、CSS、JavaScript、图像等），以减少重复请求，提升性能。
- **缓存位置**：文件缓存通常存储在浏览器的本地缓存中，可以通过 HTTP 头（如 `Cache-Control` 和 `ETag`）管理缓存策略。

通过理解不同文件在浏览器中的存放形式和处理方式，可以更好地优化网页性能和用户体验。

</details>

#### vuex在哪个阶段挂在在vue实例上

<blockquote>
Vuex 是一个独立的状态管理库，它并不是在 Vue 实例上挂载的，而是通过 Vue.use() 方法在 Vue 应用中进行安装。通常，Vuex 是在 Vue 根实例创建之前被安装的。

```js
import Vue from "vue";
import Vuex from "vuex";
import App from "./App.vue";

// 1. 使用 Vuex 插件
Vue.use(Vuex);

// 2. 创建 Vuex store 实例
const store = new Vuex.Store({
  state: {
    count: 0,
  },
  mutations: {
    increment(state) {
      state.count++;
    },
  },
});

// 3. 创建根 Vue 实例
new Vue({
  el: "#app",
  store, // 将 Vuex store 实例挂载到根实例上
  render: h => h(App),
});
```

</blockquote>

#### 在实际开发中shouldComponentUpdate有什么作用

- 避免在shouldComponentUpdate中进行过多或复杂的计算，以免影响性能。
- 如果shouldComponentUpdate返回false，那么render、componentDidUpdate等生命周期方法将不会被执行。
- 使用PureComponent或React.memo可以在某种程度上自动实现shouldComponentUpdate的功能，它们会对组件的属性进行浅比较，来决定是否重新渲染组件。
