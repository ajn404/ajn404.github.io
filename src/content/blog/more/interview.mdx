---
title: interview
pubDatetime: 2023-10-19 14:05:00
postSlug: interview
featured: false
draft: false
tags:
  - 八股
  - interview
  - 面经
description: "在前端面试过程中，对于记录面试经历是很有帮助的，这样可以更好地总结经验、查漏补缺，并在以后的面试中有所提升"
---

## 目录

## basic

### Hydration

<details>
<summary>Hydration</summary>

</details>

Hydration（即“水合”）在前端框架和库中是一个重要的概念。它主要与服务器渲染（Server-Side Rendering，SSR）和客户端渲染（Client-Side Rendering，CSR）相结合。下面我将详细解释它的意义和应用：

服务器渲染 (SSR)：
当一个页面首次加载时，如果使用服务器渲染，服务器会生成一个完整的 HTML 文档，并将其发送到客户端。这意味着浏览器可以立即看到内容，而不需要等待 JavaScript 下载和执行。

客户端渲染 (CSR)：
在客户端渲染中，页面的大部分或全部内容由 JavaScript 在浏览器中动态生成。这意味着浏览器首先需要下载和执行 JavaScript，然后才能看到完整的内容。

水合 (Hydration)：
当使用服务器渲染（SSR）并且随后启动客户端渲染（CSR）时，需要确保两者之间的内容一致性和可交互性。这就是“水合”所起的作用。水合是指客户端 JavaScript“接管”由服务器渲染生成的静态 HTML，将其转换为可交互的动态内容，同时保持用户界面的状态和事件处理程序。

在 React、Vue 和其他一些现代前端框架中，水合是自动处理的。框架会比较服务器渲染生成的 HTML 与客户端 JavaScript 生成的内容，并确保它们之间的一致性。

为什么水合很重要？

性能优化：通过使用服务器渲染和水合，您可以提供更快的首次加载时间和更好的性能体验。

SEO 友好：服务器渲染生成的静态 HTML 对搜索引擎更友好，这有助于提高页面的搜索排名。

用户体验：通过尽快显示内容并立即添加交互性，可以提供更好的用户体验。

总之，水合是前端开发中一个关键的概念，它结合了服务器渲染和客户端渲染的优点，为用户提供了更好的性能和体验。

### Closure

**闭包是对外部作用域变量的实时引用，而非复制**

<details>

<summary>2024/01/08 js闭包以及应用</summary>

闭包（Closure）是JavaScript中的一个重要概念，它与作用域、变量生命周期等紧密相关。闭包在JavaScript中有着广泛的应用，下面我将首先简要解释闭包的概念，然后列举一些常见的闭包应用场景。

#### 什么是闭包？

闭包是指有权访问另一个函数作用域中的变量的函数。简单来说，当一个函数在另一个函数内部定义时，并且这个内部函数引用了外部函数的变量，那么就产生了一个闭包。

#### 闭包的形成条件：

1. 函数嵌套：一个函数定义在另一个函数内部。
2. 内部函数引用了外部函数的变量。

#### 闭包的应用：

1. **封装私有变量和方法**：

   ```javascript
   function createCounter() {
     let count = 0;
     return {
       increment: function () {
         count++;
         return count;
       },
       decrement: function () {
         count--;
         return count;
       },
     };
   }
   const counter = createCounter();
   console.log(counter.increment()); // 输出 1
   console.log(counter.decrement()); // 输出 0
   ```

2. **模块模式**：通过闭包可以创建私有变量和方法，从而实现模块化的编程。

3. **事件监听器**：

   ```javascript
   function attachEvent() {
     let count = 0;
     document.getElementById("btn").addEventListener("click", function () {
       count++;
       console.log(`Button clicked ${count} times.`);
     });
   }
   attachEvent();
   ```

4. **循环与闭包**：在循环中使用闭包时，需要特别注意闭包与循环变量的交互。

   ```javascript
   for (var i = 0; i < 5; i++) {
     setTimeout(function () {
       console.log(i); // 输出 5, 5, 5, 5, 5
     }, 1000);
   }
   ```

   上述代码会输出五次5，因为循环结束后i的值为5。为了解决这个问题，可以使用IIFE（立即调用函数表达式）。

   ```javascript
   for (var i = 0; i < 5; i++) {
     (function (j) {
       setTimeout(function () {
         console.log(j); // 输出 0, 1, 2, 3, 4
       }, 1000);
     })(i);
   }
   ```

5. **实现函数柯里化**：通过闭包，可以实现函数柯里化，即将多参数的函数转化为一系列使用一个参数的函数。

6. **缓存**：通过闭包缓存计算结果，提高性能。
   ```javascript
   function memoize(fn) {
     const cache = {};
     return function (...args) {
       const key = JSON.stringify(args);
       if (cache[key] === undefined) {
         cache[key] = fn(...args);
       }
       return cache[key];
     };
   }
   ```

总结：闭包是JavaScript中的一个强大而灵活的特性，可以用于创建私有变量和方法、实现模块化、事件监听等。但同时也需要注意闭包可能带来的内存泄漏问题，因为闭包会保留外部函数的作用域链。

</details>

### 深圳渐近线科技

#### 您了解的排序算法有哪些？/这些排序算法是如何实现的？

我了解的排序算法包括但不限于以下几种：

1. **冒泡排序（Bubble Sort）：** 通过不断交换相邻元素，将最大（或最小）的元素逐步“冒泡”到最后（或最前）的位置。
2. **选择排序（Selection Sort）：** 每次从未排序的元素中选取最小（或最大）的元素，放到已排序部分的末尾。
3. **插入排序（Insertion Sort）：** 将待排序的元素逐个插入到已排序部分的合适位置，从而实现排序。
4. **快速排序（Quick Sort）：** 选择一个基准元素，将小于基准的元素放到基准的左侧，大于基准的元素放到右侧，然后递归地对左右两部分进行排序。
5. **归并排序（Merge Sort）：** 将待排序的数组不断地分割成更小的数组，直到每个数组只有一个元素，然后将这些小数组合并成一个新的有序数组。
6. **堆排序（Heap Sort）：** 将待排序的数组构建成一个二叉堆，然后不断地移除堆顶元素（最大或最小），并重新调整堆，直到所有元素都被移除。

7. **计数排序（Counting Sort）：** 统计数组中每个元素的出现次数，然后根据元素的大小顺序，将其放置到正确的位置上。

8. **桶排序（Bucket Sort）：** 将待排序的元素分配到不同的桶中，对每个桶中的元素进行排序，然后按照顺序合并所有桶。

9. **基数排序（Radix Sort）：** 将待排序的数字按照位数进行分组，然后按照每一位的顺序依次进行排序，直到所有位都排序完成。

每种排序算法都有其优缺点，适用于不同的场景。例如，对于小规模的数据集，插入排序可能更快；对于大规模的数据集，快速排序或归并排序可能更合适。选择合适的排序算法取决于数据的特点、排序的稳定性要求、内存空间等因素。

#### 分析一下冒泡排序的时间复杂度?

冒泡排序的时间复杂度取决于比较和交换的次数。在冒泡排序中，每次都会比较相邻的两个元素，并根据需要交换它们的位置，直到整个数组排序完成。

假设待排序的数组长度为 `n`，冒泡排序的基本思想是通过多次遍历数组，每次都比较相邻的两个元素，将较大的元素交换到数组的末尾。在第一次遍历结束后，最大的元素会被交换到数组的最后一个位置；在第二次遍历中，第二大的元素会被交换到倒数第二个位置，依次类推。

##### 最坏情况下的时间复杂度：

在最坏的情况下，即待排序数组是逆序排列的情况下，冒泡排序需要进行 `n-1` 轮比较和交换。在每一轮比较中，需要比较 `n-i-1` 次（其中 `i` 是当前轮数），因为每次都会将当前轮最大的元素交换到数组的末尾。因此，总的比较次数为：

$$[ (n-1) + (n-2) + ... + 1 = \frac{n \cdot (n-1)}{2} ]$$

因此，冒泡排序的最坏情况下的时间复杂度为
$$O(n^2)$$

##### 最好情况下的时间复杂度：

在最好的情况下，即待排序数组已经是有序的情况下，冒泡排序只需要进行一轮遍历，每次比较都不需要交换元素。因此，最好情况下的时间复杂度为 $$O(n)$$。

##### 平均情况下的时间复杂度：

在平均情况下，冒泡排序需要进行 $$( \frac{n \cdot (n-1)}{4} )$$ 次比较和 $$( \frac{n \cdot (n-1)}{4} )$$ 次交换，因此平均时间复杂度仍为 $$( O(n^2) )$$。

##### 总结：

冒泡排序的时间复杂度在最坏和平均情况下都是 $$( O(n^2) )$$，因此它是一种效率较低的排序算法，不适用于大规模数据的排序。然而，由于其简单易懂的实现方式，冒泡排序在学习排序算法和简单数据集的排序中仍然具有一定的价值。

#### js实现冒泡排序

```js
function bubbleSort(arr) {
  const len = arr.length;
  let swapped; // 用于标记本轮是否有元素交换的标志

  // 外层循环控制轮数
  for (let i = 0; i < len - 1; i++) {
    swapped = false; // 在每轮开始前重置标志为 false

    // 内层循环控制比较和交换
    for (let j = 0; j < len - 1 - i; j++) {
      // 如果前面的元素比后面的元素大，则交换它们的位置
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 使用解构赋值交换元素
        swapped = true; // 标记本轮有元素交换
      }
    }

    // 如果本轮没有元素交换，则数组已经有序，直接退出循环
    if (!swapped) {
      break;
    }
  }

  return arr;
}

// 示例
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log("原始数组:", arr);
console.log("排序后数组:", bubbleSort(arr));
```

#### 分析一下快速排序的时间复杂度

快速排序是一种常用且高效的排序算法，其平均时间复杂度为 $(O(n \log n))$，最坏情况下的时间复杂度为 $(O(n^2))$，其中 $(n)$ 是待排序数组的长度。以下是快速排序时间复杂度的分析：

##### 平均情况下的时间复杂度：

在平均情况下，快速排序的时间复杂度为 $(O(n \log n))$。这是因为快速排序的基本操作是通过将数组分成两部分，使得左边部分的元素都小于右边部分的元素，并且基准元素（pivot）在排序后处于正确的位置。然后，递归地对左右两部分进行排序。在每一次分割过程中，需要遍历数组一次，因此快速排序的时间复杂度是 $(O(n))$；而在平均情况下，每次分割都能将数组划分为大小相近的两部分，因此需要的递归层数为 $(O(\log n))$。因此，平均情况下快速排序的时间复杂度为 $(O(n \log n))$。

##### 最坏情况下的时间复杂度：

在最坏情况下，快速排序的时间复杂度为 $(O(n^2))$。最坏情况发生在每次分割后，基准元素选取不合适，导致左右两部分的大小差别很大，从而导致递归树呈现出极端不平衡的状态。例如，当待排序数组已经有序时，如果每次选择的基准元素都是第一个或最后一个元素，那么快速排序的时间复杂度将会退化到 $(O(n^2))$。因此，为了避免最坏情况的发生，一般采用随机选择基准元素或者三数取中法等方法来提高快速排序的性能。

##### 最好情况下的时间复杂度：

在最好情况下，快速排序的时间复杂度也是 $(O(n \log n))$。最好情况发生在每次分割后，左右两部分的大小相等，递归树呈现出平衡状态。这样，在每一层递归中，都会将数组大小缩减为原来的一半，因此需要的递归层数为 $(O(\log n))$，每次分割的时间复杂度为 $(O(n))$，因此最好情况下的时间复杂度为 $(O(n \log n))$。

综上所述，快速排序的平均时间复杂度为 $(O(n \log n))$，最坏情况下的时间复杂度为 $(O(n^2))$，最好情况下的时间复杂度为 $(O(n \log n))$。由于其平均时间复杂度较低，因此快速排序是一种高效的排序算法，常被应用于实际开发中。

#### 了解heap内部是如何实现的？构造函数和push函数的时间复杂度是多少？分别详细讲解这两个函数实现了什么，如何得到该时间复杂度？

在 JavaScript 中，通常使用数组来实现堆（Heap）。堆是一种特殊的二叉树结构，其中每个节点的值都大于等于（或小于等于）其子节点的值，根据这个特性，堆可以分为最大堆和最小堆。

##### 构造函数的实现和时间复杂度：

构造函数主要用于创建一个空的堆或者根据给定的数组构建一个堆。在构造函数中，通常会执行一次堆化操作，将无序的数组转换为满足堆的特性的数组。

构造函数的实现步骤通常如下：

1. 将给定数组赋值给堆的内部数组。
2. 从数组的中间位置开始向前遍历，对每个非叶子节点执行下沉操作（sinkDown），以确保每个节点都满足堆的特性。

构造函数的时间复杂度取决于堆化操作的复杂度，通常为 $(O(n))$，其中 $(n)$ 是数组的长度。因为堆化操作中，我们需要对每个非叶子节点执行一次下沉操作，而非叶子节点的数量约为数组长度的一半。

##### push 函数的实现和时间复杂度：

push 函数用于向堆中添加一个新的元素，并保持堆的特性。通常，push 操作是将新元素添加到数组的末尾，然后执行一次上浮操作（percolateUp）。

push 函数的实现步骤如下：

1. 将新元素添加到数组的末尾。
2. 对新添加的元素执行一次上浮操作（percolateUp），将其与父节点进行比较并交换，直到满足堆的特性。

push 函数的时间复杂度取决于上浮操作的复杂度，通常为 $(O(\log n))$，其中 $(n)$ 是堆的大小。因为上浮操作中，我们需要将新添加的元素与其父节点进行比较并交换，直到满足堆的特性。最坏情况下，新添加的元素可能需要上浮到堆的根节点位置，因此上浮操作的时间复杂度与堆的高度有关，堆的高度通常为 $(\log n)$。

##### 总结：

- 构造函数的时间复杂度为 $(O(n))$，其中 $(n)$ 是数组的长度。
- push 函数的时间复杂度为 $(O(\log n))$，其中 $(n)$ 是堆的大小。

这些时间复杂度是根据堆的特性以及 push 和构造函数的实现步骤得出的。因为堆是一种树状结构，其操作的时间复杂度通常与树的高度相关，而堆的高度通常为 $(\log n)$，因此 push 函数的时间复杂度为 $(O(\log n))$。
