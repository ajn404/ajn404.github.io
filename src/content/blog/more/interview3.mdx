---
title: interview(3)
pubDatetime: 2024-12-18T10:39:01Z
postSlug: interview3
ogImage: /assets/texture/麦瑟夫.webp
featured: false
draft: false
detailButton: true
tags:
  - interview
description: "前端面试(其二)"
---

我也开始面试别人了，哈哈哈哈哈哈~嗝

## 目录

## 12-18面了一个极越的大伙

#### 1. 介绍一下自己

巴拉巴拉讲了一堆

#### 2. 介绍一下项目

巴拉巴拉又讲了一堆

## 稍微难点的

---

### **一、JavaScript 深水区**

1. **事件循环（Event Loop）**

   - 如何理解 `macrotask` 和 `microtask` 的执行顺序？请结合代码示例说明 `Promise`、`MutationObserver` 和 `setTimeout` 的执行差异。
   - 如何实现一个 `sleep` 函数？用 `Promise` 和 `Generator` 分别实现，并解释原理。

2. **原型与继承**

   - 如何用 `ES5` 实现 `class A extends B` 的语法糖？请手写代码并解释 `super()` 的作用。
   - 原型链污染的原理是什么？如何避免此类安全漏洞？

3. **闭包与内存管理**
   - 闭包会导致哪些内存泄漏场景？如何通过 Chrome DevTools 定位和解决？
   - 用闭包实现一个 `LRU Cache`，要求时间复杂度 O(1)。

---

### **二、框架原理（React/Vue）**

1. **React**

   - Fiber 架构如何实现可中断渲染？对比 Stack Reconciler，解释其核心优化点。
   - 如何实现 React 的 `useMemo` 和 `useCallback`？它们的依赖项变化如何触发更新？
   - 为什么 React 18 的 `startTransition` 能提升用户体验？与 `Suspense` 结合使用的场景是什么？

2. **Vue**
   - Vue 3 的 `Proxy` 响应式系统如何解决 Vue 2 的 `Object.defineProperty` 的缺陷？
   - 如何实现 `v-model` 的自定义组件双向绑定？修饰符（如 `.trim`）的原理是什么？
   - Vue 的 `diff` 算法为何采用双端比较？与 React 的 `key` 机制有何异同？

---

### **三、性能优化**

1. **加载性能**

   - 如何通过 `Tree Shaking` 和 `Code Splitting` 减少首屏 JS 体积？Webpack 中如何配置？
   - 用 `Service Worker` 实现离线缓存时，如何设计缓存策略避免“缓存雪崩”？

2. **渲染性能**
   - 如何检测并解决 React 中的 `Render Props` 或 `HOC` 导致的重复渲染？
   - 用 `requestAnimationFrame` 优化高频事件（如滚动）的处理，如何避免掉帧？

---

### **四、安全与网络**

1. **安全防护**

   - 如何防御 DOM-based XSS？为什么 `innerHTML` 和 `eval` 是高危操作？
   - 如何设计一个 CSRF 防御方案？`SameSite Cookie` 和 `CSRF Token` 的优劣对比？

2. **HTTP 协议**
   - HTTP/2 的多路复用（Multiplexing）如何解决队头阻塞问题？HTTP/3 的 QUIC 协议有何改进？
   - 如何通过 `TCP` 和 `TLS` 握手优化首屏加载时间？`TLS 1.3` 的“0-RTT”特性如何工作？

---

### **五、工程化与开放问题**

1. **工程化**

   - 如何设计一个 Monorepo 架构的前端项目？对比 Lerna 和 Nx 的依赖管理机制。
   - 如何实现一个简单的 Babel 插件？请解析 AST 并修改代码逻辑。

2. **开放设计题**
   - 设计一个支持动态加载、权限控制和数据缓存的前端组件系统，你会如何架构？
   - 如果让你实现一个类似 `Redux` 的状态管理库，核心逻辑如何设计？如何保证状态一致性？

---

### **六、算法与逻辑**

- 实现一个 `JSON.stringify` 的 polyfill，要求处理循环引用和特殊值（如 `undefined`、`Symbol`）。
- 给定一个 DOM 节点树，如何高效统计所有文本节点的内容长度？（时间复杂度 O(n)）

---

### **解析关键点**

- **深度原理**：问题需结合底层实现（如 V8 引擎、浏览器渲染流程）。
- **场景结合**：避免纯理论题，注重实际应用（如性能监控、错误处理）。
- **开放性**：考察设计能力（如架构设计、权衡取舍）。

建议候选人回答时结合 **代码示例** 和 **实际项目经验**，体现技术深度与解决问题的系统性思维。

## 上述问题部分解答

### Generator实现 sleep函数

先读一遍

import HoverLinkContainer from "@components/react/UI/HoverLink.tsx";

<HoverLinkContainer
  client:only="react"
  url="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator"
  content="MDN-Generator"
  text="Generator"
  className="text-pink-200"
/>

```js
// sleep 函数返回 Promise（与 Promise 实现相同）
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 生成器函数示例
function* task() {
  console.log("Start");
  yield sleep(1000); // 在生成器中 yield sleep 的 Promise
  console.log("After 1 second");
}

// 执行器（运行生成器并处理异步）
function run(generator) {
  const g = generator();
  function next(err, result) {
    const { value, done } = g.next(result);
    if (done) return;
    value.then(next); // 等待 Promise 完成后再继续
  }
  next();
}

run(task);
```

### `class A extends B`

```js
// 父类 B
function B(name) {
  this.name = name;
  this.type = "Parent";
}

B.prototype.sayHello = function () {
  console.log("Hello from B");
};

// 静态方法
B.staticMethod = function () {
  console.log("Static method from B");
};

// 子类 A
function A(name, age) {
  // 相当于 super(name)
  B.call(this, name); // 调用父类构造函数
  this.age = age;
}

// 继承原型链
A.prototype = Object.create(B.prototype);
// 修复 constructor 指向
A.prototype.constructor = A;

// 覆盖/扩展原型方法
A.prototype.sayHello = function () {
  // 相当于 super.sayHello()
  B.prototype.sayHello.call(this); // 调用父类方法
  console.log("Hello from A");
};

// 继承静态方法
Object.keys(B).forEach(function (key) {
  A[key] = B[key];
});
```

### 为啥react底层没有使用requestIdelCallback

<details>
<summary>Click to expand</summary>

这是一个非常好的问题！React 作为一个高性能的 UI 库，确实需要关注主线程的调度与任务优先级。而 `requestIdleCallback`（简称 RIC） 是浏览器提供的一个 API，允许开发者在浏览器空闲时执行低优先级任务，这似乎非常适合 React 的异步调度需求。

但 **React 并没有直接使用 `requestIdleCallback`**，而是选择自己实现了一套时间片调度机制（Fiber 架构 + Scheduler 独立包），这是有原因的。下面我们详细分析一下：

---

## 🧠 为什么 `requestIdleCallback` 听起来很适合 React？

- 它可以让任务在浏览器空闲时运行，避免阻塞渲染或响应用户交互。
- 支持设置超时时间（timeout），确保任务不会无限延迟。
- 可以让 React 更好地控制任务的优先级和中断/恢复逻辑。

听起来确实非常契合 React 的 Concurrent Mode 的理念。

---

## ❌ 但是为什么 React 没用它？

### 1. **性能不可控 & 浏览器兼容性差**

- `requestIdleCallback` 的执行时机完全由浏览器决定，React 很难精确控制。
- 浏览器对“idle 时间”的定义不一致，导致调度行为不稳定。
- 兼容性不好：虽然现代浏览器支持了，但在一些旧版本浏览器中可能不可用。
- 目前只有 Chrome、Edge、Firefox 支持，Safari 支持也较新，移动端兼容性更差。

### 2. **粒度太粗，无法满足精细调度需求**

- `requestIdleCallback` 提供的时间片段通常只有几毫秒到几十毫秒，React 需要在这期间完成多个 Fiber 节点的处理。
- 如果 React 在每个 idle 回调中只做一点点工作，会导致整体更新变慢，影响用户体验。
- React 需要根据优先级动态调整任务的执行顺序，而 RIC 不提供优先级队列的功能。

### 3. **React 自己实现了更灵活的调度系统**

从 React 16 开始引入了 **Fiber 架构** 和 **Scheduler 独立包**，这个调度器是 React 团队专门为 React 设计的，具备以下优势：

#### ✅ Scheduler 包的优势：

- 基于 `MessageChannel` 实现微任务调度，比 `setTimeout` 更快更稳定。
- 支持优先级调度（如 user-blocking、normal、low 等）。
- 可以手动中断任务并稍后恢复（类似 requestIdleCallback 的功能，但可控性强得多）。
- 更好的跨平台兼容性（Web、React Native、SSR 等都可用）。

> 🔍 实际上，React 的 Scheduler 包模拟了 `requestIdleCallback` 的行为，但它是一个 polyfill + 扩展版本，更加灵活和可定制。

---

## 🧪 对比：RIC vs Scheduler

| 特性         | `requestIdleCallback`      | React Scheduler     |
| ------------ | -------------------------- | ------------------- |
| 控制权       | 浏览器控制                 | React 控制          |
| 优先级       | 不支持                     | 支持多种优先级      |
| 中断能力     | 支持（通过 timeRemaining） | 支持，并可挂起/恢复 |
| 跨平台兼容性 | 差                         | 强                  |
| 稳定性       | 不够稳定                   | 更稳定              |
| 调度灵活性   | 低                         | 高                  |

---

## 🚀 总结

React **没有使用 `requestIdleCallback` 的核心原因是**：

> “**浏览器提供的调度能力不够强大，不能满足 React 的复杂调度需求。**”

因此 React 团队选择自己实现了一个**更细粒度、更高性能、更强可控性的调度系统**，即现在的 Fiber + Scheduler 架构。

---

如果你感兴趣，可以看看 React Scheduler 的源码（[https://github.com/facebook/react/tree/main/packages/scheduler](https://github.com/facebook/react/tree/main/packages/scheduler)），里面有很多关于如何在浏览器中模拟“时间切片”和“优先级调度”的技巧。

---

如需进一步了解 React 调度机制的工作原理，我可以为你深入讲解 Fiber 架构、Lane 模型等高级内容 😎

</details>

## 涉及到的文章

- [事件循环](https://juejin.cn/post/7303739766105505832)
