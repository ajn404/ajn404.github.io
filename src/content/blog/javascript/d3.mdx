---
title: 玩转d3.js
pubDatetime: 2023-09-04T13:06:33Z
postSlug: d3
featured: true
draft: false
tags:
  - npm
  - d3
  - svg
  - canvas
description: "d3,数据可视化工具"
---

import Tree from "@components/react/d3/tree";
import Common from "@components/react/doodle/common.tsx";

<Tree float="true" client:load />

## 目录

## 简介

<fieldset class="max-w-full hidden">

<legend>什么是D3</legend>

    <blockquote cite="https://d3js.org/what-is-d3">

  <p> D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.</p>
  <footer><cite>https://d3js.org/what-is-d3</cite></footer>
</blockquote>

</fieldset>

## getting started

```shell
npm install d3
```

```html
<!doctype html>
<div id="container"></div>
<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3
    .scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3
    .scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg").attr("width", width).attr("height", height);

  // Add the x-axis.
  svg
    .append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

  // Add the y-axis.
  svg
    .append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

  // Append the SVG element.
  container.append(svg.node());
</script>
```

## demo

### tree component

```mdx
import Tree from "@components/react/d3/tree";

<Tree client:load />
```

### [Gear](https://observablehq.com/d/f4715544ebbb94fd)

import Gear from "@components/react/d3/gear";

<Gear client:load />

<details>
<summary>tsx component</summary>

```tsx
import * as d3 from "d3";
import { useEffect, useRef } from "react";

const Gear = () => {
  const ref = useRef<SVGSVGElement | null>(null);

  function gear({ teeth, radius, annulus, toothRadius, holeRadius }: any) {
    const n = teeth;
    let r2 = Math.abs(radius);
    let r0 = r2 - toothRadius;
    let r1 = r2 + toothRadius;
    let r3 = holeRadius;
    if (annulus) (r3 = r0), (r0 = r1), (r1 = r3), (r3 = r2 + toothRadius * 3);
    const da = Math.PI / n;
    let a0 = -Math.PI / 2 + (annulus ? Math.PI / n : 0);
    const path = ["M", r0 * Math.cos(a0), ",", r0 * Math.sin(a0)];
    let i = -1;
    while (++i < n) {
      path.push(
        "A",
        r0,
        ",",
        r0,
        " 0 0,1 ",
        r0 * Math.cos((a0 += da)),
        ",",
        r0 * Math.sin(a0),
        "L",
        r2 * Math.cos(a0),
        ",",
        r2 * Math.sin(a0),
        "L",
        r1 * Math.cos((a0 += da / 3)),
        ",",
        r1 * Math.sin(a0),
        "A",
        r1,
        ",",
        r1,
        " 0 0,1 ",
        r1 * Math.cos((a0 += da / 3)),
        ",",
        r1 * Math.sin(a0),
        "L",
        r2 * Math.cos((a0 += da / 3)),
        ",",
        r2 * Math.sin(a0),
        "L",
        r0 * Math.cos(a0),
        ",",
        r0 * Math.sin(a0)
      );
    }
    path.push(
      "M0,",
      -r3,
      "A",
      r3,
      ",",
      r3,
      " 0 0,0 0,",
      r3,
      "A",
      r3,
      ",",
      r3,
      " 0 0,0 0,",
      -r3,
      "Z"
    );
    return path.join("");
  }

  const graphic = () => {
    const x = Math.sin((2 * Math.PI) / 3);
    const y = Math.cos((2 * Math.PI) / 3);
    const svgElement = d3.select(ref.current);

    const svg = svgElement
      .attr("width", 640)
      .attr("viewBox", [-0.53, -0.53, 1.06, 1.06])
      .attr("stroke", "black")
      .attr("stroke-width", 1 / 640)
      .attr(
        "style",
        `width:${100}vw;max-width: 100%; height: calc( 100vh - 100px);`
      );

    const frame = svg.append("g");

    const path = frame
      .selectAll()
      .data([
        {
          fill: "#c6dbef",
          teeth: 80,
          radius: -0.5,
          origin: [0, 0],
          annulus: true,
        },
        { fill: "#6baed6", teeth: 16, radius: +0.1, origin: [0, 0] },
        { fill: "#9ecae1", teeth: 32, radius: -0.2, origin: [0, -0.3] },
        {
          fill: "#9ecae1",
          teeth: 32,
          radius: -0.2,
          origin: [-0.3 * x, -0.3 * y],
        },
        {
          fill: "#9ecae1",
          teeth: 32,
          radius: -0.2,
          origin: [0.3 * x, -0.3 * y],
        },
      ])
      .join("path")
      .attr("fill", d => d.fill)
      .attr("d", d => gear({ ...d, toothRadius: 0.008, holeRadius: 0.02 }));

    Object.assign(svg.node() as SVGSVGElement, {
      update({ angle, frameAngle }: { angle: number; frameAngle: number }) {
        path.attr(
          "transform",
          d => `translate(${d.origin}) rotate(${(angle / d.radius) % 360})`
        );
        frame.attr("transform", `rotate(${frameAngle % 360})`);
      },
    });
  };
  useEffect(() => {
    graphic();

    let id = 0;
    const animate = () => {
      const speed = 0.08;
      let angle = 0;
      let frameAngle = 0;

      let start = 0;
      const draw = function (timestamp: number) {
        if (start === 0) {
          start = timestamp;
        }
        (d3.select(ref.current).node() as any).update({ angle, frameAngle });
        angle += speed;
        frameAngle += speed / 360;
        id = requestAnimationFrame(draw);
      };
      id = requestAnimationFrame(draw);
    };
    animate();
    return () => {
      cancelAnimationFrame(id);
    };
  });

  return <svg ref={ref}></svg>;
};

export default Gear;
```

</details>

## Visualizations

### html + css

<div class="border-lightgrey relative w-full border-[1px] border-solid bg-skin-fill">
  <div class="h-3 w-[95%] bg-skin-accent" />
</div>

```html
<div
  class="border-lightgrey relative w-full border-[1px] border-solid bg-skin-fill"
>
  <div class="h-3 w-[95%] bg-skin-accent" />
</div>
```

### css-doodle

<Common client:load>
  @grid: 1 / 100% 100vmin / #0a0c27; background-size: 200px 200px;
  background-image: @doodle( @grid: 6 / 100%; @size: 4px; font-size: 4px; color:
  hsl(@r240, 30%, 50%); box-shadow: @m3x5( calc(4em - @nx * 1em) calc(@ny * 1em)
  @p(@m3(currentColor), @m2(transparent)), calc(2em + @nx * 1em) calc(@ny * 1em)
  @lp ); );
</Common>

```tsx
import Common from "@components/react/doodle/common.tsx";

<Common client:load>
  @grid: 1 / 100vmin 100vmin / #0a0c27; background-size: 200px 200px;
  background-image: @doodle( @grid: 6 / 100%; @size: 4px; font-size: 4px; color:
  hsl(@r240, 30%, 50%); box-shadow: @m3x5( calc(4em - @nx * 1em) calc(@ny * 1em)
  @p(@m3(currentColor), @m2(transparent)), calc(2em + @nx * 1em) calc(@ny * 1em)
  @lp ); );
</Common>;
```

<Common client:load>
  @grid: 1x1 / 100% 600px; gap: 2px; background: conic-gradient( at @r(30%, 70%)
  0, @stripe( transparent 25%, @m32.@p( #781217, #9A1320, #0A2667, #D8A088,
  #D6DDD1, #E95A22, #CA4122, #C74523, #2CACC9, #008C3B, #F5D700, #CA2821,
  #EADF93, #003A59, #00609A, #6E746E, #E2E0B8, #1E272B, #468495, #E1E0CA,
  #666F75, #84A16A, #413B4E, #98AEC7, #979DA4 ), transparent 25% ) );
</Common>

### webgl

- [webgl in regl](/posts/webgl)

### svg

- [svg basic](/posts/svg)

### d3 basic

#### d3.arc()

弧

import PracticeArc from "@components/react/d3/practice-arc.tsx";

<PracticeArc client:load />

<details>
  <summary>practice-arc</summary>

```tsx
import * as d3 from "d3";
import { useEffect, useRef } from "react";

export default () => {
  const ref = useRef<SVGSVGElement | null>(null);
  useEffect(() => {
    const svgElement = d3.select(ref.current);
    const g = svgElement
      .attr("width", "100")
      .attr("height", "100")
      .append("path");

    g.attr(
      "d",
      d3.arc()({
        innerRadius: 19,
        outerRadius: 40,
        startAngle: -Math.PI / 2,
        endAngle: Math.PI / 2,
      })
    )
      .attr("fill", "cornflowerblue")
      .attr("style", "transform: translate(50%, 50%)");
  });

  return <svg ref={ref}></svg>;
};
```

</details>

#### d3.axisBottom()

底部坐标轴

import PracticeAxisBottom from "@components/react/d3/practice-axis-bottom.tsx";

<PracticeAxisBottom client:load />

<details>
  <summary>practice-axis-bottom</summary>

```tsx
import * as d3 from "d3";
import { useEffect, useRef } from "react"

const Template = () => {
const ref = useRef<SVGSVGElement | null>(null);
useEffect(() => {
const xScale = d3.scaleLinear()
.domain([0, 100])
.range([10, 290])
const svgElement = d3.select(ref.current).attr("style", "width:100%;max-height:4em");
const axisGenerator = d3.axisBottom(xScale);
svgElement.append("g")
.call(axisGenerator)
return () => {
svgElement.remove();
}
})
return (

<svg ref={ref}></svg>) } export default Template;

```

</details>

### [Learn to Create D3.js Data Visualizations by Exampl](https://www.sitepoint.com/d3-js-data-visualizations/)

#### bar chart

import BarChart from "@components/react/d3/barChart.tsx";

<BarChart client:load />

```js
divElement
  .selectAll("div")
  .data([4, 8, 15, 16, 23, 42])
  .enter()
  .append("div")
  .style("height", d => `${d}px`);
```

#### contribution chart

import ContributionChart from "@components/react/d3/ContributionChart.tsx";

<ContributionChart client:load />

```jsx
const colorMap = d3.interpolateRgb(d3.rgb("#d6e685"), d3.rgb("#1e6823"));

divElement
  .selectAll("div")
  .data([0.2, 0.4, 0, 0, 0.13, 0.92])
  .enter()
  .append("div")
  .style("background-color", d => {
    return d == 0 ? "#eee" : colorMap(d);
  });
```

- [interpolateRgb](https://d3js.org/d3-interpolate/color#interpolateRgb)

> Interpolation is a key tool in graphics programming and animation

import Interpolation from "@components/react/d3/interpolateRgb.tsx";

<Interpolation client:load />

### 手写风

<div class="font-xkcd">手写风字体</div>

<div class="flex justify-around gap-8">
<div>

原图案

<svg style="width:100%" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
<defs>
<g id="noFilter">
<circle cx="256" cy="256" r="241" fill="white" stroke="black" stroke-width="8"></circle>
<path d="M88 236C88 252.974 93.6893 269.252 103.816 281.255C113.943 293.257 127.678 300 142 300C156.322 300 170.057 293.257 180.184 281.255C190.311 269.252 196 252.974 196 236H88ZM316 236C316 252.974 321.689 269.252 331.816 281.255C341.943 293.257 355.678 300 370 300C384.322 300 398.057 293.257 408.184 281.255C418.311 269.252 424 252.974 424 236H316Z" fill="black" stroke="black" stroke-width="8"></path>
<path d="M68 335H444M117 376H396M146 350V402M200 350V430M256 350V436M312 350V430M366 350V402M77 335C92.4263 371.701 117.541 402.875 149.307 424.75C181.074 446.626 218.131 458.268 256 458.268C293.869 458.268 330.926 446.626 362.693 424.75C394.459 402.875 419.574 371.701 435 335H77Z" stroke="black" stroke-width="8"></path>
</g>
</defs>
<g>
<use href="#noFilter" fill="none" stroke-width="3px"></use>
</g>
<g  fill="none" stroke-width="2px">
<use href="#noFilter"></use>
</g>
</svg>
</div>
<div>

手写风滤镜

<svg style="width:100%" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
<defs>
<filter id="noise3">
<feTurbulence baseFrequency="0.001"></feTurbulence>
<feDisplacementMap in="SourceGraphic" scale="10"></feDisplacementMap>
</filter>
<filter id="noise4">
<feTurbulence baseFrequency="0.01"></feTurbulence>
<feDisplacementMap in="SourceGraphic" scale="13"></feDisplacementMap>
</filter>
<g id="chooblarin">
<circle cx="256" cy="256" r="241" fill="white" stroke="black" stroke-width="8"></circle>
<path d="M88 236C88 252.974 93.6893 269.252 103.816 281.255C113.943 293.257 127.678 300 142 300C156.322 300 170.057 293.257 180.184 281.255C190.311 269.252 196 252.974 196 236H88ZM316 236C316 252.974 321.689 269.252 331.816 281.255C341.943 293.257 355.678 300 370 300C384.322 300 398.057 293.257 408.184 281.255C418.311 269.252 424 252.974 424 236H316Z" fill="black" stroke="black" stroke-width="8"></path>
<path d="M68 335H444M117 376H396M146 350V402M200 350V430M256 350V436M312 350V430M366 350V402M77 335C92.4263 371.701 117.541 402.875 149.307 424.75C181.074 446.626 218.131 458.268 256 458.268C293.869 458.268 330.926 446.626 362.693 424.75C394.459 402.875 419.574 371.701 435 335H77Z" stroke="black" stroke-width="8"></path>
</g>
</defs>
<g filter="url(#noise3)">
<use href="#chooblarin" fill="none" stroke-width="3px"></use>
</g>
<g filter="url(#noise4)" fill="none" stroke-width="2px">
<use href="#chooblarin"></use>
</g>
</svg>
</div>
</div>

#### [use roughjs](https://roughjs.com/)

```shell
pnpm i roughjs
```

import Rough from "@components/react/little/rough.tsx";

<Rough client:load />

<details>
<summary>代码</summary>

```tsx
import { useEffect, useRef } from "react";
import rough from "roughjs";
export default () => {
  const svg = useRef<SVGSVGElement>(null);
  useEffect(() => {
    const rc = rough.svg(svg.current);
    svg.current.appendChild(rc.line(60, 60, 190, 60));
    svg.current.appendChild(rc.rectangle(10, 10, 100, 100));
    svg.current.appendChild(
      rc.rectangle(140, 10, 100, 100, {
        fill: "rgba(255,0,0,0.2)",
        fillStyle: "solid",
        roughness: 2,
      })
    );
  });
  return (
    <>
      <div className="bg-[#fff]">
        <svg ref={svg} className=""></svg>
      </div>
    </>
  );
};
```

</details>

#### rough annotation

import RoughAnnotation from "@components/react/little/roughAnnotation.tsx";

<RoughAnnotation client:visible />

### [d3-graphviz](https://github.com/magjac/d3-graphviz?tab=readme-ov-file#examples)

import Graphviz from "@components/react/d3/graphviz/basic.tsx";

<Graphviz client:load></Graphviz>

## roadmap

<details>
<summary>d3怎么学</summary>

<blockquote>

D3.js（Data-Driven Documents）是一个功能强大且灵活的数据可视化库,但其灵活性也意味着需要掌握一定的底层知识才能充分利用它的优势.以下是使用D3.js时需要掌握的关键底层知识：

### 1. JavaScript

- **基础语法**：了解JavaScript的基本语法和概念,如变量、数据类型、函数、作用域等.
- **DOM操作**：掌握原生JavaScript的DOM操作,D3.js主要通过操作DOM来创建和更新图表.
- **事件处理**：理解JavaScript的事件机制,熟悉常见的事件如点击、鼠标悬停等,以及如何使用事件监听器.

### 2. HTML

- **基础结构**：理解HTML文档的基本结构,标签的使用,特别是常用的元素如`div`、`svg`、`canvas`等.
- **SVG**：深入了解SVG（可缩放矢量图形）,包括基本元素如`<circle>`、`<rect>`、`<line>`、`<path>`等,以及如何使用属性和样式来控制它们.

### 3. CSS

- **选择器**：掌握CSS选择器的用法,D3.js常用选择器来选择和操作DOM元素.
- **样式应用**：理解如何通过CSS控制元素的样式,包括颜色、字体、边框等.
- **布局**：了解基本的布局模型,如盒模型、Flexbox等,方便对图表的整体布局进行控制.

### 4. SVG（可缩放矢量图形）

- **基本图形**：理解SVG基本形状（如`<rect>`、`<circle>`、`<line>`、`<path>`等）及其属性.
- **路径数据**：掌握路径的绘制方法,特别是路径命令（如`M`、`L`、`C`等）.
- **坐标系**：理解SVG的坐标系和视口（viewport）,以及如何使用`viewBox`来控制图形的缩放和平移.

### 5. 数学和几何

- **坐标系**：熟悉笛卡尔坐标系和极坐标系,了解如何在这些坐标系中绘制图形.
- **几何变换**：掌握平移、旋转、缩放等几何变换及其矩阵表示法.
- **比例尺**：理解线性比例、对数比例、时间比例等概念,以及如何在数据映射中使用它们.

### 6. 数据处理

- **数组和对象操作**：熟悉JavaScript中的数组和对象操作,特别是数组的方法如`map`、`filter`、`reduce`等.
- **数据格式**：了解常见的数据格式如JSON、CSV等,以及如何解析和处理这些数据.
- **数据绑定**：掌握D3.js中的数据绑定概念,理解如何将数据绑定到DOM元素,并根据数据更新元素.

### 7. D3.js核心概念

- **选择器和选择**：理解D3.js的选择器和选择机制,特别是`d3.select`和`d3.selectAll`.
- **数据绑定**：掌握`data`、`enter`、`update`和`exit`选择集的概念及其用法.
- **过渡和动画**：了解D3.js中如何创建平滑的过渡和动画效果.
- **比例尺和坐标轴**：熟悉D3.js中的比例尺（`scale`）和坐标轴（`axis`）模块,知道如何使用它们来创建图表的比例尺和坐标轴.
- **布局**：掌握D3.js中的布局模块,如树形布局（`d3.tree`）、力导向图（`d3.forceSimulation`）等.

### 8. 高级技巧

- **模块化开发**：理解如何使用D3.js进行模块化开发,方便维护和扩展代码.
- **性能优化**：了解如何优化D3.js图表的性能,特别是在处理大规模数据时.
- **可视化设计**：掌握一些基本的可视化设计原则,确保图表不仅功能强大,还具有良好的可读性和美观性.

通过掌握上述底层知识,能够更好地理解和使用D3.js,创建功能强大且灵活的可视化图表.虽然学习曲线较为陡峭,但D3.js的强大功能和灵活性使其成为复杂和自定义数据可视化的理想选择.

</blockquote>

</details>

## continue practice

- [Disjoint force-directed graph](https://observablehq.com/@d3/disjoint-force-directed-graph/2?intent=fork)

import Force from "@components/react/d3/practice/force";

<Force client:load />

<details>
<summary>代码片段</summary>

```js
chart = {
  // Specify the dimensions of the chart.
  const width = 928;
  const height = 680;

  // Specify the color scale.
  const color = d3.scaleOrdinal(d3.schemeCategory10);

  // The force simulation mutates links and nodes, so create a copy
  // so that re-evaluating this cell produces the same result.
  const links = data.links.map(d => ({...d}));
  const nodes = data.nodes.map(d => ({...d}));

  // Create a simulation with several forces.
  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id))
      .force("charge", d3.forceManyBody())
      .force("x", d3.forceX())
      .force("y", d3.forceY());

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "max-width: 100%; height: auto;");

  // Add a line for each link, and a circle for each node.
  const link = svg.append("g")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6)
    .selectAll("line")
    .data(links)
    .join("line")
      .attr("stroke-width", d => Math.sqrt(d.value));

  const node = svg.append("g")
      .attr("stroke", "#fff")
      .attr("stroke-width", 1.5)
    .selectAll("circle")
    .data(nodes)
    .join("circle")
      .attr("r", 5)
      .attr("fill", d => color(d.group));

  node.append("title")
      .text(d => d.id);

  // Add a drag behavior.
  node.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

  // Set the position attributes of links and nodes each time the simulation ticks.
  simulation.on("tick", () => {
    link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
  });

  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  // When this cell is re-run, stop the previous simulation. (This doesn’t
  // really matter since the target alpha is zero and the simulation will
  // stop naturally, but it’s a good practice.)
  invalidation.then(() => simulation.stop());

  return svg.node();
}
```

</details>

<details>
<summary>详细解释</summary>
这个代码片段是一个使用D3.js创建力导向图（force-directed graph）的示例.这个图表通常用于显示节点和它们之间的关系（连接）.以下是对每个部分的详细解释：

```javascript
chart = {
  // Specify the dimensions of the chart.
  const width = 928;
  const height = 680;
```

首先,定义了图表的宽度和高度.

```javascript
// Specify the color scale.
const color = d3.scaleOrdinal(d3.schemeCategory10);
```

定义了一个颜色比例尺,用于根据节点的不同组别（group）着色.

```javascript
// The force simulation mutates links and nodes, so create a copy
// so that re-evaluating this cell produces the same result.
const links = data.links.map(d => ({ ...d }));
const nodes = data.nodes.map(d => ({ ...d }));
```

复制数据中的链接和节点,防止直接修改原始数据.

```javascript
// Create a simulation with several forces.
const simulation = d3
  .forceSimulation(nodes)
  .force(
    "link",
    d3.forceLink(links).id(d => d.id)
  )
  .force("charge", d3.forceManyBody())
  .force("x", d3.forceX())
  .force("y", d3.forceY());
```

创建一个力模拟（force simulation）,包括以下几种力：

- **link**: 用于保持连接节点的距离.
- **charge**: 模拟节点间的电荷力,使它们彼此排斥.
- **x** 和 **y**: 用于将节点拉向中心,防止它们散开.

```javascript
// Create the SVG container.
const svg = d3
  .create("svg")
  .attr("width", width)
  .attr("height", height)
  .attr("viewBox", [-width / 2, -height / 2, width, height])
  .attr("style", "max-width: 100%; height: auto;");
```

创建一个SVG容器,并设置它的尺寸和视图框.

```javascript
// Add a line for each link, and a circle for each node.
const link = svg
  .append("g")
  .attr("stroke", "#999")
  .attr("stroke-opacity", 0.6)
  .selectAll("line")
  .data(links)
  .join("line")
  .attr("stroke-width", d => Math.sqrt(d.value));
```

添加表示每个链接的线条,并根据链接的值设置线条的宽度.

```javascript
const node = svg
  .append("g")
  .attr("stroke", "#fff")
  .attr("stroke-width", 1.5)
  .selectAll("circle")
  .data(nodes)
  .join("circle")
  .attr("r", 5)
  .attr("fill", d => color(d.group));
```

添加表示每个节点的圆圈,并根据节点的组别设置颜色.

```javascript
node.append("title").text(d => d.id);
```

为每个节点添加标题,在悬停时显示节点的ID.

```javascript
// Add a drag behavior.
node.call(
  d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended)
);
```

为每个节点添加拖动行为,允许用户拖动节点.

```javascript
// Set the position attributes of links and nodes each time the simulation ticks.
simulation.on("tick", () => {
  link
    .attr("x1", d => d.source.x)
    .attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x)
    .attr("y2", d => d.target.y);

  node.attr("cx", d => d.x).attr("cy", d => d.y);
});
```

每次模拟“tick”时更新链接和节点的位置.

```javascript
// Reheat the simulation when drag starts, and fix the subject position.
function dragstarted(event) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  event.subject.fx = event.subject.x;
  event.subject.fy = event.subject.y;
}

// Update the subject (dragged node) position during drag.
function dragged(event) {
  event.subject.fx = event.x;
  event.subject.fy = event.y;
}

// Restore the target alpha so the simulation cools after dragging ends.
// Unfix the subject position now that it’s no longer being dragged.
function dragended(event) {
  if (!event.active) simulation.alphaTarget(0);
  event.subject.fx = null;
  event.subject.fy = null;
}
```

定义拖动行为的函数：

- **dragstarted**: 当拖动开始时,加热模拟并固定节点位置.
- **dragged**: 在拖动过程中更新节点位置.
- **dragended**: 当拖动结束时,冷却模拟并释放节点位置.

```javascript
  // When this cell is re-run, stop the previous simulation. (This doesn’t
  // really matter since the target alpha is zero and the simulation will
  // stop naturally, but it’s a good practice.)
  invalidation.then(() => simulation.stop());

  return svg.node();
}
```

当重新运行此单元格时,停止之前的模拟.这通常不会影响结果,但是一种良好的实践.

最后,返回SVG节点,该节点包含生成的力导向图.

### 总结

这个代码片段展示了如何使用D3.js创建一个力导向图,包括定义图表尺寸、颜色比例尺、力模拟、SVG容器、链接和节点的可视化、拖动行为以及更新位置的机制.这种图表对于展示节点之间的关系非常有用,常用于网络图、社交关系图等.

</details>

- [Drag (SVG Voronoi)](https://observablehq.com/@d3/circle-dragging-iii)

import Voronoi from "@components/react/d3/practice/Voronoi";

<Voronoi client:load />

## combine d3 with others

- [delatin](https://github.com/mapbox/delatin)

一个快速的 JavaScript 3D 地形网格生成工具.使用 Delaunay 三角剖分近似高度场,在给定的最大误差下最小化点和三角形的数量.

- [ZDog](https://zzz.dog/)

Round, flat, designer-friendly
pseudo-3D engine for canvas & SVG

ZDog 是一个用于 Canvas 和 SVG 的伪 3D 引擎,它提供了一个简单而强大的 API,用于创建圆角、阴影和透视效果的 2D 和 3D 形状.

import Zdog from "@components/react/d3/fantastic/zdog";

<Zdog client:load />

## 这两天用d3手写了一个很实用的组件

<details>
<summary>Click to expand</summary>

import ComponentName from "@components/vue/d3/index.vue";

<ComponentName client:visible />

之后做了很大的优化，但放在这个博客里不太合适，就不搬了

简单看看代码吧

```vue
<template>
  <div class="container">
    <div class="toolbar" v-if="!props.readonly" style="width: 50%;">
      <button
        @click="undo"
        :disabled="!canUndo"
        title="快捷键: Ctrl/Command + Z"
      >
        撤销
      </button>
      <button
        @click="redo"
        :disabled="!canRedo"
        title="快捷键: Ctrl/Command + Shift + Z"
      >
        重做
      </button>
      <button @click="clearShapes">清空图形</button>
      <button @click="downloadImage">下载图形</button>
      <div style="margin-top: 10px;">
        <button @click="alignShapes('left')" :disabled="!canAlign">
          左对齐
        </button>
        <button @click="alignShapes('center')" :disabled="!canAlign">
          居中对齐
        </button>
        <button @click="alignShapes('right')" :disabled="!canAlign">
          右对齐
        </button>
        <button @click="alignShapes('top')" :disabled="!canAlign">
          顶部对齐
        </button>
        <button @click="alignShapes('middle')" :disabled="!canAlign">
          垂直居中
        </button>
        <button @click="alignShapes('bottom')" :disabled="!canAlign">
          底部对齐
        </button>
      </div>
      <div class="submit">
        <label>公司名称:</label>
        <InputSelectTree
          @reset="resetCompany"
          style="width: 250px;"
          @select="companySelect"
          v-model:value="company"
          placeholder="请选择/输入公司名称"
          editable
          config-info="JE_RBAC_COMPANYTREE,,,S"
        >
        </InputSelectTree>
        <template v-if="drawingMode === 'unit' && currentAreaName">
          <label class="grid-column-1">所属区域: {{ currentAreaName }}</label>
        </template>
        <label>{{ drawingMode === "area" ? "区域名称:" : "单元名称:" }}</label>
        <Input
          required
          v-model:value="polygonName"
          @change="drawChart"
          :placeholder="`输入${drawingMode === 'area' ? '区域' : '单元'}名称`"
        />
        <label>{{ drawingMode === "area" ? "区域颜色:" : "单元颜色:" }}</label>
        <div class="color-picker">
          <div
            class="color-option"
            v-for="(color, index) in colors"
            :key="index"
            :style="{ backgroundColor: color.value }"
            :class="{ active: selectedColor === color.value }"
            @click="selectColor(color.value)"
            :title="color.label"
          ></div>
        </div>
        <button @click="saveShapes" type="submit">
          保存{{ drawingMode === "area" ? "区域" : "单元" }}
        </button>
      </div>

      <div class="shortcuts-tips">
        <p>提示：</p>
        <ul>
          <li>撤销：Ctrl/Command + Z</li>
          <li>重做：Ctrl/Command + Shift + Z</li>
          <li>删除多边形：点击已保存的多边形后使用Backspace/Delete</li>
          <li>
            选择多边形：点击已保存的多边形进行单选 按住Ctrl/Command 进行多选
          </li>
          <li>右键区域进入单元绘制</li>
        </ul>
      </div>
      <button @click="exportData" style="margin-top: 10px;">导出数据</button>

      <div class="mode-indicator">
        <span
          >当前模式:
          {{ drawingMode === "area" ? "区域绘制" : "单元绘制" }}</span
        >
        <button v-if="drawingMode === 'unit'" @click="backToAreaMode">
          返回区域绘制
        </button>
      </div>
    </div>

    <div class="view-div" v-if="readonly">
      <InputSelectTree
        @reset="resetCompany"
        style="width: 250px;"
        @select="companySelect"
        v-model:value="company"
        placeholder="请选择/输入公司名称"
        editable
        @change="drawChart"
        config-info="JE_RBAC_COMPANYTREE,,,S"
      >
      </InputSelectTree>
      <button @click="downloadImage">下载图形</button>

      <div class="mode-indicator" v-if="drawingMode === 'unit'">
        <span>当前模式: 单元查看</span>
        <button @click="backToAreaMode">返回区域查看</button>
      </div>
    </div>

    <div
      @contextmenu.prevent
      ref="chartContainer"
      class="chart-container"
    ></div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed, onUnmounted, watch } from "vue";
import { Input } from "ant-design-vue";
import { InputSelect } from "@jecloud/ui";
import * as d3 from "d3";
import MockShape from "./mockShapes.json";
const InputSelectTree = InputSelect.Tree;
const chartContainer = ref(null);
const points = ref([]); // Stores the vertices of the polygon
const polygonName = ref(""); // Stores the name of the polygon
let drawing = false;

// Undo and redo stacks
const undoStack = ref([]);
const redoStack = ref([]);
const company = ref(null);

// 添加绘制状态管理
const drawingMode = ref("area"); // 'area' 或 'unit'
const currentAreaId = ref(null); // 当前选中的区域ID

// 修改数据结构
const savedPolygons = ref({
  areas: [],
  units: [],
});

// 添加颜色选项
const colors = [
  { label: "低风险", value: "#1E90FF" }, // 蓝色
  { label: "一般风险", value: "#FFD700" }, // 黄色
  { label: "较大风险", value: "#FFA500" }, // 橘色
  { label: "重大风险", value: "#FF4500" }, // 红色
  { label: "停工停产", value: "#808080" }, // 灰色
];

// 当前选中的颜色
const selectedColor = ref(colors[0].value);

// 添加图例显示状态控制
const legendStatus = ref(
  colors.map(color => ({
    ...color,
    visible: true,
  }))
);

// 添加 props 定义
const props = defineProps({
  readonly: {
    type: Boolean,
    default: false,
  },
});

// 添加选中状态追踪
const selectedPolygons = ref(new Set());

// 添加是否可以对齐的计算属性
const canAlign = computed(() => selectedPolygons.value.size > 1);

const gridSpacing = 20; // 网格间距
// 将坐标磁吸到最近的网格线
const snapToGrid = value => {
  return Math.round(value / gridSpacing) * gridSpacing;
};

// // 将坐标磁吸到最近的网格线
// const snapToGrid = (value) => {
//   const snappedValue = Math.round(value / gridSpacing) * gridSpacing;
//   // 使用插值实现平滑过渡
//   return value + (snappedValue - value) * 0.1; // 0.1 是平滑因子，可以根据需要调整
// };

const selectColor = val => {
  selectedColor.value = val;
  drawChart();
};

// 添加选择多边形的功能
const togglePolygonSelection = (index, event, type) => {
  if (props.readonly) return;

  // 阻止事件冒泡，防止触发画布的点击事件
  event.stopPropagation();

  // 生成唯一的选择标识符
  const selectionId = `${type}-${index}`;

  // 确保在单元模式下只能选择单元，在区域模式下只能选择区域
  const isCorrectMode =
    (drawingMode.value === "area" && type === "area") ||
    (drawingMode.value === "unit" && type === "unit");

  if (!isCorrectMode) return;

  // 如果按住Ctrl/Command键，则切换选择状态
  if (event.ctrlKey || event.metaKey) {
    if (selectedPolygons.value.has(selectionId)) {
      selectedPolygons.value.delete(selectionId);
    } else {
      selectedPolygons.value.add(selectionId);
    }
  } else {
    // 如果没有按住Ctrl/Command键，则清除其他选择并选中当前多边形
    selectedPolygons.value.clear();
    selectedPolygons.value.add(selectionId);
  }

  drawChart();
};

const companySelect = val => {
  const { rows } = val;
  company.value = rows[0].text;
};

const resetCompany = () => {
  company.value = null;
};

watch(
  () => company.value,
  () => {
    drawChart();
  }
);

const drawChart = () => {
  const width = window.innerWidth / 2 + 200;
  const height = window.innerHeight - 100;

  // Clear container
  d3.select(chartContainer.value).selectAll("*").remove();

  // Create SVG element
  const svg = d3
    .select(chartContainer.value)
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid #ccc");

  if (!props.readonly && selectedPolygons.value.size === 0) {
    svg.on("click", function (event) {
      // 检查事件源，如果点击的是多边形，则不添加新点
      if (event.target.tagName === "polygon") {
        return;
      }

      if (!drawing) {
        drawing = true;
      }
      undoStack.value.push([...points.value]);
      redoStack.value = [];
      const coords = d3.pointer(event);
      points.value.push([snapToGrid(coords[0]), snapToGrid(coords[1])]);
      updatePolygon(svg);
    });
  }

  updatePolygon(svg); // Initial call to draw empty or existing shapes
};

// Function to draw or update the polygon
const updatePolygon = svg => {
  // Clear previous polygon and circles
  svg.selectAll("*").remove();

  // 获取SVG的高度和宽度
  const height = svg.node().getBoundingClientRect().height;
  const width = svg.node().getBoundingClientRect().width;

  // 根据绘制模式显示不同的内容
  if (drawingMode.value === "area") {
    // 绘制所有区域
    savedPolygons.value.areas.forEach((polygon, index) => {
      if (!company.value || polygon.company !== company.value) return;
      drawPolygon(svg, polygon, index, "area");
    });
  } else if (drawingMode.value === "unit") {
    // 在单元模式下，只显示当前选中的区域和其下的单元
    const currentArea = savedPolygons.value.areas.find(
      area => area.id === currentAreaId.value
    );
    if (currentArea) {
      // 以半透明方式显示当前区域
      // drawPolygon(svg, currentArea, -1, 'area', true);

      // 显示该域下的所有单元
      savedPolygons.value.units
        .filter(unit => unit.areaId === currentAreaId.value)
        .forEach((unit, index) => {
          drawPolygon(svg, unit, index, "unit");
        });
    }
  }

  // 绘制当前正在绘制的多边形
  if (points.value.length > 0) {
    const currentLegendItem = legendStatus.value.find(
      item => item.value === selectedColor.value
    );
    if (currentLegendItem?.visible) {
      svg
        .append("polygon")
        .attr("points", points.value.map(d => d.join(",")).join(" "))
        .style("fill", selectedColor.value)
        .attr("stroke", "black")
        .attr("stroke-width", 2);

      // Draw circles for each vertex and make them draggable
      svg
        .selectAll("circle")
        .data(points.value)
        .enter()
        .append("circle")
        .attr("cx", d => d[0])
        .attr("cy", d => d[1])
        .attr("r", 6)
        .attr("fill", "yellow")
        .attr("stroke", "black")
        .attr("stroke-width", 1)
        .call(
          d3
            .drag()
            .on("start", dragStarted)
            .on("drag", dragged)
            .on("end", dragEnded)
        );

      // Add the polygon name
      if (polygonName.value) {
        // Calculate the center of the polygon for placing the text
        const center = calculatePolygonCenter(points.value);
        svg
          .append("text")
          .attr("x", center[0])
          .attr("y", center[1])
          .attr("text-anchor", "middle")
          .attr("fill", "black")
          .attr("font-size", "14px")
          .text(polygonName.value);
      }
    }
  }

  // 添加图例（使用获取到的height）
  const legendGroup = svg
    .append("g")
    .attr("class", "legend")
    .attr("transform", `translate(20, ${height - 150})`); // 左下角置

  legendStatus.value.forEach((item, index) => {
    const legendItem = legendGroup
      .append("g")
      .attr("transform", `translate(0, ${index * 25})`)
      .style("cursor", "pointer")
      .on("click", event => {
        // 阻止事件冒泡
        event.stopPropagation();
        // 切换显示状态
        item.visible = !item.visible;
        // 重新绘制
        drawChart();
      });

    // 图例颜色框
    legendItem
      .append("rect")
      .attr("width", 18)
      .attr("height", 18)
      .attr("fill", item.value)
      .style("opacity", item.visible ? 1 : 0.5);

    // 图例文字
    legendItem
      .append("text")
      .attr("x", 24)
      .attr("y", 14)
      .text(item.label)
      .style("font-size", "14px")
      .style("z-index", "1")
      .style("opacity", item.visible ? 1 : 0.5);
  });

  if (!props.readonly) {
    // 只在非只读模式下添加拖拽功能
    svg
      .selectAll("circle")
      .data(points.value)
      .enter()
      .append("circle")
      .attr("cx", d => d[0])
      .attr("cy", d => d[1])
      .attr("r", 10)
      .attr("fill", "yellow")
      .attr("stroke", "black")
      .attr("stroke-width", 1)
      .call(
        d3
          .drag()
          .on("start", dragStarted)
          .on("drag", dragged)
          .on("end", dragEnded)
      );
    // 添加网格线

    for (let x = 0; x < width; x += gridSpacing) {
      svg
        .append("line")
        .attr("x1", x)
        .attr("y1", 0)
        .attr("x2", x)
        .attr("y2", height)
        .style("stroke", "#ccc")
        .style("stroke-width", 0.5);
    }
    for (let y = 0; y < height; y += gridSpacing) {
      svg
        .append("line")
        .attr("x1", 0)
        .attr("y1", y)
        .attr("x2", width)
        .attr("y2", y)
        .style("stroke", "#ccc")
        .style("stroke-width", 0.5);
    }
  }
};

// Drag event handlers
const dragStarted = (event, d) => {
  // 只需要高亮显示被拖动的点
  d3.select(event.sourceEvent.target).raise().classed("active", true);
};

const dragged = (event, d) => {
  // 直接使用事件中的坐标
  const [x, y] = d3.pointer(event, chartContainer.value);
  d[0] = snapToGrid(x);
  d[1] = snapToGrid(y);

  drawChart();
};

const dragEnded = (event, d) => {
  d3.select(event.sourceEvent.target).classed("active", false);

  // 保存当前状态到撤销栈
  undoStack.value.push([...points.value]);
  redoStack.value = [];
};

// Function to calculate the center of the polygon
const calculatePolygonCenter = points => {
  const x = points.map(point => point[0]);
  const y = points.map(point => point[1]);
  const centerX = x.reduce((sum, val) => sum + val, 0) / points.length;
  const centerY = y.reduce((sum, val) => sum + val, 0) / points.length;
  return [centerX, centerY];
};

// Undo function
const undo = () => {
  if (undoStack.value.length > 0) {
    const lastAction = undoStack.value.pop();

    if (lastAction.type === "clear") {
      // 如果是清空操作，保存当前状态到重做栈
      redoStack.value.push({
        type: "clear",
        data: JSON.parse(JSON.stringify(savedPolygons.value)),
      });
      // 恢复之前的状态
      savedPolygons.value = lastAction.data;
    } else {
      // 处理普通的点操作
      redoStack.value.push([...points.value]);
      points.value = lastAction;
    }

    drawChart();
  }
};

// Redo function
const redo = () => {
  if (redoStack.value.length > 0) {
    const nextAction = redoStack.value.pop();

    if (nextAction.type === "clear") {
      // 如果是清空操作，保存当前状态到撤销栈
      undoStack.value.push({
        type: "clear",
        data: JSON.parse(JSON.stringify(savedPolygons.value)),
      });
      // 恢复清空后的状态
      savedPolygons.value = nextAction.data;
    } else {
      // 处理普通的点操作
      undoStack.value.push([...points.value]);
      points.value = nextAction;
    }

    drawChart();
  }
};

// Save shapes to local storage
const saveShapes = () => {
  if (points.value.length < 3) {
    JE.message("请至少绘制三个点！");
    return;
  }

  if (!polygonName.value) {
    JE.message("请输入多形名称！");
    return;
  }

  if (!company.value) {
    JE.message("请选择公司！");
    return;
  }

  const shapeData = {
    id: Date.now(), // 生成唯一ID
    company: company.value,
    points: [...points.value],
    name: polygonName.value,
    color: selectedColor.value,
  };

  if (drawingMode.value === "area") {
    savedPolygons.value.areas.push(shapeData);
  } else {
    savedPolygons.value.units.push({
      ...shapeData,
      areaId: currentAreaId.value,
    });
  }

  // 保存到 localStorage
  localStorage.setItem("savedShapes", JSON.stringify(savedPolygons.value));

  // 清空当前绘制的多边形，准备绘制新的
  points.value = [];
  polygonName.value = "";
  undoStack.value = [];
  redoStack.value = [];
  drawing = false;
  // 清空选择状态
  selectedPolygons.value.clear();

  // 重新绘制
  drawChart();

  JE.message("图形已保存!");
};

// Clear all shapes and reset
const clearShapes = () => {
  // 保存当前状态用于撤销
  const previousState = JSON.parse(JSON.stringify(savedPolygons.value));
  undoStack.value.push({
    type: "clear",
    data: previousState,
  });
  redoStack.value = [];

  // 清空当前绘制状态
  points.value = [];
  polygonName.value = "";
  drawing = false;
  selectedPolygons.value.clear();

  if (drawingMode.value === "area") {
    // 区域模式：清空当前公司的所有区域
    savedPolygons.value = {
      areas: savedPolygons.value.areas.filter(
        item => item.company !== company.value
      ),
      units: savedPolygons.value.units.filter(
        item => item.company !== company.value
      ),
    };
  } else {
    // 单元模式：只清空当前区域下的单元
    savedPolygons.value = {
      areas: savedPolygons.value.areas, // 保持区域不变
      units: savedPolygons.value.units.filter(
        item =>
          item.areaId !== currentAreaId.value || item.company !== company.value
      ),
    };
  }

  localStorage.setItem("savedShapes", JSON.stringify(savedPolygons.value));
  drawChart();
};

// Set shape type (for extensibility)
const setShape = shape => {
  if (shape === "polygon") {
    clearShapes(); // Clear the current drawing and set up for a new polygon
  }
};

// Computed properties to check if undo/redo actions are possible
const canUndo = computed(() => undoStack.value.length > 0);
const canRedo = computed(() => redoStack.value.length > 0);

// 添加下载图形功能
const downloadImage = () => {
  // 获取SVG元素
  const svg = d3.select(chartContainer.value).select("svg").node();

  // 创建一个临时的Canvas
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  // 设置Canvas尺寸与SVG相同
  canvas.width = svg.width.baseVal.value;
  canvas.height = svg.height.baseVal.value;

  // 将SVG转换为图片数据
  const svgData = new XMLSerializer().serializeToString(svg);
  const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(svgBlob);

  // 创建图片对象
  const img = new Image();
  img.onload = () => {
    // 在Canvas上绘制图片
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);

    // 将Canvas转换为图片并下载
    const imgURL = canvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.download = `${polygonName.value || "polygon"}.png`;
    link.href = imgURL;
    link.click();

    // 清理资源
    URL.revokeObjectURL(url);
  };
  img.src = url;
};

// 添加键盘事件处理函数
const handleKeyboard = event => {
  if (props.readonly) return; // 只读模式下不处键盘事件

  // 撤销：Ctrl+Z 或 Command+Z
  if (
    (event.ctrlKey || event.metaKey) &&
    !event.shiftKey &&
    event.key === "z"
  ) {
    event.preventDefault();
    undo();
  }
  // 重做：Ctrl+Shift+Z 或 Command+Shift+Z
  else if (
    (event.ctrlKey || event.metaKey) &&
    event.shiftKey &&
    event.key === "z"
  ) {
    event.preventDefault();
    redo();
  }
  // 删除：Backspace 或 Delete
  else if (
    (event.key === "Backspace" || event.key === "Delete") &&
    canDelete.value
  ) {
    event.preventDefault();
    deleteSelected();
  }
};

// Lifecycle hook to initialize the drawing area
onMounted(() => {
  const savedData = localStorage.getItem("savedShapes");
  if (savedData) {
    try {
      const parsedData = JSON.parse(savedData);
      // 处理旧数据格式到新格式的迁移
      if (Array.isArray(parsedData)) {
        // 如果是旧格式（数组），则全部作为区域数据
        savedPolygons.value = {
          areas: parsedData,
          units: [],
        };
      } else {
        // 如果已经是新格式（包含 areas 和 units），直接使用
        savedPolygons.value = parsedData;
      }
    } catch (e) {
      console.error("Error parsing saved shapes:", e);
      savedPolygons.value = {
        areas: [],
        units: [],
      };
    }
  } else {
    // 如果没有保存的数据，使用 MockShape
    try {
      const mockData = Array.isArray(MockShape)
        ? { areas: MockShape, units: [] }
        : MockShape;
      savedPolygons.value = mockData;
    } catch (e) {
      console.error("Error loading mock shapes:", e);
      savedPolygons.value = {
        areas: [],
        units: [],
      };
    }
  }

  drawChart();

  // 添加键盘事件监听
  window.addEventListener("keydown", handleKeyboard);
});

// 添加 onUnmounted 清理事件监听
onUnmounted(() => {
  window.removeEventListener("keydown", handleKeyboard);
});

// 修改拖动相关的函数
const dragPolygonStarted = (event, index, type) => {
  // 根据类型获取正确的数组
  const polygonArray =
    type === "area" ? savedPolygons.value.areas : savedPolygons.value.units;
  const polygon = polygonArray[index];

  if (!polygon) return;

  polygon.startPoints = JSON.parse(JSON.stringify(polygon.points));
  polygon.startMousePos = d3.pointer(event, chartContainer.value);
};

const dragPolygon = (event, index, type) => {
  const polygonArray =
    type === "area" ? savedPolygons.value.areas : savedPolygons.value.units;
  const polygon = polygonArray[index];

  if (!polygon || !polygon.startPoints || !polygon.startMousePos) return;

  const currentMousePos = d3.pointer(event, chartContainer.value);
  const dx = currentMousePos[0] - polygon.startMousePos[0];
  const dy = currentMousePos[1] - polygon.startMousePos[1];

  polygon.points = polygon.startPoints.map(point => [
    snapToGrid(point[0] + dx),
    snapToGrid(point[1] + dy),
  ]);

  drawChart();
};

const dragPolygonEnded = (event, index, type) => {
  const polygonArray =
    type === "area" ? savedPolygons.value.areas : savedPolygons.value.units;
  const polygon = polygonArray[index];

  if (!polygon) return;

  delete polygon.startPoints;
  delete polygon.startMousePos;
  localStorage.setItem("savedShapes", JSON.stringify(savedPolygons.value));
};

// 添加对齐功能
const alignShapes = alignment => {
  if (selectedPolygons.value.size < 2) return;

  const selectedShapes = Array.from(selectedPolygons.value)
    .map(selectionId => {
      const [type, indexStr] = selectionId.split("-");
      const index = parseInt(indexStr);
      return type === "area"
        ? savedPolygons.value.areas[index]
        : savedPolygons.value.units[index];
    })
    .filter(Boolean);

  // 计算界框
  const bounds = selectedShapes.map(polygon => {
    const xs = polygon.points.map(p => p[0]);
    const ys = polygon.points.map(p => p[1]);
    return {
      left: Math.min(...xs),
      right: Math.max(...xs),
      top: Math.min(...ys),
      bottom: Math.max(...ys),
      width: Math.max(...xs) - Math.min(...xs),
      height: Math.max(...ys) - Math.min(...ys),
      centerX: (Math.max(...xs) + Math.min(...xs)) / 2,
      centerY: (Math.max(...ys) + Math.min(...ys)) / 2,
    };
  });

  // 根据不同的齐方式计算偏移量
  selectedShapes.forEach((polygon, i) => {
    const currentBound = bounds[i];
    let dx = 0,
      dy = 0;

    switch (alignment) {
      case "left":
        dx = Math.min(...bounds.map(b => b.left)) - currentBound.left;
        break;
      case "center":
        const centerX =
          bounds.reduce((sum, b) => sum + b.centerX, 0) / bounds.length;
        dx = centerX - currentBound.centerX;
        break;
      case "right":
        dx = Math.max(...bounds.map(b => b.right)) - currentBound.right;
        break;
      case "top":
        dy = Math.min(...bounds.map(b => b.top)) - currentBound.top;
        break;
      case "middle":
        const centerY =
          bounds.reduce((sum, b) => sum + b.centerY, 0) / bounds.length;
        dy = centerY - currentBound.centerY;
        break;
      case "bottom":
        dy = Math.max(...bounds.map(b => b.bottom)) - currentBound.bottom;
        break;
    }

    // 应用偏移量
    polygon.points = polygon.points.map(point => [
      point[0] + dx,
      point[1] + dy,
    ]);
  });

  // 保存更改并重绘
  localStorage.setItem("savedShapes", JSON.stringify(savedPolygons.value));
  drawChart();
};

// 添加是否可以删除的计算属性
const canDelete = computed(() => selectedPolygons.value.size > 0);

// 添加删除选中多边形的功能
const deleteSelected = () => {
  if (selectedPolygons.value.size === 0) return;

  const previousState = JSON.parse(JSON.stringify(savedPolygons.value));
  undoStack.value.push({
    type: "clear",
    data: previousState,
  });

  // 收集要删除的索引
  const toDeleteAreas = [];
  const toDeleteUnits = [];

  selectedPolygons.value.forEach(selectionId => {
    const [type, indexStr] = selectionId.split("-");
    const index = parseInt(indexStr);

    // 确保在正确的模式下删除正确类型的图形
    if (type === "area" && drawingMode.value === "area") {
      toDeleteAreas.push(index);
    } else if (type === "unit" && drawingMode.value === "unit") {
      toDeleteUnits.push(index);
    }
  });

  // 按索引从大到小排序,这样删除时不会影响其他元素的索引
  toDeleteAreas.sort((a, b) => b - a);
  toDeleteUnits.sort((a, b) => b - a);

  // 删除区域
  toDeleteAreas.forEach(index => {
    savedPolygons.value.areas.splice(index, 1);
  });

  // 删除单元
  toDeleteUnits.forEach(index => {
    savedPolygons.value.units.splice(index, 1);
  });

  // 清空选择状态
  selectedPolygons.value.clear();

  // 保存更改到localStorage
  localStorage.setItem("savedShapes", JSON.stringify(savedPolygons.value));

  // 重新绘制
  drawChart();
};

const exportData = () => {
  console.log(savedPolygons.value);
  const parsedData = savedPolygons.value; // 解析 JSON 数据
  const blob = new Blob([JSON.stringify(parsedData, null, 2)], {
    type: "application/json",
  }); // 创建 Blob 对象
  const url = URL.createObjectURL(blob); // 创建下载链接

  const a = document.createElement("a"); // 创建一个链接元素
  a.href = url;
  a.download = "data.json"; // 设置下载文件名
  document.body.appendChild(a); // 将链接添加到文档
  a.click(); // 模拟点击下载
  document.body.removeChild(a); // 下载后移除链接
  URL.revokeObjectURL(url); // 释放 URL 对象
};

// 修改 handleContextMenu 函数
const handleContextMenu = (event, polygon) => {
  event.preventDefault();

  if (polygon.type === "area") {
    // 切换到单元绘制模式，移除只读模式判断
    drawingMode.value = "unit";
    currentAreaId.value = polygon.id;
    // 清空当前绘制的点
    points.value = [];
    // 清空选择状态
    selectedPolygons.value.clear();
    // 重新绘制
    drawChart();
    JE.message("已进入单元模式");
  }
};

// 添加返回区域绘制模式的功能
const backToAreaMode = () => {
  drawingMode.value = "area";
  currentAreaId.value = null;
  points.value = [];
  selectedPolygons.value.clear();
  drawChart();
};

// 添加绘制多边形的辅助函数
const drawPolygon = (svg, polygon, index, type, isBackground = false) => {
  const legendItem = legendStatus.value.find(
    item => item.value === polygon.color
  );
  if (!legendItem?.visible) return;

  const selectionId = `${type}-${index}`;
  const isSelected = selectedPolygons.value.has(selectionId);

  // 创建多边形元素
  const polygonElement = svg
    .append("polygon")
    .attr("points", polygon.points.map(d => d.join(",")).join(" "))
    .style("fill", polygon.color)
    .style("opacity", isBackground ? 0.3 : 1)
    .attr("stroke", isSelected ? "#000" : "black")
    .attr("stroke-width", isSelected ? 3 : 2)
    .style("cursor", "move")
    .style("stroke-dasharray", isSelected ? "5,5" : "none")
    .attr("data-index", index)
    .attr("data-type", type);

  if (!isBackground && !props.readonly) {
    // 根据当前模式决定是否添加事件监听
    const shouldAddEvents =
      (drawingMode.value === "area" && type === "area") ||
      (drawingMode.value === "unit" && type === "unit");

    if (shouldAddEvents) {
      polygonElement
        .on("click", event => togglePolygonSelection(index, event, type))
        .call(
          d3
            .drag()
            .on("start", function (event) {
              dragPolygonStarted(event, index, type);
            })
            .on("drag", function (event) {
              dragPolygon(event, index, type);
            })
            .on("end", function (event) {
              dragPolygonEnded(event, index, type);
            })
        );
    }
  }
  // 区域才需要右键菜单
  if (type === "area") {
    polygonElement.on("contextmenu", event => {
      handleContextMenu(event, { type, id: polygon.id });
    });
  }

  // 添加多边形名称
  if (polygon.name) {
    const center = calculatePolygonCenter(polygon.points);
    svg
      .append("text")
      .attr("x", center[0])
      .attr("y", center[1])
      .attr("text-anchor", "middle")
      .attr("fill", "black")
      .attr("font-size", "14px")
      .style("opacity", isBackground ? 0.3 : 1)
      .text(polygon.name);
  }
};

// 添加计算属性获取当前区域名称
const currentAreaName = computed(() => {
  if (drawingMode.value === "unit" && currentAreaId.value) {
    const currentArea = savedPolygons.value.areas.find(
      area => area.id === currentAreaId.value
    );
    return currentArea?.name || "";
  }
  return "";
});
</script>

<style scoped lang="less">
@import url("./style.less");
</style>
```

</details>

## 链接

- [d3.js 官网](https://d3js.org/what-is-d3)
- [d3 in react](https://2019.wattenberger.com/blog/react-and-d3)
- [探索 d3](https://observablehq.com/explore)
- [d3 api index](https://d3js.org/api)
- [webgl](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API)
