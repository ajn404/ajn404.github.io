---
author: ajn404
pubDatetime: 2024-11-27T17:22:34.000Z
modDatetime:
ogImage: /assets/gif/shader.gif
title: book of shader
featured: true
draft: false
tags:
  - "2024"
  - "glsl"
  - "book of shader"
description: "book of shader"
---

å­¦ä¹ shaderï¼Œä»book of shaderå¼€å§‹

import ShaderTemplate from "@components/react/fiber/bookOfShader/template.tsx";

import ShaderTemplateUrl from "@components/react/fiber/bookOfShader/templateFromUrl.tsx";

import Text from "@components/react/UI/Text.tsx";

import CodeFromUrl from "@components/astro/UI/code.astro";

## ç›®å½•

## [editor](/fantastic/glslEditor)

- [æœ¬åœ°æ‰“å¼€](/fantastic/glslEditor)
- [å®˜ç½‘](https://thebookofshaders.com/edit.php)

## 07

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/1.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/2.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/3.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/4.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/5.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/6.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/7.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/8.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/9.frag"
  client:only="react"
/>

</div>

<details >
<summary>demo</summary>

import Demo1 from "@components/react/fiber/bookOfShader/specific/demo1.tsx";

<Demo1 client:load />

</details>

### æåæ ‡ç³»ä¸‹çš„å›¾å½¢

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/10.frag"
  client:only="react"
/>

### å˜¿ï¼ŒåŠ¨èµ·æ¥ï¼

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/11.frag"
  client:only="react"
/>

```glsl
uniform vec2 u_resolution;
uniform float u_time;

varying vec2 v_uv;

void main(){
    vec2 uv  = v_uv;
    vec3 color = vec3(0.0);

    vec2 pos= vec2(0.5)- uv;

    float d = length(pos);
    float r = d*2.0;

    float a = atan(pos.y,pos.x);
    float f = cos(a*3.0+u_time*0.5);
    color = vec3(1.0 - smoothstep(f, f+0.01, r));

    gl_FragColor = vec4(color, 1.0);
}
```

<details open>
<summary>Click to expand</summary>
vec2 uv = v_uv;: å°† v_uv èµ‹å€¼ç»™ uvï¼Œæ–¹ä¾¿åç»­ä½¿ç”¨ã€‚

vec3 color = vec3(0.0);: åˆå§‹åŒ–é¢œè‰²å‘é‡ä¸ºé»‘è‰²ã€‚

vec2 pos = vec2(0.5) - uv;: è®¡ç®—ç‰‡æ®µç›¸å¯¹äºå±å¹•ä¸­å¿ƒçš„åæ ‡ã€‚vec2(0.5) ä»£è¡¨å±å¹•ä¸­å¿ƒï¼Œå‡å» uv å¾—åˆ°ç‰‡æ®µçš„åç§»é‡ã€‚

float d = length(pos);: è®¡ç®—ç‰‡æ®µåˆ°å±å¹•ä¸­å¿ƒçš„è·ç¦»ã€‚

float r = d \* 2.0;: å°†è·ç¦»ç¼©æ”¾ä¸¤å€ã€‚è¿™å½±å“äº†å›¾æ¡ˆçš„åŠå¾„ã€‚

float a = atan(pos.y, pos.x);: è®¡ç®—ç‰‡æ®µç›¸å¯¹äºxè½´çš„è§’åº¦ã€‚

float f = cos(a _ 3.0 + u_time _ 0.5);: è¿™æ˜¯æ ¸å¿ƒéƒ¨åˆ†ï¼Œå®ƒè®¡ç®—äº†ä¸€ä¸ªåŸºäºè§’åº¦å’Œæ—¶é—´çš„æ³¢æµªå‡½æ•°ã€‚a _ 3.0 å†³å®šäº†èŠ±ç“£çš„æ•°é‡ (3ç“£)ï¼Œu_time _ 0.5 ä½¿å›¾æ¡ˆéšæ—¶é—´æ—‹è½¬ã€‚cos å‡½æ•°äº§ç”Ÿæ³¢æµªæ•ˆæœã€‚

color = vec3(1.0 - smoothstep(f, f + 0.01, r));: è¿™æ˜¯å›¾æ¡ˆç”Ÿæˆçš„æœ€ç»ˆæ­¥éª¤ã€‚smoothstep å‡½æ•°æ˜¯ä¸€ä¸ªå¹³æ»‘çš„æ­¥è¿›å‡½æ•°ï¼Œå®ƒæ ¹æ® r (è·ç¦») å’Œ f (æ³¢æµªå‡½æ•°) çš„å€¼ç”Ÿæˆä¸€ä¸ªå¹³æ»‘è¿‡æ¸¡çš„é¢œè‰²ã€‚1.0 - smoothstep(...) åè½¬äº†é¢œè‰²ï¼Œä½¿å›¾æ¡ˆçœ‹èµ·æ¥æ›´æ¸…æ™°ã€‚

gl_FragColor = vec4(color, 1.0);: å°†è®¡ç®—å‡ºçš„é¢œè‰²èµ‹å€¼ç»™ gl_FragColorï¼Œè¿™æ˜¯ç‰‡æ®µç€è‰²å™¨çš„è¾“å‡ºï¼Œè¡¨ç¤ºç‰‡æ®µæœ€ç»ˆçš„é¢œè‰²å’Œalphaå€¼ (alphaå€¼ä¸º1.0ï¼Œå®Œå…¨ä¸é€æ˜)ã€‚

</details>

### [å¡”ç½—ç‰Œå­¦ä¹ shader](https://pixelspiritdeck.com/)

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/12.frag"
  client:only="react"
/>

## 08

### å¹³ç§» æ—‹è½¬ ç»“åˆ

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/13.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/14.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/15.frag"
  client:only="react"
/>
</div>

### ç¼©æ”¾

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/16.frag"
  client:only="react"
/>

### demo

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/1.frag"
  client:only="react"
/>

- ä¸€å¼€å§‹å›¾å½¢æ²¡å±…ä¸­,åè¿‡æ¥è®¡ç®—äº†ä¸€ä¸‹`fragCoord`

```glsl
    vec2 uv = v_uv;
    vec2 c = v_uv * u_resolution.xy;
    mainImage(gl_FragColor, c);
```

<details>
<summary>source code</summary>

```glsl
#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))
#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )
#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )
#define M_PI 3.1415926535897932384626433832795

#define blue1 vec3(0.74,0.95,1.00)
#define blue2 vec3(0.87,0.98,1.00)
#define blue3 vec3(0.35,0.76,0.83)
#define blue4 vec3(0.953,0.969,0.89)
#define red   vec3(1.00,0.38,0.227)

#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))

varying vec2 v_uv;
uniform vec2 u_resolution;
uniform float u_time;

float movingLine(vec2 uv, vec2 center, float radius) {
    //angle of the line
    float theta0 = 90.0 * u_time;
    vec2 d = uv - center;
    float r = sqrt(dot(d, d));
    if(r < radius) {
        //compute the distance to the line theta=theta0
        vec2 p = radius * vec2(cos(theta0 * M_PI / 180.0), -sin(theta0 * M_PI / 180.0));
        float l = length(d - p * clamp(dot(d, p) / dot(p, p), 0.0, 1.0));
        d = normalize(d);
        //compute gradient based on angle difference to theta0
        float theta = mod(180.0 * atan(d.y, d.x) / M_PI + theta0, 360.0);
        float gradient = clamp(1.0 - theta / 90.0, 0.0, 1.0);
        return SMOOTH(l, 1.0) + 0.5 * gradient;
    } else
        return 0.0;
}

float circle(vec2 uv, vec2 center, float radius, float width) {
    float r = length(uv - center);
    return SMOOTH(r - width / 2.0, radius) - SMOOTH(r + width / 2.0, radius);
}

float circle2(vec2 uv, vec2 center, float radius, float width, float opening) {
    vec2 d = uv - center;
    float r = sqrt(dot(d, d));
    d = normalize(d);
    if(abs(d.y) > opening)
        return SMOOTH(r - width / 2.0, radius) - SMOOTH(r + width / 2.0, radius);
    else
        return 0.0;
}
float circle3(vec2 uv, vec2 center, float radius, float width) {
    vec2 d = uv - center;
    float r = sqrt(dot(d, d));
    d = normalize(d);
    float theta = 180.0 * (atan(d.y, d.x) / M_PI);
    return smoothstep(2.0, 2.1, abs(mod(theta + 2.0, 45.0) - 2.0)) *
        mix(0.5, 1.0, step(45.0, abs(mod(theta, 180.0) - 90.0))) *
        (SMOOTH(r - width / 2.0, radius) - SMOOTH(r + width / 2.0, radius));
}

float triangles(vec2 uv, vec2 center, float radius) {
    vec2 d = uv - center;
    return RS(-8.0, 0.0, d.x - radius) * (1.0 - smoothstep(7.0 + d.x - radius, 9.0 + d.x - radius, abs(d.y))) + RS(0.0, 8.0, d.x + radius) * (1.0 - smoothstep(7.0 - d.x - radius, 9.0 - d.x - radius, abs(d.y))) + RS(-8.0, 0.0, d.y - radius) * (1.0 - smoothstep(7.0 + d.y - radius, 9.0 + d.y - radius, abs(d.x))) + RS(0.0, 8.0, d.y + radius) * (1.0 - smoothstep(7.0 - d.y - radius, 9.0 - d.y - radius, abs(d.x)));
}

float _cross(vec2 uv, vec2 center, float radius) {
    vec2 d = uv - center;
    int x = int(d.x);
    int y = int(d.y);
    float r = sqrt(dot(d, d));
    if((r < radius) && ((x == y) || (x == -y)))
        return 1.0;
    else
        return 0.0;
}
float dots(vec2 uv, vec2 center, float radius) {
    vec2 d = uv - center;
    float r = sqrt(dot(d, d));
    if(r <= 2.5)
        return 1.0;
    if((r <= radius) && ((abs(d.y + 0.5) <= 1.0) && (mod(d.x + 1.0, 50.0) < 2.0)))
        return 1.0;
    else if((abs(d.y + 0.5) <= 1.0) && (r >= 50.0) && (r < 115.0))
        return 0.5;
    else
        return 0.0;
}
float bip1(vec2 uv, vec2 center) {
    return SMOOTH(length(uv - center), 3.0);
}
float bip2(vec2 uv, vec2 center) {
    float r = length(uv - center);
    float R = 8.0 + mod(87.0 * u_time, 80.0);
    return (0.5 - 0.5 * cos(30.0 * u_time)) * SMOOTH(r, 5.0) + SMOOTH(6.0, r) - SMOOTH(8.0, r) + smoothstep(max(8.0, R - 20.0), R, r) - SMOOTH(R, r);
}
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec3 finalColor;
    vec2 uv = fragCoord.xy;
    vec2 c = u_resolution.xy / 2.0;
    finalColor = vec3(0.3 * _cross(uv, c, 240.0));
    finalColor += (circle(uv, c, 100.0, 1.0) + circle(uv, c, 165.0, 1.0)) * blue1;
    finalColor += (circle(uv, c, 240.0, 2.0));
    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;
    finalColor += triangles(uv, c, 315.0 + 30.0 * sin(u_time)) * blue2;
    finalColor += movingLine(uv, c, 240.0) * blue3;
    finalColor += circle(uv, c, 10.0, 1.0) * blue3;
    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5 + 0.2 * cos(u_time)) * blue3;
    if(length(uv - c) < 240.0) {
        vec2 p = 130.0 * MOV(1.3, 1.0, 1.0, 1.4, 3.0 + 0.1 * u_time);
        finalColor += bip1(uv, c + p) * vec3(1, 1, 1);
        p = 130.0 * MOV(0.9, -1.1, 1.7, 0.8, -2.0 + sin(0.1 * u_time) + 0.15 * u_time);
        finalColor += bip1(uv, c + p) * vec3(1, 1, 1);
        p = 50.0 * MOV(1.54, 1.7, 1.37, 1.8, sin(0.1 * u_time + 7.0) + 0.2 * u_time);
        finalColor += bip2(uv, c + p) * red;
    }
    fragColor = vec4(finalColor, 1.0);
}

void main() {
    //é€šè¿‡v_uvå’Œu_resolutionè®¡ç®—å½“å‰åƒç´ çš„åæ ‡
    vec2 uv = v_uv;
    vec2 c = v_uv * u_resolution.xy;


    mainImage(gl_FragColor, c);
}
```

</details>

### yvu

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/07/17.frag"
  client:only="react"
/>

## 09 patterns

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/1.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/2.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/3.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/4.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/5.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/6.frag"
  client:only="react"
/>

</div>

- æ ¹æ®æ—¶é—´å˜åŒ–å¯¹åç§»é‡åšåŠ¨ç”»ã€‚

<div class="prose-flex ">
<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/7.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/8.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/9.frag"
  client:only="react"
/>

</div>

- Truchet

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/10.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/11.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/12.frag"
  client:only="react"
/>

</div>

- æŠŠé»‘ç™½ä¸‰è§’å˜æˆå…¶ä»–å…ƒç´ 

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/13.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/15.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/14.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/09/16.frag"
  client:only="react"
/>

</div>

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/2.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/3.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/4.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/5.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/6.frag"
  client:only="react"
/>

</div>

## 10 éšæœº

$$
y = fract(sin(x)*100000.0);
$$

<ShaderTemplateUrl
  width="60"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/fract.frag"
  client:only="react"
/>

```glsl
//ç”Ÿæˆä¼ªéšæœºæµ®ç‚¹æ•°çš„å‡½æ•°
float random(vec2 coord) {
    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
}
```

<div class="prose-flex ">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_param.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_rect.frag"
  client:only="react"
/>

</div>

- é´å¾®åº”ç”¨ä¸€ä¸‹

```glsl
varying vec2 v_uv;
uniform float u_time;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *
        43758.5453123);
}

void main() {
    vec2 st = v_uv * 10.0; // è°ƒæ•´ 10.0 æ¥æ§åˆ¶çº¹ç†çš„åˆ†è¾¨ç‡
    float x = v_uv.x * 10.0; // è°ƒæ•´ 10.0 æ¥æ§åˆ¶ x è½´çš„èŒƒå›´
    float y = fract(sin(x) * min(u_time, 100000.));
    st  = st /2.;
    gl_FragColor = vec4(random(st)*st.x, y*st.x, random(st)*st.x, 1.0); // ä½¿ç”¨ y å€¼ä½œä¸ºç°åº¦é¢œè‰²
}
```

<ShaderTemplateUrl
  width="60"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/func.frag"
  client:only="react"
/>

<div class="prose-flex">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_walk_v1.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_walk_v2.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_walk_v3.frag"
  client:only="react"
/>

</div>

### md,åŠ¨èµ·æ¥ï¼

<div class="prose-flex">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_walk_v1_move.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_walk_v2_move.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/10/random_walk_v3_move.frag"
  client:only="react"
/>

</div>

### demo

<div class="prose-flex gap-0 items-center text-lg">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/8.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/9.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/7.frag"
  client:only="react"
/>

</div>

## 11 å™ªå£°

<div class="prose-flex gap-1 items-center">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/noise.frag"
  client:only="react"
/>

ç»“åˆu_mouse

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/noise_mouse.frag"
  client:only="react"
/>

</div>

å°±åƒåœ¨[è¿™ç¯‡æ–‡ç« ](/posts/nature-of-code#perlincurve)ä¸­å°è¯•çš„æŸæ—å™ªå£°ä¸€æ ·

<details>
<summary>Click to expand</summary>

import PerlinCurve from "@components/react/p5/Randomness/PerlinCurve.tsx";

<PerlinCurve hideRandom client:visible />

</details>

è·ç¦»åœº

<div class="prose-flex gap-1 items-center">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/circle.frag"
  client:only="react"
/>

```glsl
float n = noise(pos);float c = circle(st, n * 0.5);
```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/noise_mouse_circle.frag"
  client:only="react"
/>

çœ‹ç€ä¼¼ä¹å’Œå‰é¢çš„ä¸€æ ·ï¼Œå®é™…è¿™ä¸ªæ˜¯rectangle,èƒŒæ™¯åœ¨2.5kæ˜¾ç¤ºå±æ˜¯é»‘è‰²çš„ï¼Œ1kæ˜¾ç¤ºå±åˆ™æ˜¯é’é»„äº¤æ¥

<ShaderTemplateUrl
  width="60"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/noise_rect.frag"
  client:only="react"
/>

</div>

ä¹˜é£ç ´æµª,è™½ç„¶å¾ˆæ€ª

<ShaderTemplateUrl
  width="60"
  height="30"
  imgPaths="/assets/webp/2.webp"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/noise_rect_art_v2.frag"
  client:only="react"
/>

<details>
<summary>value noise && gradient noise</summary>

**Value Noise** å’Œ **Gradient Noise** æ˜¯è®¡ç®—æœºå›¾å½¢å­¦ä¸­ä¸¤ç§å¸¸è§çš„å™ªå£°ç”Ÿæˆæ–¹æ³•ã€‚å®ƒä»¬åœ¨æ•°å­¦æ„é€ ã€è§†è§‰æ•ˆæœå’Œå®ç°æ–¹å¼ä¸Šæœ‰æ‰€ä¸åŒã€‚ä»¥ä¸‹æ˜¯ä¸¤è€…çš„ä¸»è¦åŒºåˆ«ï¼š

---

### **1. å®šä¹‰å’ŒåŸç†**

#### **Value Noise**

- **æ ¸å¿ƒæ€æƒ³**ï¼šåœ¨ç½‘æ ¼çš„æ¯ä¸ªé¡¶ç‚¹ç”Ÿæˆéšæœºçš„æ ‡é‡å€¼ï¼ˆå•ä¸ªå€¼ï¼‰ï¼Œç„¶åé€šè¿‡æ’å€¼å‡½æ•°åœ¨ç½‘æ ¼å†…éƒ¨å¹³æ»‘è¿‡æ¸¡ã€‚
- **æ„é€ æ–¹å¼**ï¼š
  1. åœ¨ä¸€ä¸ªè§„åˆ™ç½‘æ ¼ä¸Šåˆ†é…éšæœºå€¼ï¼ˆæ ‡é‡ï¼‰ã€‚
  2. åœ¨ç½‘æ ¼å†…æ’å€¼ï¼ˆä¾‹å¦‚ä½¿ç”¨çº¿æ€§æ’å€¼æˆ–ä¸‰æ¬¡æ’å€¼ï¼‰ã€‚
  3. å¹³æ»‘åçš„å™ªå£°å€¼å‘ˆç°è¿ç»­å˜åŒ–ï¼Œä½†æ¢¯åº¦ä¸è¿ç»­ã€‚
- **è§†è§‰æ•ˆæœ**ï¼š
  - çœ‹èµ·æ¥åƒæŸ”å’Œçš„äº‘æœµæˆ–æ¨¡ç³Šçš„çº¹ç†ã€‚
  - å…·æœ‰æŸ”å’Œè¿‡æ¸¡ï¼Œä½†æ•´ä½“æ²¡æœ‰æ˜¾è‘—çš„æ–¹å‘æ€§ã€‚

---

#### **Gradient Noise**

- **æ ¸å¿ƒæ€æƒ³**ï¼šåœ¨ç½‘æ ¼çš„æ¯ä¸ªé¡¶ç‚¹ç”Ÿæˆéšæœºçš„æ¢¯åº¦å‘é‡ï¼Œè€Œä¸æ˜¯æ ‡é‡å€¼ã€‚å™ªå£°å€¼æ˜¯æ ¹æ®æ¢¯åº¦çš„å½±å“è®¡ç®—çš„ã€‚
- **æ„é€ æ–¹å¼**ï¼š
  1. åœ¨ç½‘æ ¼é¡¶ç‚¹åˆ†é…éšæœºçš„æ¢¯åº¦å‘é‡ã€‚
  2. åœ¨ç½‘æ ¼å†…éƒ¨ï¼Œé€šè¿‡å°†é¡¶ç‚¹æ¢¯åº¦ç‚¹ç§¯æ’å€¼ç‚¹çš„å‘é‡æ¥è®¡ç®—å™ªå£°å€¼ã€‚
  3. æ’å€¼ç»“æœæ›´å…‰æ»‘ï¼Œæ¢¯åº¦è¿ç»­ã€‚
- **ä»£è¡¨æ–¹æ³•**ï¼š
  - Perlin Noise æ˜¯ Gradient Noise çš„å…¸å‹ä¾‹å­ã€‚
- **è§†è§‰æ•ˆæœ**ï¼š
  - æ›´è‡ªç„¶çš„å˜åŒ–ï¼Œå¸¸ç”¨äºæ¨¡æ‹Ÿåœ°å½¢ã€äº‘å±‚ã€æ°´é¢ç­‰ã€‚

---

### **2. æ•°å­¦æ’å€¼**

- **Value Noise**ï¼š
  - æ’å€¼ä»…åŸºäºç½‘æ ¼é¡¶ç‚¹çš„æ ‡é‡å€¼ã€‚
  - é€šå¸¸ä½¿ç”¨çº¿æ€§æ’å€¼ã€åŒçº¿æ€§æ’å€¼æˆ–ä¸‰æ¬¡æ’å€¼å‡½æ•°ã€‚
  - æ¢¯åº¦ä¸è¿ç»­ï¼Œå¯èƒ½å‡ºç°è§†è§‰ä¸Šçš„ç¡¬è¾¹ã€‚
- **Gradient Noise**ï¼š
  - æ’å€¼åŸºäºç½‘æ ¼é¡¶ç‚¹çš„æ¢¯åº¦ï¼ˆæ–¹å‘ä¿¡æ¯ï¼‰å’Œä¸æ’å€¼ç‚¹çš„çŸ¢é‡çš„ç‚¹ç§¯ã€‚
  - é€šå¸¸ä½¿ç”¨ä¸‰æ¬¡æ’å€¼ï¼ˆä¾‹å¦‚ Hermite æ’å€¼ï¼‰ã€‚
  - æ¢¯åº¦è¿ç»­ï¼Œè§†è§‰ä¸Šæ›´å¹³æ»‘ã€‚

---

### **3. æ€§èƒ½**

- **Value Noise**ï¼š
  - å®ç°ç®€å•ï¼Œè®¡ç®—é‡è¾ƒå°ã€‚
  - é€‚åˆç”Ÿæˆå¿«é€Ÿçš„å™ªå£°æ•ˆæœï¼Œä½†ç¼ºä¹çœŸå®æ„Ÿã€‚
- **Gradient Noise**ï¼š
  - å®ç°è¾ƒå¤æ‚ï¼Œéœ€è¦é¢å¤–çš„æ¢¯åº¦è®¡ç®—ã€‚
  - æ€§èƒ½ç¨æ…¢ï¼Œä½†ç»“æœæ›´åŠ è‡ªç„¶ï¼Œé€‚åˆé«˜è´¨é‡éœ€æ±‚ã€‚

---

### **4. è§†è§‰æ•ˆæœ**

| ç‰¹æ€§     | **Value Noise**    | **Gradient Noise**             |
| -------- | ------------------ | ------------------------------ |
| å¹³æ»‘ç¨‹åº¦ | å¹³æ»‘ï¼Œä½†å¯èƒ½æœ‰ç¡¬è¾¹ | æ›´åŠ å¹³æ»‘ï¼Œè‡ªç„¶                 |
| æ–¹å‘æ€§   | æ— æ–¹å‘æ€§ï¼Œå˜åŒ–å‡åŒ€ | æœ‰æ–¹å‘æ€§ï¼Œè¡¨ç°æ›´çœŸå®           |
| ç”¨é€”     | çº¹ç†ç”Ÿæˆã€ç®€å•å™ªå£° | åœ°å½¢ã€äº‘å±‚ã€æ°´é¢æ¨¡æ‹Ÿç­‰è‡ªç„¶ç°è±¡ |

---

### **5. åº”ç”¨åœºæ™¯**

- **Value Noise**ï¼š
  - é€‚åˆå¿«é€Ÿç”ŸæˆæŸ”å’Œçš„å™ªå£°æ•ˆæœã€‚
  - ç”¨äºç®€å•çš„èƒŒæ™¯ã€ç²—ç³™çš„å™ªå£°çº¹ç†ã€‚
- **Gradient Noise**ï¼š
  - æ›´é€‚åˆæ¨¡æ‹Ÿè‡ªç„¶ç°è±¡ï¼Œå¦‚åœ°å½¢ç”Ÿæˆã€äº‘å±‚ã€æ°´é¢ã€çƒŸé›¾ç­‰ã€‚
  - è¢«å¹¿æ³›ç”¨äºå›¾å½¢å­¦ã€æ¸¸æˆå¼€å‘å’Œç¨‹åºåŒ–å†…å®¹ç”Ÿæˆã€‚

---

### **æ€»ç»“**

- **Value Noise** ç®€å•é«˜æ•ˆï¼Œé€‚åˆå¯¹è´¨é‡è¦æ±‚ä¸é«˜çš„åœºæ™¯ã€‚
- **Gradient Noise** æä¾›æ›´çœŸå®ã€æ›´å¹³æ»‘çš„ç»“æœï¼Œä½†è®¡ç®—æ›´å¤æ‚ï¼Œé€‚åˆéœ€è¦é«˜è´¨é‡è‡ªç„¶æ¨¡æ‹Ÿçš„åœºæ™¯ã€‚

</details>

- gradient noise

<div class="items-center prose-flex">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/gradient_noise_rect.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  imgPaths="/assets/webp/2.webp"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/gradient_noise_rect_art_v2.frag"
  client:only="react"
/>

ï¼ğŸ¤¯ç«Ÿç„¶æœ‰æµªçº¹

</div>

<div class="prose-flex items-center flex-wrap text-wrap">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/grid.frag"
  client:only="react"
/>

```glsl
vec2 skew(vec2 st) {
    vec2 r = vec2(0.0);
    r.x = 1.1547 * st.x;
    r.y = st.y + 0.5 * r.x;
    return r;
}

```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/grid_skew.frag"
  client:only="react"
/>

é€šè¿‡åˆ¤æ–­ if x > y (ä¸‹ä¸‰è§’) è¿˜æ˜¯ y >
x(ä¸Šä¸‰è§’)ï¼Œå°±æŠŠæ­ªæ–œè¿‡çš„æ­£æ–¹å½¢åˆ‡æˆäº†ä¸¤ä¸ªç­‰è…°ä¸‰è§’å½¢

```glsl
vec3 simplexGrid(vec2 st) {
    vec3 xyz = vec3(0.0);

    vec2 p = fract(skew(st));
    if(p.x > p.y) {
        xyz.xy = 1.0 - vec2(p.x, p.y - p.x);
        xyz.z = p.y;
    } else {
        xyz.yz = 1.0 - vec2(p.x - p.y, p.y);
        xyz.x = p.x;
    }

    return fract(xyz);
}
```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/grid_simplex.frag"
  client:only="react"
/>

<p class="w-1/4">**Simplex Noise**</p>

```glsl
float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187,
    0.366025403784439,
    -0.577350269189626,
    0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = vec2(0.0);
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec2 x1 = x0.xy + C.xx - i1;
    vec2 x2 = x0.xy + C.zz;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);

    m = m * m;
    m = m * m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

    vec3 g = vec3(0.0);
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);
    return 130.0 * dot(m, g);
}
```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/simplexNoise.frag"
  client:only="react"
/>

import Excalidraw from "@components/astro/UI/excalidraw.astro";

<details>
<summary>æµç¨‹å›¾</summary>

<Excalidraw
  viewModeEnabled="true"
  file="perlin_noise"
  className="w-full h-full"
/>

</details>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/11/perlin_noise.frag"
  client:only="react"
/>

</div>

### demo

<div class="prose-flex">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/pang.frag"
  client:only="react"
/>

ok,å¥½æ€ªï¼ŒğŸ˜‚

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/pang_v1.frag"
  client:only="react"
/>

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/noise.frag"
  client:only="react"
  imgPaths="/assets/svg/ru02.svg,/assets/svg/ru01.svg"
/>

</div>

## 12 è¿­ä»£

### forå¾ªç¯å®ç°è·ç¦»åœº

<div class="prose-flex">

é€šè¿‡é¼ æ ‡ä½ç½®åŠ¨æ€è°ƒæ•´ä¸€ä¸ªç‚¹çš„ä½ç½®ï¼Œä»è€Œå®æ—¶æ”¹å˜å›¾åƒæ•ˆæœ

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop.frag"
  client:only="react"
/>

```glsl
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

varying vec2 v_uv;

void main() {
    vec2 st = v_uv;
    vec3 color = vec3(.0);
    vec2 point[5];
    point[0] = vec2(0.83, 0.75);
    point[1] = vec2(0.60, 0.07);
    point[2] = vec2(0.28, 0.64);
    point[3] = vec2(0.31, 0.26);
    point[4] = u_mouse ;
    //5ä¸ªç‰¹å¾ç‚¹ï¼Œä¸€ä¸ªæ˜¯é¼ æ ‡ä½ç½®
    float m_dist = 1.;
    for(int i = 0; i < 5; i++) {
        float dist = distance(st, point[i]);
        m_dist = min(m_dist, dist);
    }
    color += m_dist;
    // color -= step(.7,abs(sin(50.0*m_dist)))*.3;
    gl_FragColor = vec4(color, 1.0);
}
```

å–æ¶ˆæ³¨é‡Š,èƒ½ç›´è§‚åœ°çœ‹åˆ°è·ç¦»åœº

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_clear.frag"
  client:only="react"
/>

</div>

<div class="prose-flex flex-wrap">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_grid.frag"
  client:only="react"
/>

è®¡ç®—ç›¸é‚»ç½‘ç»œçš„åƒç´ ç‚¹å’Œéšæœºç‚¹çš„ä½ç½®,æŠŠç©ºé—´åˆ†å‰²æˆç½‘æ ¼,è®¡ç®—æ¯ä¸ªåƒç´ ç‚¹åˆ°å®ƒæ‰€åœ¨ç½‘æ ¼ä¸­çš„é‚£ä¸ªç‰¹å¾ç‚¹çš„è·ç¦»ï¼Œå’Œå®ƒåˆ°ç›¸é‚»çš„å…«ä¸ªç½‘æ ¼ä¸­çš„ç‰¹å¾ç‚¹çš„è·ç¦»ï¼Œç»“æœæ˜¯ä¸€ä¸ªè·ç¦»åœº

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_grid_neighbor.frag"
  client:only="react"
/>

</div>

<div class="prose-flex">

```glsl
color += m_dist;                 // ç»˜åˆ¶æœ€å°è·ç¦»ï¼ˆå¹³æ»‘çš„ç°åº¦åœºï¼‰
color += 1. - step(.02, m_dist); // ç»˜åˆ¶ç½‘æ ¼ä¸­å¿ƒçš„åœ†ç‚¹
color -= step(.7,abs(sin(27.0*m_dist)))*.5;
```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_grid_neighbor_v1.frag"
  client:only="react"
/>

```glsl
color += smoothstep(.1, .5, m_dist);
```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_grid_neighbor_v2.frag"
  client:only="react"
/>

</div>

<div class="prose-flex">

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_grid_neighbor_v3.frag"
  client:only="react"
/>

```glsl
point = 0.1 + 0.9 * sin(u_time + 6.2831 * point);
//éšæœºç‚¹åº”è¯¥èƒ½å‡ºç°åœ¨å¤šä¸ªç½‘æ ¼ä¸­
```

<ShaderTemplateUrl
  width="30"
  height="30"
  fragmentShaderPath="/assets/glsl/bookOfShader/12/for_loop_grid_neighbor_v4.frag"
  client:only="react"
/>

</div>

<details>
<summary>Georgy Voronoiç®—æ³•</summary>

import D3Voronoi from "@components/react/d3/practice/Voronoi.tsx";

<D3Voronoi client:visible />

import Voronoi from "@components/react/observablehq/ajn404/voronoi.tsx";

<Voronoi client:visible />

Georgy Voronoiç®—æ³•ç”¨äºç”ŸæˆVoronoiå›¾ï¼Œè¿™æ˜¯ä¸€ç§å°†å¹³é¢åˆ’åˆ†ä¸ºå¤šä¸ªåŒºåŸŸçš„æ–¹æ³•ï¼Œæ¯ä¸ªåŒºåŸŸå¯¹åº”äºä¸€ä¸ªç»™å®šçš„ç‚¹é›†ï¼ˆç§°ä¸ºç§å­ç‚¹ï¼‰ã€‚åœ¨æ¯ä¸ªVoronoiå•å…ƒä¸­ï¼Œæ‰€æœ‰ç‚¹åˆ°è¯¥ç§å­ç‚¹çš„è·ç¦»éƒ½å°äºåˆ°å…¶ä»–ç§å­ç‚¹çš„è·ç¦»ã€‚ä»¥ä¸‹æ˜¯Voronoiå›¾ç”Ÿæˆçš„åŸºæœ¬æ­¥éª¤å’Œä¸€ç§å¸¸è§çš„ç®—æ³•å®ç°ï¼š

### åŸºæœ¬æ­¥éª¤

1. **è¾“å…¥ç‚¹é›†**ï¼šç»™å®šä¸€ç»„ç‚¹ï¼ˆç§å­ç‚¹ï¼‰ã€‚
2. **è®¡ç®—è¾¹ç•Œ**ï¼šå¯¹äºæ¯ä¸€å¯¹ç§å­ç‚¹ï¼Œè®¡ç®—å®ƒä»¬çš„ä¸­å‚çº¿ï¼Œè¿™äº›ä¸­å‚çº¿å°†å½¢æˆVoronoiå›¾çš„è¾¹ç•Œã€‚
3. **æ„å»ºå•å…ƒ**ï¼šé€šè¿‡è¿æ¥ä¸­å‚çº¿çš„äº¤ç‚¹ï¼Œå½¢æˆVoronoiå•å…ƒã€‚
4. **è¾“å‡ºç»“æœ**ï¼šè¿”å›Voronoiå›¾çš„è¾¹ç•Œå’Œå•å…ƒã€‚

### å¸¸è§ç®—æ³•

1. **æš´åŠ›æ³•**ï¼š

   - å¯¹äºæ¯ä¸ªåƒç´ ï¼Œè®¡ç®—å…¶åˆ°æ‰€æœ‰ç§å­ç‚¹çš„è·ç¦»ï¼Œé€‰æ‹©æœ€è¿‘çš„ç§å­ç‚¹ã€‚è¿™ç§æ–¹æ³•ç®€å•ä½†æ•ˆç‡ä½ä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ã€‚

2. **Fortuneç®—æ³•**ï¼š
   - è¿™æ˜¯ä¸€ä¸ªæ›´é«˜æ•ˆçš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n log n)ã€‚å®ƒä½¿ç”¨äº†æ‰«æçº¿æŠ€æœ¯ï¼Œé€šè¿‡ç»´æŠ¤ä¸€ä¸ªäº‹ä»¶é˜Ÿåˆ—å’Œä¸€ä¸ªæ´»åŠ¨è¾¹ç•Œæ¥æ„å»ºVoronoiå›¾ã€‚

### ç¤ºä¾‹ä»£ç ï¼ˆPythonï¼‰

ä»¥ä¸‹æ˜¯ä½¿ç”¨æš´åŠ›æ³•ç”ŸæˆVoronoiå›¾çš„ç®€å•ç¤ºä¾‹ï¼š

```python
import numpy as np
import matplotlib.pyplot as plt

def voronoi(points, size):
    img = np.zeros((size, size, 3), dtype=np.uint8)
    for x in range(size):
        for y in range(size):
            # è®¡ç®—æ¯ä¸ªåƒç´ åˆ°æ‰€æœ‰ç§å­ç‚¹çš„è·ç¦»
            distances = [np.linalg.norm(np.array([x, y]) - np.array(point)) for point in points]
            # æ‰¾åˆ°æœ€è¿‘çš„ç§å­ç‚¹
            closest = np.argmin(distances)
            img[y, x] = [closest * 50 % 255, closest * 100 % 255, closest * 150 % 255]  # é¢œè‰²ç¼–ç 
    return img

# ç¤ºä¾‹ç§å­ç‚¹
points = [(100, 200), (300, 400), (500, 100), (700, 600)]
size = 800
voronoi_image = voronoi(points, size)

plt.imshow(voronoi_image)
plt.title("Voronoi Diagram")
plt.axis('off')
plt.show()
```

è¿™ä¸ªä»£ç ç¤ºä¾‹ç”Ÿæˆäº†ä¸€ä¸ªç®€å•çš„Voronoiå›¾ï¼Œä½¿ç”¨éšæœºé¢œè‰²æ¥è¡¨ç¤ºä¸åŒçš„å•å…ƒã€‚ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ç§å­ç‚¹çš„ä½ç½®å’Œæ•°é‡ã€‚

</details>

- demo

<ShaderTemplateUrl
  width="90"
  height="20"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/fluent.frag"
  client:only="react"
/>

- åŠ å…¥æ›´å¤šçš„å˜åŒ–

<ShaderTemplateUrl
  width="90"
  height="20"
  fragmentShaderPath="/assets/glsl/bookOfShader/demo/fluent_v1.frag"
  client:only="react"
/>

## æœ¬é¡µé¢ä¸»è¦ä½¿ç”¨çš„ç»„ä»¶æºç 

[src/components/react/fiber/bookOfShader/templateFromUrl.tsx](https://github.com/ajn404/ajn404.github.io/blob/main/src/components/react/fiber/bookOfShader/templateFromUrl.tsx)

<details >
<summary>Click to expand</summary>

- åˆå§‹åŒ–ä»£ç 

```tsx
import React, {
  useRef,
  useEffect,
  useState,
  useMemo,
  useCallback,
} from "react";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { ShaderMaterial } from "three";
import * as THREE from "three";

const CustomShaderCube: React.FC<{
  mouse: { x: number; y: number };
  vertexShader: string;
  fragmentShader: string;
}> = ({ mouse, vertexShader, fragmentShader }) => {
  const meshRef = useRef<THREE.Mesh>(null);
  const { size, gl } = useThree();

  const material = useMemo<ShaderMaterial>(() => {
    return new ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2() },
        u_mouse: { value: new THREE.Vector2() },
      },
    });
  }, [vertexShader, fragmentShader]);

  useEffect(() => {
    const updateSize = () => {
      gl.setPixelRatio(window.devicePixelRatio || 2);
      gl.setSize(size.width, size.height);
      material.uniforms.u_resolution.value.set(size.width, size.height);
    };
    updateSize();
  }, [size, gl, material]);

  useFrame(({ clock }) => {
    material.uniforms.u_time.value = clock.getElapsedTime();
    material.uniforms.u_mouse.value.set(mouse.x, mouse.y);
    material.uniforms.u_resolution.value.set(size.width, size.height);
  });

  return (
    <mesh ref={meshRef} material={material}>
      <planeGeometry args={[size.width, size.height, 1]} />
    </mesh>
  );
};

type NumericString = `${number}`;

const App: React.FC<{
  vertexShaderPath?: string;
  fragmentShaderPath?: string;
  width?: NumericString;
  height?: NumericString;
}> = ({
  vertexShaderPath = "/assets/glsl/all.vert",
  fragmentShaderPath = "/assets/glsl/draft/1.frag",
  width = "45",
  height = "45",
}) => {
  const [vertexShader, setVertexShader] = useState("");
  const [fragmentShader, setFragmentShader] = useState("");
  const [mouse, setMouse] = useState({ x: 0, y: 0 });
  const canvas = useRef<HTMLCanvasElement>(null);

  const handleMouseMove = useCallback((event: MouseEvent) => {
    setMouse({ x: event.clientX, y: event.clientY });
  }, []);

  useEffect(() => {
    const canvasElement = canvas.current;
    if (canvasElement) {
      canvasElement.addEventListener("mousemove", handleMouseMove);
      return () =>
        canvasElement.removeEventListener("mousemove", handleMouseMove);
    }
  }, [handleMouseMove]);

  const loadShaders = useMemo(
    () => async () => {
      try {
        const [vertexRes, fragmentRes] = await Promise.all([
          fetch(vertexShaderPath),
          fetch(fragmentShaderPath),
        ]);

        if (vertexRes.ok && fragmentRes.ok) {
          const [vertexText, fragmentText] = await Promise.all([
            vertexRes.text(),
            fragmentRes.text(),
          ]);
          setVertexShader(vertexText);
          setFragmentShader(fragmentText);
        }
      } catch (error) {
        console.error("Error fetching shader files:", error);
      }
    },
    [vertexShaderPath, fragmentShaderPath]
  );

  useEffect(() => {
    loadShaders();
  }, [loadShaders]);

  return (
    <Canvas
      dpr={[1, 2]}
      className="m-auto my-2 border-blue-500 border-solid border-4"
      gl={{ antialias: false }}
      camera={{ position: [0, 0, 15], fov: 17.5, near: 1, far: 20 }}
      style={{ width: `${width}vw`, height: `${height}vw` }}
      ref={canvas}
    >
      <color attach="background" args={["black"]} />
      {vertexShader && fragmentShader && (
        <CustomShaderCube
          mouse={mouse}
          vertexShader={vertexShader}
          fragmentShader={fragmentShader}
        />
      )}
    </Canvas>
  );
};

export default App;
```

- 2024-12-06 ä¼˜åŒ–ä»£ç 

```tsx
import React, {
  useRef,
  useEffect,
  useState,
  useMemo,
  useCallback,
} from "react";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { ShaderMaterial } from "three";
import * as THREE from "three";

const CustomShaderCube: React.FC<{
  mouse: { x: number; y: number };
  vertexShader: string;
  fragmentShader: string;
}> = ({ mouse, vertexShader, fragmentShader }) => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);
  const meshRef = useRef<THREE.Mesh>(null);
  const { size, gl } = useThree();

  const material = useMemo<ShaderMaterial>(() => {
    return new ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2() },
        u_mouse: { value: new THREE.Vector2() },
      },
    });
  }, [vertexShader, fragmentShader]);

  useEffect(() => {
    return () => {
      material.dispose();
      geometry.dispose();
    };
  }, [material, geometry]);

  useEffect(() => {
    const pixelRatio = window.devicePixelRatio || 2;
    gl.setPixelRatio(pixelRatio);
    gl.setSize(size.width, size.height);
    material.uniforms.u_resolution.value.set(size.width, size.height);
  }, [size.width, size.height, gl, material]);

  useFrame(({ clock }) => {
    material.uniforms.u_time.value = clock.getElapsedTime();
    material.uniforms.u_mouse.value.set(mouse.x, mouse.y);
  });

  useEffect(() => {
    const canvas = gl.domElement;

    const handleContextLost = (event: Event) => {
      event.preventDefault();
      console.log("WebGL context lost. Attempting to restore...");
    };

    const handleContextRestored = () => {
      console.log("WebGL context restored");
      // é‡æ–°åˆå§‹åŒ–å¿…è¦çš„ WebGL èµ„æº
      gl.setPixelRatio(window.devicePixelRatio || 2);
      gl.setSize(size.width, size.height);
      material.uniforms.u_resolution.value.set(size.width, size.height);
    };

    canvas.addEventListener("webglcontextlost", handleContextLost);
    canvas.addEventListener("webglcontextrestored", handleContextRestored);

    return () => {
      canvas.removeEventListener("webglcontextlost", handleContextLost);
      canvas.removeEventListener("webglcontextrestored", handleContextRestored);
    };
  }, [gl, size, material]);

  useEffect(() => {
    if (meshRef.current) {
      meshRef.current.position.z = 0;
    }
  }, []);

  return <mesh ref={meshRef} material={material} geometry={geometry}></mesh>;
};

type NumericString = `${number}`;

const App: React.FC<{
  vertexShaderPath?: string;
  fragmentShaderPath?: string;
  width?: NumericString;
  height?: NumericString;
}> = ({
  vertexShaderPath = "/assets/glsl/all.vert",
  fragmentShaderPath = "/assets/glsl/draft/1.frag",
  width = "45",
  height = "45",
}) => {
  const [vertexShader, setVertexShader] = useState("");
  const [fragmentShader, setFragmentShader] = useState("");
  const [mouse, setMouse] = useState({ x: 0, y: 0 });
  const [isVisible, setIsVisible] = useState(false); // æ§åˆ¶å¯è§†çŠ¶æ€
  const canvasRef = useRef<HTMLDivElement>(null);

  const handleMouseMove = useCallback((event: MouseEvent) => {
    const { clientX, clientY } = event;
    setMouse({ x: clientX, y: clientY });
  }, []);

  useEffect(() => {
    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [handleMouseMove]);

  const loadShaders = useCallback(async () => {
    try {
      const [vertexRes, fragmentRes] = await Promise.all([
        fetch(vertexShaderPath),
        fetch(fragmentShaderPath),
      ]);

      if (!vertexRes.ok || !fragmentRes.ok) {
        throw new Error(
          `Failed to load shaders: ${vertexRes.status}, ${fragmentRes.status}`
        );
      }

      const [vertexText, fragmentText] = await Promise.all([
        vertexRes.text(),
        fragmentRes.text(),
      ]);

      setVertexShader(vertexText);
      setFragmentShader(fragmentText);
    } catch (error) {
      console.error("Error fetching shader files:", error);
    }
  }, [vertexShaderPath, fragmentShaderPath]);

  useEffect(() => {
    loadShaders();
  }, [loadShaders]);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsVisible(entry.isIntersecting);
      },
      { threshold: 0.1 } // æ§åˆ¶åœ¨ 10% å¯è§æ—¶è§¦å‘
    );

    if (canvasRef.current) {
      observer.observe(canvasRef.current);
    }

    return () => {
      if (canvasRef.current) {
        observer.unobserve(canvasRef.current);
      }
    };
  }, []);

  return (
    <div
      ref={canvasRef}
      style={{
        width: `${width}vw`,
        height: `${height}vw`,
        border: "4px solid blue",
        margin: "auto",
        marginTop: "2rem",
      }}
    >
      {isVisible && vertexShader && fragmentShader && (
        <Canvas
          dpr={[1, 2]}
          camera={{
            position: [0, 0, 1],
            fov: 45,
            near: 0.1,
            far: 1000,
          }}
          gl={{
            antialias: false,
            powerPreference: "high-performance",
            preserveDrawingBuffer: true,
            alpha: false,
            stencil: false,
          }}
          onCreated={({ gl }) => {
            gl.setClearColor("black");
          }}
        >
          <CustomShaderCube
            mouse={mouse}
            vertexShader={vertexShader}
            fragmentShader={fragmentShader}
          />
        </Canvas>
      )}
    </div>
  );
};

export default App;
```

- 2024-12-16 æ·»åŠ äº†u_texture

```tsx
import React, {
  useRef,
  useEffect,
  useState,
  useMemo,
  useCallback,
} from "react";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { ShaderMaterial, TextureLoader } from "three";
import * as THREE from "three";

const CustomShaderCube: React.FC<{
  mouse: { x: number; y: number };
  vertexShader: string;
  fragmentShader: string;
  texturePaths: string[];
}> = ({ mouse, vertexShader, fragmentShader, texturePaths }) => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);
  const material = useMemo(() => {
    const uniforms: Record<string, any> = {
      u_time: { value: 0 },
      u_resolution: { value: new THREE.Vector2() },
      u_mouse: { value: new THREE.Vector2() },
    };

    // Initialize uniforms for each texture
    texturePaths.forEach((_, index) => {
      uniforms[`u_texture${index}`] = { value: null };
    });

    return new ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms,
    });
  }, [vertexShader, fragmentShader]);

  const { size, gl } = useThree();

  useEffect(() => {
    const pixelRatio = window.devicePixelRatio || 2;
    gl.setPixelRatio(pixelRatio);
    gl.setSize(size.width, size.height);
    material.uniforms.u_resolution.value.set(size.width, size.height);

    // Load all textures
    if (texturePaths.length > 0) {
      const textureLoader = new TextureLoader();
      texturePaths.forEach((path, index) => {
        textureLoader.load(path, texture => {
          //ç¦æ­¢é‡å¤ repeat
          texture.wrapS = THREE.ClampToEdgeWrapping;
          texture.wrapT = THREE.ClampToEdgeWrapping;
          material.uniforms[`u_texture${index}`].value = texture;
        });
      });
    }
    return () => {
      material.dispose();
      geometry.dispose();
    };
  }, [size, gl, material, geometry]);

  useFrame(({ clock }) => {
    material.uniforms.u_time.value = clock.getElapsedTime();
    material.uniforms.u_mouse.value.set(mouse.x, mouse.y);
  });

  return <mesh material={material} geometry={geometry}></mesh>;
};

type NumericString = `${number}`;

const App: React.FC<{
  vertexShaderPath?: string;
  fragmentShaderPath?: string;
  width?: NumericString;
  height?: NumericString;
  imgPaths?: string;
}> = ({
  vertexShaderPath = "/assets/glsl/all.vert",
  fragmentShaderPath = "/assets/glsl/draft/1.frag",
  width = "45",
  height = "45",
  imgPaths = "",
}) => {
  const [shaders, setShaders] = useState({
    vertexShader: "",
    fragmentShader: "",
  });
  const [mouse, setMouse] = useState({ x: 0, y: 0 });
  const [isVisible, setIsVisible] = useState(false);
  const canvasRef = useRef<HTMLDivElement>(null);
  const texturePaths = imgPaths.split(",").map(path => path.trim());
  const [isLoading, setIsLoading] = useState(true);

  const handleMouseMove = useCallback((event: MouseEvent) => {
    setMouse({ x: event.clientX, y: event.clientY });
  }, []);
  const handleTouchMove = useCallback((event: TouchEvent) => {
    const touch = event.touches[0];
    setMouse({ x: touch.clientX, y: touch.clientY });
  }, []);
  const loadShaders = async () => {
    setIsLoading(true);
    try {
      const [vertexRes, fragmentRes] = await Promise.all([
        fetch(vertexShaderPath),
        fetch(fragmentShaderPath),
      ]);

      if (!vertexRes.ok || !fragmentRes.ok) {
        throw new Error(
          `Failed to load shaders: ${vertexRes.status}, ${fragmentRes.status}`
        );
      }

      const [vertexShader, fragmentShader] = await Promise.all([
        vertexRes.text(),
        fragmentRes.text(),
      ]);

      setShaders({ vertexShader, fragmentShader });
    } catch (error) {
      console.error("Error fetching shader files:", error);
    } finally {
      setIsLoading(false);
    }
  };
  useEffect(() => {
    loadShaders();
  }, [vertexShaderPath, fragmentShaderPath]);

  useEffect(() => {
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("touchmove", handleTouchMove);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("touchmove", handleTouchMove);
    };
  }, [handleMouseMove, handleTouchMove]);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => setIsVisible(entry.isIntersecting),
      { threshold: 0.1 }
    );

    if (canvasRef.current) observer.observe(canvasRef.current);

    return () => {
      if (canvasRef.current) observer.unobserve(canvasRef.current);
    };
  }, []);

  return (
    <div
      ref={canvasRef}
      style={{
        width: `${width}vw`,
        height: `${height}vw`,
        minWidth: `${width}vw`,
        minHeight: `${height}vw`,
        margin: "auto",
        boxShadow: "rgba(200, 211, 211, 0.2) 0px 7px 29px 0px",
        marginTop: "2rem",
        cursor: "pointer",
      }}
    >
      {isLoading || !isVisible ? (
        <div className="flex justify-center items-center h-full">
          Loading...
        </div>
      ) : (
        <Canvas
          dpr={[1, 2]}
          camera={{
            position: [0, 0, 1],
            fov: 45,
            near: 0.1,
            far: 1000,
          }}
          gl={{
            antialias: true,
            powerPreference: "high-performance",
            preserveDrawingBuffer: true,
            alpha: false,
            stencil: false,
          }}
          onCreated={({ gl }) => {
            const pixelRatio = window.devicePixelRatio || 2;
            gl.setPixelRatio(pixelRatio);
          }}
          className="w-full h-full"
        >
          <CustomShaderCube
            mouse={mouse}
            vertexShader={shaders.vertexShader}
            fragmentShader={shaders.fragmentShader}
            texturePaths={texturePaths}
          />
        </Canvas>
      )}
    </div>
  );
};

export default App;
```

- u_mouseé€»è¾‘

```tsx
const handleMouseMove = useCallback((event: MouseEvent) => {
  if (!canvasRef.current) return;

  const rect = canvasRef.current.getBoundingClientRect(); // è·å– Canvas çš„ä½ç½®å’Œå°ºå¯¸
  setMouse({
    x: (event.clientX - rect.left) / rect.width, // é¼ æ ‡ç›¸å¯¹äº Canvas çš„å½’ä¸€åŒ–åæ ‡
    y: 1 - (event.clientY - rect.top) / rect.height, // ç¿»è½¬ Y è½´
  });
}, []);

const handleTouchMove = useCallback((event: TouchEvent) => {
  if (!canvasRef.current) return;

  const touch = event.touches[0];
  const rect = canvasRef.current.getBoundingClientRect(); // è·å– Canvas çš„ä½ç½®å’Œå°ºå¯¸
  setMouse({
    x: (touch.clientX - rect.left) / rect.width, // é¼ æ ‡ç›¸å¯¹äº Canvas çš„å½’ä¸€åŒ–åæ ‡
    y: 1 - (touch.clientY - rect.top) / rect.height, // ç¿»è½¬ Y è½´
  });
}, []);
```

<CodeFromUrl
  lang="tsx"
  highlightLines="207"
  url="src/components/react/fiber/bookOfShader/templateFromUrl.tsx"
/>

</details>

## æ„Ÿæ…¨

æœ‰æ—¶è‡ªå·±ä¹Ÿä¸çŸ¥é“ä¼šå†™å‡ºæ¥ä»€ä¹ˆä¸œè¥¿,æˆ–è€…æŠ„çš„æŸä¸ªä¸œè¥¿è¢«è‡ªå·±é­”æ”¹æˆâ€œä¸å¯æ˜çŠ¶ç‰©â€

## é“¾æ¥

- [Book of Shaders](https://thebookofshaders.com/)
- [ryojiikeda](https://www.ryojiikeda.com/)
- [code demo](https://glslsandbox.com/)
- [glsl tool](https://fordhurley.com/glsl-grapher/)
