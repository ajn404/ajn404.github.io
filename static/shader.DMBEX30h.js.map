{"version":3,"file":"shader.DMBEX30h.js","sources":["../../src/components/react/fiber/WaveMaterial.ts","../../src/components/react/fiber/shader.tsx"],"sourcesContent":["import * as THREE from \"three\";\nimport { extend } from \"@react-three/fiber\";\nimport { shaderMaterial } from \"@react-three/drei\";\n\nconst WaveMaterial = shaderMaterial(\n  {\n    time: 0,\n    resolution: new THREE.Vector2(),\n    pointer: new THREE.Vector2(),\n  },\n  /*glsl*/ `\n      varying vec2 vUv;\n      void main() {\n        vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectionPosition = projectionMatrix * viewPosition;\n        gl_Position = projectionPosition;\n        vUv = uv;\n      }`,\n  /*glsl*/ `\n      uniform float time;\n      uniform vec2 resolution;\n      uniform vec2 pointer;\n      varying vec2 vUv;      \n\n      vec3 palette(float t) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.263, 0.416, 0.557);\n        return a + b * cos(6.28318 * (c * t + d));\n      }\n\n      void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;      \n        vec2 uv0 = uv;\n        vec3 finalColor = vec3(0.0);\n        uv = fract(uv * 1.5) - 0.5;     \n        uv = sin(uv * 0.5) - pointer;     \n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + time * 0.4);\n        d = sin(d * 8.0 + time) / 8.0;\n        d = abs(d);\n        d = pow(0.02 / d, 2.0);\n        finalColor += col * d;\n        gl_FragColor = vec4(finalColor, 1.0);   \n      }`\n);\n\nextend({ WaveMaterial });\n\nexport { WaveMaterial };\n","// @ts-nocheck\nimport { useRef } from \"react\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport { WaveMaterial } from \"./WaveMaterial\";\nimport { easing } from \"maath\";\n\nfunction ShaderPlane() {\n  const ref = useRef();\n  const { viewport, size } = useThree();\n  useFrame((state, delta) => {\n    ref.current.time += delta;\n    easing.damp3(ref.current.pointer, state.pointer, 0.2, delta);\n  });\n  return (\n    <mesh scale={[viewport.width, viewport.height, 1]}>\n      <planeGeometry />\n      <waveMaterial\n        ref={ref}\n        key={WaveMaterial.key}\n        resolution={[size.width * viewport.dpr, size.height * viewport.dpr]}\n      />\n    </mesh>\n  );\n}\n\nexport default function App() {\n  return (\n    <Canvas style={{ height: \"300px\", margin: \"auto\" }}>\n      <ShaderPlane />\n    </Canvas>\n  );\n}\n"],"names":["WaveMaterial","shaderMaterial","THREE.Vector2","extend","ShaderPlane","ref","useRef","viewport","size","useThree","useFrame","state","delta","easing","jsxs","jsx","App","Canvas"],"mappings":"+uBAIA,MAAMA,EAAeC,EACnB,CACE,KAAM,EACN,WAAY,IAAIC,EAChB,QAAS,IAAIA,CACf,EACS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QA4BX,EAEAC,EAAO,CAAE,aAAAH,EAAc,EC3CvB,SAASI,GAAc,CACrB,MAAMC,EAAMC,EAAAA,OAAO,EACb,CAAE,SAAAC,EAAU,KAAAC,CAAK,EAAIC,EAAS,EAC3B,OAAAC,EAAA,CAACC,EAAOC,IAAU,CACzBP,EAAI,QAAQ,MAAQO,EACpBC,EAAO,MAAMR,EAAI,QAAQ,QAASM,EAAM,QAAS,GAAKC,CAAK,CAAA,CAC5D,EAECE,OAAC,QAAK,MAAO,CAACP,EAAS,MAAOA,EAAS,OAAQ,CAAC,EAC9C,SAAA,CAAAQ,EAAA,IAAC,gBAAc,EAAA,EACfA,EAAA,IAAC,eAAA,CACC,IAAAV,EAEA,WAAY,CAACG,EAAK,MAAQD,EAAS,IAAKC,EAAK,OAASD,EAAS,GAAG,CAAA,EAD7DP,EAAa,GAAA,CAEpB,EACF,CAEJ,CAEA,SAAwBgB,GAAM,CAE1B,OAAAD,EAAA,IAACE,EAAO,CAAA,MAAO,CAAE,OAAQ,QAAS,OAAQ,MAAO,EAC/C,SAACF,EAAAA,IAAAX,EAAA,CAAA,CAAY,CACf,CAAA,CAEJ"}