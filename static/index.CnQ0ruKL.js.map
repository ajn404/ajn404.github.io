{"version":3,"file":"index.CnQ0ruKL.js","sources":["../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/version.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-extended-exponential-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-extended-linear-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-set-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-set-value-curve-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-target-value-at-time.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/exponential-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/linear-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/any-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/set-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/set-value-curve-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-value-of-automation-event-at-index-at-time.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-end-time-and-value-of-previous-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/cancel-and-hold-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/cancel-scheduled-values-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-event-time.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-exponential-ramp-value-at-time.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-linear-ramp-value-at-time.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/interpolate-value.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/get-value-curve-value-at-time.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/guards/set-target-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/classes/automation-event-list.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-cancel-and-hold-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-cancel-scheduled-values-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-exponential-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-linear-ramp-to-value-automation-event.js","../../node_modules/.pnpm/automation-events@7.1.10/node_modules/automation-events/build/es2019/functions/create-set-target-automation-event.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/globals.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/constants.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/gain-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/read-only-map.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/guards/delay-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/window.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","../../node_modules/.pnpm/standardized-audio-context@25.3.77/node_modules/standardized-audio-context/build/es2019/module.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/TypeCheck.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Debug.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/AudioContext.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/Ticker.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Defaults.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/Tone.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Math.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Timeline.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/ContextInitialization.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Emitter.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/BaseContext.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/Context.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/DummyContext.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Interface.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/OfflineContext.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/Global.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/type/Conversions.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/type/TimeBase.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/type/Time.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/type/Frequency.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/type/TransportTime.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/ToneWithContext.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/StateTimeline.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/Param.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/Gain.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/OneShotSource.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/ToneConstantSource.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/Signal.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/TickParam.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/TickSignal.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/TickSource.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/Clock.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/channel/Volume.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/Destination.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/Listener.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/type/Ticks.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Draw.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/IntervalTimeline.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/TimelineValue.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/SignalOperator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/WaveShaper.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/Pow.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/TransportEvent.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/clock/Transport.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/Source.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/Oscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/AudioToGain.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/signal/Multiply.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/AMOscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/FMOscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/PulseOscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/FatOscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/PWMOscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/util/Decorator.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/source/buffer/Player.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/envelope/Envelope.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/instrument/Instrument.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/instrument/Monophonic.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/instrument/Synth.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/instrument/MembraneSynth.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/instrument/Sampler.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/channel/Panner.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/effect/BitCrusher.worklet.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/channel/Solo.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/channel/PanVol.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/component/channel/Channel.js","../../node_modules/.pnpm/tone@15.1.22/node_modules/tone/build/esm/index.js"],"sourcesContent":["export const version = \"15.1.22\";\n//# sourceMappingURL=version.js.map","export const createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {\n    return { endTime, insertTime, type: 'exponentialRampToValue', value };\n};\n//# sourceMappingURL=create-extended-exponential-ramp-to-value-automation-event.js.map","export const createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {\n    return { endTime, insertTime, type: 'linearRampToValue', value };\n};\n//# sourceMappingURL=create-extended-linear-ramp-to-value-automation-event.js.map","export const createSetValueAutomationEvent = (value, startTime) => {\n    return { startTime, type: 'setValue', value };\n};\n//# sourceMappingURL=create-set-value-automation-event.js.map","export const createSetValueCurveAutomationEvent = (values, startTime, duration) => {\n    return { duration, startTime, type: 'setValueCurve', values };\n};\n//# sourceMappingURL=create-set-value-curve-automation-event.js.map","export const getTargetValueAtTime = (time, valueAtStartTime, { startTime, target, timeConstant }) => {\n    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n};\n//# sourceMappingURL=get-target-value-at-time.js.map","export const isExponentialRampToValueAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'exponentialRampToValue';\n};\n//# sourceMappingURL=exponential-ramp-to-value-automation-event.js.map","export const isLinearRampToValueAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'linearRampToValue';\n};\n//# sourceMappingURL=linear-ramp-to-value-automation-event.js.map","import { isExponentialRampToValueAutomationEvent } from './exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from './linear-ramp-to-value-automation-event';\nexport const isAnyRampToValueAutomationEvent = (automationEvent) => {\n    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n};\n//# sourceMappingURL=any-ramp-to-value-automation-event.js.map","export const isSetValueAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'setValue';\n};\n//# sourceMappingURL=set-value-automation-event.js.map","export const isSetValueCurveAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'setValueCurve';\n};\n//# sourceMappingURL=set-value-curve-automation-event.js.map","import { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport const getValueOfAutomationEventAtIndexAtTime = (automationEvents, index, time, defaultValue) => {\n    const automationEvent = automationEvents[index];\n    return automationEvent === undefined\n        ? defaultValue\n        : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent)\n            ? automationEvent.value\n            : isSetValueCurveAutomationEvent(automationEvent)\n                ? automationEvent.values[automationEvent.values.length - 1]\n                : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n};\n//# sourceMappingURL=get-value-of-automation-event-at-index-at-time.js.map","import { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport const getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) => {\n    return currentAutomationEvent === undefined\n        ? [nextAutomationEvent.insertTime, defaultValue]\n        : isAnyRampToValueAutomationEvent(currentAutomationEvent)\n            ? [currentAutomationEvent.endTime, currentAutomationEvent.value]\n            : isSetValueAutomationEvent(currentAutomationEvent)\n                ? [currentAutomationEvent.startTime, currentAutomationEvent.value]\n                : isSetValueCurveAutomationEvent(currentAutomationEvent)\n                    ? [\n                        currentAutomationEvent.startTime + currentAutomationEvent.duration,\n                        currentAutomationEvent.values[currentAutomationEvent.values.length - 1]\n                    ]\n                    : [\n                        currentAutomationEvent.startTime,\n                        getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)\n                    ];\n};\n//# sourceMappingURL=get-end-time-and-value-of-previous-automation-event.js.map","export const isCancelAndHoldAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'cancelAndHold';\n};\n//# sourceMappingURL=cancel-and-hold-automation-event.js.map","export const isCancelScheduledValuesAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'cancelScheduledValues';\n};\n//# sourceMappingURL=cancel-scheduled-values-automation-event.js.map","import { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nexport const getEventTime = (automationEvent) => {\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n    }\n    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n    }\n    return automationEvent.startTime;\n};\n//# sourceMappingURL=get-event-time.js.map","export const getExponentialRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {\n    if (valueAtStartTime === value) {\n        return value;\n    }\n    if ((0 < valueAtStartTime && 0 < value) || (valueAtStartTime < 0 && value < 0)) {\n        return valueAtStartTime * (value / valueAtStartTime) ** ((time - startTime) / (endTime - startTime));\n    }\n    return 0;\n};\n//# sourceMappingURL=get-exponential-ramp-value-at-time.js.map","export const getLinearRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {\n    return valueAtStartTime + ((time - startTime) / (endTime - startTime)) * (value - valueAtStartTime);\n};\n//# sourceMappingURL=get-linear-ramp-value-at-time.js.map","export const interpolateValue = (values, theoreticIndex) => {\n    const lowerIndex = Math.floor(theoreticIndex);\n    const upperIndex = Math.ceil(theoreticIndex);\n    if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n    }\n    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n};\n//# sourceMappingURL=interpolate-value.js.map","import { interpolateValue } from './interpolate-value';\nexport const getValueCurveValueAtTime = (time, { duration, startTime, values }) => {\n    const theoreticIndex = ((time - startTime) / duration) * (values.length - 1);\n    return interpolateValue(values, theoreticIndex);\n};\n//# sourceMappingURL=get-value-curve-value-at-time.js.map","export const isSetTargetAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'setTarget';\n};\n//# sourceMappingURL=set-target-automation-event.js.map","import { createExtendedExponentialRampToValueAutomationEvent } from '../functions/create-extended-exponential-ramp-to-value-automation-event';\nimport { createExtendedLinearRampToValueAutomationEvent } from '../functions/create-extended-linear-ramp-to-value-automation-event';\nimport { createSetValueAutomationEvent } from '../functions/create-set-value-automation-event';\nimport { createSetValueCurveAutomationEvent } from '../functions/create-set-value-curve-automation-event';\nimport { getEndTimeAndValueOfPreviousAutomationEvent } from '../functions/get-end-time-and-value-of-previous-automation-event';\nimport { getEventTime } from '../functions/get-event-time';\nimport { getExponentialRampValueAtTime } from '../functions/get-exponential-ramp-value-at-time';\nimport { getLinearRampValueAtTime } from '../functions/get-linear-ramp-value-at-time';\nimport { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { getValueCurveValueAtTime } from '../functions/get-value-curve-value-at-time';\nimport { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nimport { isSetTargetAutomationEvent } from '../guards/set-target-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport class AutomationEventList {\n    constructor(defaultValue) {\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n    }\n    [Symbol.iterator]() {\n        return this._automationEvents[Symbol.iterator]();\n    }\n    add(automationEvent) {\n        const eventTime = getEventTime(automationEvent);\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => {\n                if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                    return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n                }\n                return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            const removedAutomationEvent = this._automationEvents[index];\n            if (index !== -1) {\n                this._automationEvents = this._automationEvents.slice(0, index);\n            }\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n                const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n                if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                    if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                        throw new Error('The internal list is malformed.');\n                    }\n                    const startTime = lastAutomationEvent === undefined\n                        ? removedAutomationEvent.insertTime\n                        : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.startTime + lastAutomationEvent.duration\n                            : getEventTime(lastAutomationEvent);\n                    const startValue = lastAutomationEvent === undefined\n                        ? this._defaultValue\n                        : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1]\n                            : lastAutomationEvent.value;\n                    const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent)\n                        : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                    const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime)\n                        : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n                    this._automationEvents.push(truncatedAutomationEvent);\n                }\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                    this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n                }\n                if (lastAutomationEvent !== undefined &&\n                    isSetValueCurveAutomationEvent(lastAutomationEvent) &&\n                    lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                    const duration = eventTime - lastAutomationEvent.startTime;\n                    const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                    const length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                    const fraction = (duration / (length - 1)) * ratio;\n                    const values = lastAutomationEvent.values.slice(0, length);\n                    if (fraction < 1) {\n                        for (let i = 1; i < length; i += 1) {\n                            const factor = (fraction * i) % 1;\n                            values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                        }\n                    }\n                    this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n                }\n            }\n        }\n        else {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);\n            const previousAutomationEvent = index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];\n            if (previousAutomationEvent !== undefined &&\n                isSetValueCurveAutomationEvent(previousAutomationEvent) &&\n                getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n                return false;\n            }\n            const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent)\n                ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime)\n                : isLinearRampToValueAutomationEvent(automationEvent)\n                    ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime)\n                    : automationEvent;\n            if (index === -1) {\n                this._automationEvents.push(persistentAutomationEvent);\n            }\n            else {\n                if (isSetValueCurveAutomationEvent(automationEvent) &&\n                    eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])) {\n                    return false;\n                }\n                this._automationEvents.splice(index, 0, persistentAutomationEvent);\n            }\n        }\n        return true;\n    }\n    flush(time) {\n        const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);\n        if (index > 1) {\n            const remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            const firstRemainingAutomationEvent = remainingAutomationEvents[0];\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n                remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n            this._automationEvents = remainingAutomationEvents;\n        }\n    }\n    getValue(time) {\n        if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n        }\n        const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);\n        const nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n        const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n        const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n        if (currentAutomationEvent !== undefined &&\n            isSetTargetAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n        }\n        if (currentAutomationEvent !== undefined &&\n            isSetValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n        }\n        if (currentAutomationEvent !== undefined &&\n            isSetValueCurveAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n                return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n        if (currentAutomationEvent !== undefined &&\n            isAnyRampToValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n        }\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n            return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n        return this._defaultValue;\n    }\n}\n//# sourceMappingURL=automation-event-list.js.map","export const createCancelAndHoldAutomationEvent = (cancelTime) => {\n    return { cancelTime, type: 'cancelAndHold' };\n};\n//# sourceMappingURL=create-cancel-and-hold-automation-event.js.map","export const createCancelScheduledValuesAutomationEvent = (cancelTime) => {\n    return { cancelTime, type: 'cancelScheduledValues' };\n};\n//# sourceMappingURL=create-cancel-scheduled-values-automation-event.js.map","export const createExponentialRampToValueAutomationEvent = (value, endTime) => {\n    return { endTime, type: 'exponentialRampToValue', value };\n};\n//# sourceMappingURL=create-exponential-ramp-to-value-automation-event.js.map","export const createLinearRampToValueAutomationEvent = (value, endTime) => {\n    return { endTime, type: 'linearRampToValue', value };\n};\n//# sourceMappingURL=create-linear-ramp-to-value-automation-event.js.map","export const createSetTargetAutomationEvent = (target, startTime, timeConstant) => {\n    return { startTime, target, timeConstant, type: 'setTarget' };\n};\n//# sourceMappingURL=create-set-target-automation-event.js.map","export const createAbortError = () => new DOMException('', 'AbortError');\n//# sourceMappingURL=abort-error.js.map","export const createAddActiveInputConnectionToAudioNode = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n    };\n};\n//# sourceMappingURL=add-active-input-connection-to-audio-node.js.map","export const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n    return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n        const activeInputs = [];\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n//# sourceMappingURL=add-audio-node-connections.js.map","export const createAddAudioParamConnections = (audioParamConnectionsStore) => {\n    return (audioParam, audioParamRenderer) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n//# sourceMappingURL=add-audio-param-connections.js.map","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\n//# sourceMappingURL=globals.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {\n    let index = 0;\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const nativeContext = getNativeContext(context);\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise = nativeContext.audioWorklet === undefined\n            ? fetchSource(moduleURL)\n                .then(([source, absoluteUrl]) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * ${ importStatements };\n                 * ((a, b) => {\n                 *     (a[b] = a[b] || [ ]).push(\n                 *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                 *             ${ sourceWithoutImportStatements }\n                 *         }\n                 *     );\n                 * })(window, '_AWGS');\n                 * ```\n                 */\n                // tslint:disable-next-line:max-line-length\n                const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n                // @todo Evaluating the given source code is a possible security problem.\n                return evaluateSource(wrappedSource);\n            })\n                .then(() => {\n                const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n                if (evaluateAudioWorkletGlobalScope === undefined) {\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    throw new SyntaxError();\n                }\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n                }, undefined, (name, processorCtor) => {\n                    if (name.trim() === '') {\n                        throw createNotSupportedError();\n                    }\n                    const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                    if (nodeNameToProcessorConstructorMap !== undefined) {\n                        if (nodeNameToProcessorConstructorMap.has(name)) {\n                            throw createNotSupportedError();\n                        }\n                        verifyProcessorCtor(processorCtor);\n                        verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                        nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                    }\n                    else {\n                        verifyProcessorCtor(processorCtor);\n                        verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                        NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                    }\n                }, nativeContext.sampleRate, undefined, undefined));\n            })\n            : Promise.all([\n                fetchSource(moduleURL),\n                Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))\n            ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                const currentIndex = index + 1;\n                index = currentIndex;\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * This is the unminified version of the code used below.\n                 *\n                 * ```js\n                 * class extends AudioWorkletProcessor {\n                 *\n                 *     __buffers = new WeakSet();\n                 *\n                 *     constructor () {\n                 *         super();\n                 *\n                 *         this.port.postMessage = ((postMessage) => {\n                 *             return (message, transferables) => {\n                 *                 const filteredTransferables = (transferables)\n                 *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                 *                     : transferables;\n                 *\n                 *                 return postMessage.call(this.port, message, filteredTransferables);\n                 *              };\n                 *         })(this.port.postMessage);\n                 *     }\n                 * }\n                 * ```\n                 */\n                const patchedAudioWorkletProcessor = isSupportingPostMessage\n                    ? 'AudioWorkletProcessor'\n                    : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                /*\n                 * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                 *\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })(\n                 *     ${ patchedAudioWorkletProcessor },\n                 *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *         __collectBuffers = (array) => {\n                 *             array.forEach((element) => this.__buffers.add(element.buffer));\n                 *         };\n                 *\n                 *         process (inputs, outputs, parameters) {\n                 *             inputs.forEach(this.__collectBuffers);\n                 *             outputs.forEach(this.__collectBuffers);\n                 *             this.__collectBuffers(Object.values(parameters));\n                 *\n                 *             return super.process(\n                 *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *                 outputs,\n                 *                 parameters\n                 *             );\n                 *         }\n                 *\n                 *     })\n                 * );\n                 *\n                 * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                 *\n                 *     process () {\n                 *         return false;\n                 *     }\n                 *\n                 * })`\n                 * ```\n                 */\n                const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                const bufferRegistration = isSupportingPostMessage\n                    ? ''\n                    : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                return nativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => {\n                    if (isNativeOfflineAudioContext(nativeContext)) {\n                        return nativeContext;\n                    }\n                    // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                    const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n                    return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                })\n                    .then((nativeContextOrBackupOfflineAudioContext) => {\n                    if (nativeAudioWorkletNodeConstructor === null) {\n                        throw new SyntaxError();\n                    }\n                    try {\n                        // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                        new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                    }\n                    catch {\n                        throw new SyntaxError();\n                    }\n                })\n                    .finally(() => URL.revokeObjectURL(url));\n            });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n            if (updatedResolvedRequestsOfContext === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                updatedResolvedRequestsOfContext.add(moduleURL);\n            }\n        })\n            .finally(() => {\n            const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n            if (updatedOngoingRequestsOfContext !== undefined) {\n                updatedOngoingRequestsOfContext.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=add-audio-worklet-module.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=get-value-for-key.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=pick-element-from-set.js.map","import { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\nexport const deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\n//# sourceMappingURL=delete-passive-input-connection-to-audio-node.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = (audioNode) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n//# sourceMappingURL=set-internal-state-to-active.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=audio-worklet-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = (audioNode) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n//# sourceMappingURL=set-internal-state-to-passive.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=set-internal-state-to-passive-when-necessary.js.map","import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nexport const createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) => {\n    const tailTimeTimeoutIds = new WeakMap();\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n        const eventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            }\n            else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n                const tailTime = getAudioNodeTailTime(destination);\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                }\n                else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n                    tailTimeTimeoutIds.set(destination, setTimeout(() => {\n                        if (isActiveAudioNode(destination)) {\n                            setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                        }\n                    }, tailTime * 1000));\n                }\n            }\n        };\n        if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n            eventListeners.add(eventListener);\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            }\n            else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=add-connection-to-audio-node.js.map","export const createAddPassiveInputConnectionToAudioNode = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        }\n        else {\n            insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n        }\n    };\n};\n//# sourceMappingURL=add-passive-input-connection-to-audio-node.js.map","export const createAddSilentConnection = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n//# sourceMappingURL=add-silent-connection.js.map","export const createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=add-unrendered-audio-worklet-node.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class AnalyserNode extends audionNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null));\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=analyser-node-constructor.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=is-owned-by-context.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=analyser-node-renderer-factory.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","export const createIndexSizeError = () => new DOMException('', 'IndexSizeError');\n//# sourceMappingURL=index-size-error.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=wrap-audio-buffer-get-channel-data-method.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-constructor.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=constants.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n//# sourceMappingURL=is-active-audio-node.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class AudioBufferSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline ? createAudioBufferSourceNodeRenderer() : null));\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-renderer-factory.js.map","export const isAudioBufferSourceNode = (audioNode) => {\n    return 'playbackRate' in audioNode;\n};\n//# sourceMappingURL=audio-buffer-source-node.js.map","export const isBiquadFilterNode = (audioNode) => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n//# sourceMappingURL=biquad-filter-node.js.map","export const isConstantSourceNode = (audioNode) => {\n    return 'offset' in audioNode;\n};\n//# sourceMappingURL=constant-source-node.js.map","export const isGainNode = (audioNode) => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n//# sourceMappingURL=gain-node.js.map","export const isOscillatorNode = (audioNode) => {\n    return 'detune' in audioNode && 'frequency' in audioNode && !('gain' in audioNode);\n};\n//# sourceMappingURL=oscillator-node.js.map","export const isStereoPannerNode = (audioNode) => {\n    return 'pan' in audioNode;\n};\n//# sourceMappingURL=stereo-panner-node.js.map","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n//# sourceMappingURL=get-audio-node-connections.js.map","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n//# sourceMappingURL=get-audio-param-connections.js.map","import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\nexport const deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n    activeInputs.forEach((connections) => connections.forEach(([source]) => {\n        if (!trace.includes(audioNode)) {\n            deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n        }\n    }));\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n            // Bug #149: Safari does not yet support the detune AudioParam.\n            audioNode.playbackRate\n        ]\n        : isAudioWorkletNode(audioNode)\n            ? Array.from(audioNode.parameters.values())\n            : isBiquadFilterNode(audioNode)\n                ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n                : isConstantSourceNode(audioNode)\n                    ? [audioNode.offset]\n                    : isGainNode(audioNode)\n                        ? [audioNode.gain]\n                        : isOscillatorNode(audioNode)\n                            ? [audioNode.detune, audioNode.frequency]\n                            : isStereoPannerNode(audioNode)\n                                ? [audioNode.pan]\n                                : [];\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=deactivate-active-audio-node-input-connections.js.map","import { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\nexport const deactivateAudioGraph = (context) => {\n    deactivateActiveAudioNodeInputConnections(context.destination, []);\n};\n//# sourceMappingURL=deactivate-audio-graph.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return (latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback')));\n};\n//# sourceMappingURL=is-valid-latency-hint.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            let nativeAudioContext;\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            }\n            catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                        ? 512 / sampleRate\n                        : latencyHint === 'interactive' || latencyHint === undefined\n                            ? 256 / sampleRate\n                            : latencyHint === 'playback'\n                                ? 1024 / sampleRate\n                                : /*\n                                   * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                                   * ScriptProcessorNode.\n                                   */\n                                    (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n                this._nativeGainNode.gain.value = 1e-37;\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            }\n            else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n                deactivateAudioGraph(this);\n            });\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamDestination() {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=audio-context-constructor.js.map","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null));\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=audio-destination-node-constructor.js.map","export const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap();\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext) {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n//# sourceMappingURL=audio-destination-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n                isScriptProcessorNodeCreated = true;\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                        lastOrientation = orientation;\n                    }\n                    const positon = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                        lastPosition = positon;\n                    }\n                };\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index) => (value) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index) => (value) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input, initialValue, setValue) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return initialValue;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n                overwriteAccessors(audioParam, 'value', (get) => () => get.call(audioParam), (set) => (value) => {\n                    try {\n                        set.call(audioParam, value);\n                    }\n                    catch (err) {\n                        if (err.code !== 9) {\n                            throw err;\n                        }\n                    }\n                    createScriptProcessorNode();\n                    if (isOffline) {\n                        // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                        setValue(value);\n                    }\n                });\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n                return audioParam;\n            };\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-listener-factory.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=audio-node.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=audio-node-output-connection.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=insert-element-in-set.js.map","import { insertElementInSet } from './insert-element-in-set';\nexport const addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n//# sourceMappingURL=add-active-input-connection-to-audio-param.js.map","import { insertElementInSet } from './insert-element-in-set';\nexport const addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);\n    }\n};\n//# sourceMappingURL=add-passive-input-connection-to-audio-param.js.map","export const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n//# sourceMappingURL=native-audio-node-faker.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=connect-native-audio-node-to-native-audio-node.js.map","export const deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\n//# sourceMappingURL=delete-active-input-connection.js.map","import { pickElementFromSet } from './pick-element-from-set';\nexport const deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n//# sourceMappingURL=delete-active-input-connection-to-audio-param.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n//# sourceMappingURL=delete-event-listeners-of-audio-node.js.map","import { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\nexport const deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\n//# sourceMappingURL=delete-passive-input-connection-to-audio-param.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=disconnect-native-audio-node-from-native-audio-node.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=get-native-audio-node.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=get-native-audio-param.js.map","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n//# sourceMappingURL=is-part-of-a-cycle.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=is-passive-audio-node.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor) => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        }\n        else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n            channelData[0] = 1;\n            channelData[1] = 1;\n            const source = nativeAudioContext.createBufferSource();\n            source.buffer = ones;\n            source.loop = true;\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n                if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                    resolve(true);\n                }\n                else {\n                    resolve(false);\n                }\n                source.stop();\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n            source.start();\n        }\n    });\n};\n//# sourceMappingURL=test-audio-node-disconnect-method-support.js.map","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n    const counts = new Map();\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n//# sourceMappingURL=visit-each-audio-node-once.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=native-audio-node.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination, output = 0, input = 0) => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === undefined));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=wrap-audio-node-disconnect-method.js.map","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source, isOffline) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => outputConnection[0] === destination &&\n        (output === undefined || outputConnection[1] === output) &&\n        (input === undefined || outputConnection[2] === input))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) => {\n    return class AudioNode extends eventTargetConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        // tslint:disable-next-line:invalid-void\n        connect(destination, output = 0, input = 0) {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    const isPassive = isPassiveAudioNode(this);\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err;\n                }\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-node-constructor.js.map","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return defaultValue;\n            },\n            get maxValue() {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array.from(automationEventList).pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n                const currentTime = audioNode.context.currentTime;\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                const currentTime = audioNode.context.currentTime;\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=audio-param-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-param-renderer.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=read-only-map.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options) {\n            var _a;\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed'\n                ? nativeContext\n                : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null));\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n            const { activeInputs } = getAudioNodeConnections(this);\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=audio-worklet-node-constructor.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=copy-from-channel.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=copy-to-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = typeof y === 'number' ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=create-nested-arrays.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=get-audio-worklet-processor.js.map","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n            }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                        addModule: (moduleURL, options) => {\n                            return addAudioWorkletModule(this, moduleURL, options);\n                        }\n                    };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData).then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            }, (err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=base-audio-context-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class BiquadFilterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = (isOffline ? createBiquadFilterNodeRenderer() : null);\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            }\n            catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=biquad-filter-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=biquad-filter-node-renderer-factory.js.map","export const createCacheTestResult = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        try {\n            const synchronousTestResult = test();\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                    ongoingTests.delete(tester);\n                    testResults.set(tester, finalTestResult);\n                    return finalTestResult;\n                });\n            }\n            testResults.set(tester, synchronousTestResult);\n            return synchronousTestResult;\n        }\n        catch {\n            testResults.set(tester, false);\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=cache-test-result.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ChannelMergerNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null));\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=channel-merger-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=channel-merger-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nexport const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions) => {\n    return class ChannelSplitterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null));\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=channel-splitter-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=channel-splitter-node-renderer-factory.js.map","export const createConnectAudioParam = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n//# sourceMappingURL=connect-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=connect-multiple-outputs.js.map","export const createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n//# sourceMappingURL=connected-native-audio-buffer-source-node-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class ConstantSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline ? createConstantSourceNodeRendererFactory() : null));\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=constant-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=constant-source-node-renderer-factory.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=convert-number-to-unsigned-long.js.map","const DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class ConvolverNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = (isOffline ? createConvolverNodeRenderer() : null);\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n                setAudioNodeTailTime(this, 0);\n            }\n            else {\n                this._isBufferNullified = false;\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=convolver-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            }\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=convolver-node-renderer-factory.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err;\n        }\n    };\n};\n//# sourceMappingURL=create-native-offline-audio-context.js.map","export const createDataCloneError = () => new DOMException('', 'DataCloneError');\n//# sourceMappingURL=data-clone-error.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1, port2 } = new MessageChannel();\n    return new Promise((resolve) => {\n        const closeAndResolve = () => {\n            port2.onmessage = null;\n            port1.close();\n            port2.close();\n            resolve();\n        };\n        port2.onmessage = () => closeAndResolve();\n        try {\n            port1.postMessage(arrayBuffer, [arrayBuffer]);\n        }\n        catch {\n            // Ignore errors.\n        }\n        finally {\n            closeAndResolve();\n        }\n    });\n};\n//# sourceMappingURL=detach-array-buffer.js.map","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                detachArrayBuffer(audioData).catch(() => {\n                    // Ignore errors.\n                });\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = async () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    await detachArrayBuffer(audioData);\n                }\n                catch {\n                    // Ignore errors.\n                }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete().then(() => resolve(audioBuffer));\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=decode-audio-data.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    }\n                    else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        }\n        else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n//# sourceMappingURL=decrement-cycle-counter.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class DelayNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = (isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=delay-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=delay-node-renderer-factory.js.map","export const createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n    };\n};\n//# sourceMappingURL=delete-active-input-connection-to-audio-node.js.map","export const createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=delete-unrendered-audio-worklet-node.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=delay-node.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=detect-cycles.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=disconnect-multiple-outputs.js.map","const DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class DynamicsCompressorNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = (isOffline ? createDynamicsCompressorNodeRenderer() : null);\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n            setAudioNodeTailTime(this, 0.006);\n        }\n        get attack() {\n            return this._attack;\n        }\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=dynamics-compressor-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=dynamics-compressor-node-renderer-factory.js.map","export const createEncodingError = () => new DOMException('', 'EncodingError');\n//# sourceMappingURL=encoding-error.js.map","export const createEvaluateSource = (window) => {\n    return (source) => new Promise((resolve, reject) => {\n        if (window === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n            return;\n        }\n        const head = window.document.head;\n        if (head === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n        }\n        else {\n            const script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=evaluate-source.js.map","export const createEventTargetConstructor = (wrapEventListener) => {\n    return class EventTarget {\n        constructor(_nativeEventTarget) {\n            this._nativeEventTarget = _nativeEventTarget;\n            this._listeners = new WeakMap();\n        }\n        addEventListener(type, listener, options) {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n        dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n        removeEventListener(type, listener, options) {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n//# sourceMappingURL=event-target-constructor.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=expose-current-frame-and-current-time.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        }\n        catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=fetch-source.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class GainNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = (isOffline ? createGainNodeRenderer() : null);\n            super(context, false, nativeGainNode, gainNodeRenderer);\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=gain-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=gain-node-renderer-factory.js.map","export const createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore, getValueForKey) => {\n    return (nativeAudioWorkletNode) => getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=get-active-audio-worklet-node-inputs.js.map","export const createGetAudioNodeRenderer = (getAudioNodeConnections) => {\n    return (audioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n    };\n};\n//# sourceMappingURL=get-audio-node-renderer.js.map","export const createGetAudioNodeTailTime = (audioNodeTailTimeStore) => {\n    return (audioNode) => { var _a; return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0; };\n};\n//# sourceMappingURL=get-audio-node-tail-time.js.map","export const createGetAudioParamRenderer = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n    };\n};\n//# sourceMappingURL=get-audio-param-renderer.js.map","export const createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n//# sourceMappingURL=get-backup-offline-audio-context.js.map","export const createInvalidStateError = () => new DOMException('', 'InvalidStateError');\n//# sourceMappingURL=invalid-state-error.js.map","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = (contextStore) => {\n    return (context) => {\n        const nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n        return (nativeContext);\n    };\n};\n//# sourceMappingURL=get-native-context.js.map","export const createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n        return backupOfflineAudioContext;\n    };\n};\n//# sourceMappingURL=get-or-create-backup-offline-audio-context.js.map","export const createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n    };\n};\n//# sourceMappingURL=get-unrendered-audio-worklet-nodes.js.map","export const createInvalidAccessError = () => new DOMException('', 'InvalidAccessError');\n//# sourceMappingURL=invalid-access-error.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=wrap-iir-filter-node-get-frequency-response-method.js.map","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class IIRFilterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null));\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=iir-filter-node-constructor.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=filter-buffer.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=iir-filter-node-renderer-factory.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                        }\n                        else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n                cycleCounters.set(audioNode, count);\n            }\n            else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n//# sourceMappingURL=increment-cycle-counter-factory.js.map","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n//# sourceMappingURL=is-any-audio-context.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=is-any-audio-param.js.map","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=is-any-offline-audio-context.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=is-native-audio-context.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n//# sourceMappingURL=is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n//# sourceMappingURL=is-native-audio-param.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=is-native-context.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=is-native-offline-audio-context.js.map","export const createIsSecureContext = (window) => window !== null && window.isSecureContext;\n//# sourceMappingURL=is-secure-context.js.map","export const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaElementAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n            super(context, true, nativeMediaElementAudioSourceNode, null);\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=media-element-audio-source-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n};\nexport const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n            super(context, false, nativeMediaStreamAudioDestinationNode, null);\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n        get stream() {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n//# sourceMappingURL=media-stream-audio-destination-node-constructor.js.map","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            super(context, true, nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=media-stream-audio-source-node-constructor.js.map","export const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {\n    return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=media-stream-track-audio-source-node-constructor.js.map","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n    return class MinimalBaseAudioContext extends eventTargetConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=minimal-base-audio-context-constructor.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=test-promise-support.js.map","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set();\n        nativeAudioNode.connect = ((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination, output = 0, input = 0) => {\n                const wasDisconnected = connections.size === 0;\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    connect.call(nativeAudioNode, destination, output, input);\n                    insertElementInSet(connections, [destination, output, input], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n                    return destination;\n                }\n                connect.call(nativeAudioNode, destination, output);\n                insertElementInSet(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n                return;\n            };\n        })(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput, output, input) => {\n                const wasConnected = connections.size > 0;\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n                    connections.clear();\n                }\n                else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    disconnect.call(nativeAudioNode, destinationOrOutput);\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n                    }\n                    else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output);\n                    }\n                    for (const connection of connections) {\n                        if (connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                const isDisconnected = connections.size === 0;\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n    };\n};\n//# sourceMappingURL=monitor-connections.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=assign-native-audio-node-option.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=assign-native-audio-node-options.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=test-analyser-node-get-float-time-domain-data-method-support.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=wrap-analyser-node-get-float-time-domain-data-method.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=native-analyser-node-factory.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=native-audio-buffer-constructor.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=assign-native-audio-node-audio-param-value.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=native-audio-buffer-source-node-factory.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=native-audio-context-constructor.js.map","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            }\n            catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            try {\n                nativeAudioDestinationNode.channelCount = value;\n            }\n            catch (err) {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                if (value > nativeAudioDestinationNode.maxChannelCount) {\n                    throw err;\n                }\n            }\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n    };\n};\n//# sourceMappingURL=native-audio-destination-node.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=native-audio-worklet-node-constructor.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=test-clonability-of-audio-worklet-node-options.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);\n                const patchedEventListeners = new Map();\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = typeof value === 'function' ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = typeof args[1] === 'function'\n                                ? args[1]\n                                : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n                                            unpatchedEventListener(event);\n                                        }\n                                        else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n        }\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-factory.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=compute-buffer-size.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=clone-audio-worklet-node-options.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=create-audio-worklet-processor-promise.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=create-audio-worklet-processor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n        const activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n                                return input;\n                            }\n                            const count = activeInputIndexes.get(index);\n                            if (count === undefined) {\n                                return [];\n                            }\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                }\n                                else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                            colno: error.colno,\n                            filename: error.filename,\n                            lineno: error.lineno,\n                            message: error.message\n                        }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNode = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n    return nativeBiquadFilterNode;\n};\n//# sourceMappingURL=native-biquad-filter-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=native-channel-merger-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=wrap-channel-splitter-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNode = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n    return nativeChannelSplitterNode;\n};\n//# sourceMappingURL=native-channel-splitter-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=native-constant-source-node-factory.js.map","export const interceptConnections = (original, interceptor) => {\n    original.connect = interceptor.connect.bind(interceptor);\n    original.disconnect = interceptor.disconnect.bind(interceptor);\n    return original;\n};\n//# sourceMappingURL=intercept-connections.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCount', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value > 2) {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCountMode', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value === 'max') {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=native-convolver-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNode = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n    return nativeDelayNode;\n};\n//# sourceMappingURL=native-delay-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=native-dynamics-compressor-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNode = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n    return nativeGainNode;\n};\n//# sourceMappingURL=native-gain-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=native-iir-filter-node-factory.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\nfunction multiply(a, b) {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=native-iir-filter-node-faker-factory.js.map","export const createNativeMediaElementAudioSourceNode = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n//# sourceMappingURL=native-media-element-audio-source-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n    return nativeMediaStreamAudioDestinationNode;\n};\n//# sourceMappingURL=native-media-stream-audio-destination-node.js.map","export const createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n    return nativeMediaStreamAudioSourceNode;\n};\n//# sourceMappingURL=native-media-stream-audio-source-node.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, isNativeOfflineAudioContext) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=native-media-stream-track-audio-source-node-factory.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=native-offline-audio-context-constructor.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=native-oscillator-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=native-panner-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = nativeContext.createPanner();\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n        let lastOrientation = [orientationX, orientationY, orientationZ];\n        let lastPosition = [positionX, positionY, positionZ];\n        const buffer = new Float32Array(1);\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                getFirstSample(inputBuffer, buffer, 0),\n                getFirstSample(inputBuffer, buffer, 1),\n                getFirstSample(inputBuffer, buffer, 2)\n            ];\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                getFirstSample(inputBuffer, buffer, 3),\n                getFirstSample(inputBuffer, buffer, 4),\n                getFirstSample(inputBuffer, buffer, 5)\n            ];\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-panner-node-faker-factory.js.map","export const createNativePeriodicWaveFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n        return nativePeriodicWave;\n    };\n};\n//# sourceMappingURL=native-periodic-wave-factory.js.map","export const createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n//# sourceMappingURL=native-script-processor-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    };\n};\n//# sourceMappingURL=native-stereo-panner-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve }));\n        return {\n            connectGraph() {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n        return {\n            connectGraph() {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForLeftOutputWaveShaperNode\n                    : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForRightOutputWaveShaperNode\n                    : leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForLeftOutputWaveShaperNode\n                    : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForRightOutputWaveShaperNode\n                    : rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForLeftOutputWaveShaperNode\n                    : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForRightOutputWaveShaperNode\n                    : leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForLeftOutputWaveShaperNode\n                    : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForRightOutputWaveShaperNode\n                    : rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            connectGraph();\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n            isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-stereo-panner-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                    (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    }\n                    else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n            isConnected = true;\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-faker-factory.js.map","export const createNotSupportedError = () => new DOMException('', 'NotSupportedError');\n//# sourceMappingURL=not-supported-error.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n                deactivateAudioGraph(this);\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=offline-audio-context-constructor.js.map","import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max', // This attribute has no effect for nodes with no inputs.\n    channelInterpretation: 'speakers', // This attribute has no effect for nodes with no inputs.\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class OscillatorNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = (isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=oscillator-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=oscillator-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class PannerNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = (isOffline ? createPannerNodeRenderer() : null);\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=panner-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let renderedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode(proxy);\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            }\n            else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all([\n                            proxy.orientationX,\n                            proxy.orientationY,\n                            proxy.orientationZ,\n                            proxy.positionX,\n                            proxy.positionY,\n                            proxy.positionZ\n                        ].map(async (audioParam, index) => {\n                            const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: index === 0 ? 1 : 0\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n                            return nativeConstantSourceNode;\n                        }));\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n                const channelDatas = [];\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n                inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n                    if (orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n                        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n                return nativeGainNode;\n            }\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=panner-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore, sanitizePeriodicWaveOptions) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n            periodicWaveStore.add(periodicWave);\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=periodic-wave-constructor.js.map","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n//# sourceMappingURL=render-automation.js.map","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        await Promise.all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array.from(connections).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-node.js.map","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-param.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=render-native-offline-audio-context.js.map","export const createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n//# sourceMappingURL=set-active-audio-worklet-node-inputs.js.map","export const createSetAudioNodeTailTime = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n//# sourceMappingURL=set-audio-node-tail-time.js.map","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */\n        .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext))))\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=start-rendering.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class StereoPannerNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = (isOffline ? createStereoPannerNodeRenderer() : null);\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=stereo-panner-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=stereo-panner-node-renderer-factory.js.map","// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=test-audio-buffer-constructor-support.js.map","// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'], {\n            type: 'application/javascript; charset=utf-8'\n        });\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n            await offlineAudioContext.startRendering();\n            // Bug #197: Safari does not deliver the messages before the promise returned by startRendering() resolves.\n            await new Promise((resolve) => setTimeout(resolve));\n        }\n        catch {\n            // Ignore errors.\n        }\n        finally {\n            URL.revokeObjectURL(url);\n        }\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n//# sourceMappingURL=test-audio-worklet-processor-post-message-support.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=test-offline-audio-context-current-time-support.js.map","export const createUnknownError = () => new DOMException('', 'UnknownError');\n//# sourceMappingURL=unknown-error.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class WaveShaperNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = (isOffline ? createWaveShaperNodeRenderer() : null);\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=wave-shaper-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=wave-shaper-node-renderer-factory.js.map","export const createWindow = () => (typeof window === 'undefined' ? null : window);\n//# sourceMappingURL=window.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', (get) => () => {\n            const value = get.call(nativeAudioBufferSourceNode);\n            return value === nullifiedBuffer ? null : value;\n        }, (set) => (value) => {\n            return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n        });\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-stop-method-nullified-buffer.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=wrap-channel-merger-node.js.map","export const getFirstSample = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n    return buffer[0];\n};\n//# sourceMappingURL=get-first-sample.js.map","export const isDCCurve = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n    const length = curve.length;\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n//# sourceMappingURL=is-dc-curve.js.map","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n    const { get, set } = Object.getOwnPropertyDescriptor(prototype, property);\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n//# sourceMappingURL=overwrite-accessors.js.map","export const sanitizeAudioWorkletNodeOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: options.outputChannelCount !== undefined\n            ? options.outputChannelCount\n            : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                    [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n//# sourceMappingURL=sanitize-audio-worklet-node-options.js.map","export const sanitizeChannelSplitterOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n//# sourceMappingURL=sanitize-channel-splitter-options.js.map","export const sanitizePeriodicWaveOptions = (options) => {\n    const { imag, real } = options;\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n    return { ...options, imag, real };\n};\n//# sourceMappingURL=sanitize-periodic-wave-options.js.map","export const setValueAtTimeUntilPossible = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    }\n    catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n//# sourceMappingURL=set-value-at-time-until-possible.js.map","export const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.start();\n    try {\n        nativeAudioBufferSourceNode.start();\n    }\n    catch {\n        return true;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","export const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.start();\n    try {\n        nativeAudioBufferSourceNode.stop();\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-stop-method-nullified-buffer-support.js.map","export const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    }\n    catch (err) {\n        return err instanceof RangeError;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n    try {\n        nativeAudioBufferSourceNode.stop();\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    }\n    catch (err) {\n        return err instanceof RangeError;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","export const testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n        port2.close();\n    }\n};\n//# sourceMappingURL=test-audio-worklet-node-options-clonability.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","import { interceptConnections } from './intercept-connections';\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = nativeContext.createGain();\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                }\n                catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            }\n            else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","export const wrapEventListener = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n//# sourceMappingURL=wrap-event-listener.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet(), sanitizePeriodicWaveOptions);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = isSecureContext\n    ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, new WeakMap(), new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), \n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window)\n    : undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener)\n    : undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor), testDomExceptionConstructorSupport, createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=module.js.map","/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg) {\n    return arg === undefined;\n}\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined(arg) {\n    return arg !== undefined;\n}\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg) {\n    return typeof arg === \"function\";\n}\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg) {\n    return typeof arg === \"number\";\n}\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg) {\n    return (Object.prototype.toString.call(arg) === \"[object Object]\" &&\n        arg.constructor === Object);\n}\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg) {\n    return typeof arg === \"boolean\";\n}\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg) {\n    return Array.isArray(arg);\n}\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg) {\n    return typeof arg === \"string\";\n}\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg) {\n    return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n//# sourceMappingURL=TypeCheck.js.map","import { isUndef } from \"./TypeCheck.js\";\n/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement, error) {\n    if (!statement) {\n        throw new Error(error);\n    }\n}\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value, gte, lte = Infinity) {\n    if (!(gte <= value && value <= lte)) {\n        throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n    }\n}\n/**\n * Warn if the context is not running.\n */\nexport function assertContextRunning(context) {\n    // add a warning if the context is not started\n    if (!context.isOffline && context.state !== \"running\") {\n        warn('The AudioContext is \"suspended\". Invoke Tone.start() from a user action to start the audio.');\n    }\n}\n/**\n * If it is currently inside a scheduled callback\n */\nlet isInsideScheduledCallback = false;\nlet printedScheduledWarning = false;\n/**\n * Notify that the following block of code is occurring inside a Transport callback.\n */\nexport function enterScheduledCallback(insideCallback) {\n    isInsideScheduledCallback = insideCallback;\n}\n/**\n * Make sure that a time was passed into\n */\nexport function assertUsedScheduleTime(time) {\n    if (isUndef(time) &&\n        isInsideScheduledCallback &&\n        !printedScheduledWarning) {\n        printedScheduledWarning = true;\n        warn(\"Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing\");\n    }\n}\n/**\n * The default logger is the console\n */\nlet defaultLogger = console;\n/**\n * Set the logging interface\n */\nexport function setLogger(logger) {\n    defaultLogger = logger;\n}\n/**\n * Log anything\n */\nexport function log(...args) {\n    defaultLogger.log(...args);\n}\n/**\n * Warn anything\n */\nexport function warn(...args) {\n    defaultLogger.warn(...args);\n}\n//# sourceMappingURL=Debug.js.map","import { AudioContext as stdAudioContext, AudioWorkletNode as stdAudioWorkletNode, OfflineAudioContext as stdOfflineAudioContext, } from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\n/**\n * Create a new AudioContext\n */\nexport function createAudioContext(options) {\n    return new stdAudioContext(options);\n}\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels, length, sampleRate) {\n    return new stdOfflineAudioContext(channels, length, sampleRate);\n}\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow = typeof self === \"object\" ? self : null;\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n    (theWindow.hasOwnProperty(\"AudioContext\") ||\n        theWindow.hasOwnProperty(\"webkitAudioContext\"));\nexport function createAudioWorkletNode(context, name, options) {\n    assert(isDefined(stdAudioWorkletNode), \"AudioWorkletNode only works in a secure context (https or localhost)\");\n    return new (context instanceof (theWindow === null || theWindow === void 0 ? void 0 : theWindow.BaseAudioContext)\n        ? theWindow === null || theWindow === void 0 ? void 0 : theWindow.AudioWorkletNode\n        : stdAudioWorkletNode)(context, name, options);\n}\n/**\n * This promise resolves to a boolean which indicates if the\n * functionality is supported within the currently used browse.\n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\nexport { isSupported as supported } from \"standardized-audio-context\";\n//# sourceMappingURL=AudioContext.js.map","/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n    constructor(callback, type, updateInterval, contextSampleRate) {\n        this._callback = callback;\n        this._type = type;\n        this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 0.001);\n        this.updateInterval = updateInterval;\n        // create the clock source for the first time\n        this._createClock();\n    }\n    /**\n     * Generate a web worker\n     */\n    _createWorker() {\n        const blob = new Blob([\n            /* javascript */ `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`,\n        ], { type: \"text/javascript\" });\n        const blobUrl = URL.createObjectURL(blob);\n        const worker = new Worker(blobUrl);\n        worker.onmessage = this._callback.bind(this);\n        this._worker = worker;\n    }\n    /**\n     * Create a timeout loop\n     */\n    _createTimeout() {\n        this._timeout = setTimeout(() => {\n            this._createTimeout();\n            this._callback();\n        }, this._updateInterval * 1000);\n    }\n    /**\n     * Create the clock source.\n     */\n    _createClock() {\n        if (this._type === \"worker\") {\n            try {\n                this._createWorker();\n            }\n            catch (e) {\n                // workers not supported, fallback to timeout\n                this._type = \"timeout\";\n                this._createClock();\n            }\n        }\n        else if (this._type === \"timeout\") {\n            this._createTimeout();\n        }\n    }\n    /**\n     * Clean up the current clock source\n     */\n    _disposeClock() {\n        if (this._timeout) {\n            clearTimeout(this._timeout);\n        }\n        if (this._worker) {\n            this._worker.terminate();\n            this._worker.onmessage = null;\n        }\n    }\n    /**\n     * The rate in seconds the ticker will update\n     */\n    get updateInterval() {\n        return this._updateInterval;\n    }\n    set updateInterval(interval) {\n        var _a;\n        this._updateInterval = Math.max(interval, this._minimumUpdateInterval);\n        if (this._type === \"worker\") {\n            (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(this._updateInterval * 1000);\n        }\n    }\n    /**\n     * The type of the ticker, either a worker or a timeout\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._disposeClock();\n        this._type = type;\n        this._createClock();\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        this._disposeClock();\n    }\n}\n//# sourceMappingURL=Ticker.js.map","import { AudioBuffer, isAnyAudioContext, isAnyAudioNode, isAnyAudioParam, isAnyOfflineAudioContext, } from \"standardized-audio-context\";\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg) {\n    return isAnyAudioParam(arg);\n}\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg) {\n    return isAnyAudioNode(arg);\n}\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg) {\n    return isAnyOfflineAudioContext(arg);\n}\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg) {\n    return isAnyAudioContext(arg);\n}\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg) {\n    return arg instanceof AudioBuffer;\n}\n//# sourceMappingURL=AdvancedTypeCheck.js.map","import { isAudioBuffer, isAudioNode, isAudioParam, } from \"./AdvancedTypeCheck.js\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck.js\";\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key, arg) {\n    return (key === \"value\" ||\n        isAudioParam(arg) ||\n        isAudioNode(arg) ||\n        isAudioBuffer(arg));\n}\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge(target, ...sources) {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (noCopy(key, source[key])) {\n                target[key] = source[key];\n            }\n            else if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, { [key]: {} });\n                }\n                deepMerge(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    // @ts-ignore\n    return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA, arrayB) {\n    return (arrayA.length === arrayB.length &&\n        arrayA.every((element, index) => arrayB[index] === element));\n}\n/**\n * Convert an args array into an object.\n * @internal\n */\nexport function optionsFromArguments(defaults, argsArray, keys = [], objKey) {\n    const opts = {};\n    const args = Array.from(argsArray);\n    // if the first argument is an object and has an object key\n    if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n        // if it's not part of the defaults\n        const partOfDefaults = Object.keys(args[0]).some((key) => Reflect.has(defaults, key));\n        if (!partOfDefaults) {\n            // merge that key\n            deepMerge(opts, { [objKey]: args[0] });\n            // remove the obj key from the keys\n            keys.splice(keys.indexOf(objKey), 1);\n            // shift the first argument off\n            args.shift();\n        }\n    }\n    if (args.length === 1 && isObject(args[0])) {\n        deepMerge(opts, args[0]);\n    }\n    else {\n        for (let i = 0; i < keys.length; i++) {\n            if (isDefined(args[i])) {\n                opts[keys[i]] = args[i];\n            }\n        }\n    }\n    return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance(instance) {\n    return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n * @internal\n */\nexport function defaultArg(given, fallback) {\n    if (isUndef(given)) {\n        return fallback;\n    }\n    else {\n        return given;\n    }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject(obj, omit) {\n    omit.forEach((prop) => {\n        if (Reflect.has(obj, prop)) {\n            delete obj[prop];\n        }\n    });\n    return obj;\n}\n//# sourceMappingURL=Defaults.js.map","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2024 Yotam Mann\n */\nimport { version } from \"../version.js\";\nimport { theWindow } from \"./context/AudioContext.js\";\nimport { log } from \"./util/Debug.js\";\n/**\n * Tone is the base class of all other classes.\n *\n * @category Core\n * @constructor\n */\nexport class Tone {\n    constructor() {\n        //-------------------------------------\n        // \tDEBUGGING\n        //-------------------------------------\n        /**\n         * Set this debug flag to log all events that happen in this class.\n         */\n        this.debug = false;\n        //-------------------------------------\n        // \tDISPOSING\n        //-------------------------------------\n        /**\n         * Indicates if the instance was disposed\n         */\n        this._wasDisposed = false;\n    }\n    /**\n     * Returns all of the default options belonging to the class.\n     */\n    static getDefaults() {\n        return {};\n    }\n    /**\n     * Prints the outputs to the console log for debugging purposes.\n     * Prints the contents only if either the object has a property\n     * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n     * is set to the name of the class.\n     * @example\n     * const osc = new Tone.Oscillator();\n     * // prints all logs originating from this oscillator\n     * osc.debug = true;\n     * // calls to start/stop will print in the console\n     * osc.start();\n     */\n    log(...args) {\n        // if the object is either set to debug = true\n        // or if there is a string on the Tone.global.with the class name\n        if (this.debug ||\n            (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n            log(this, ...args);\n        }\n    }\n    /**\n     * disconnect and dispose.\n     */\n    dispose() {\n        this._wasDisposed = true;\n        return this;\n    }\n    /**\n     * Indicates if the instance was disposed. 'Disposing' an\n     * instance means that all of the Web Audio nodes that were\n     * created for the instance are disconnected and freed for garbage collection.\n     */\n    get disposed() {\n        return this._wasDisposed;\n    }\n    /**\n     * Convert the class to a string\n     * @example\n     * const osc = new Tone.Oscillator();\n     * console.log(osc.toString());\n     */\n    toString() {\n        return this.name;\n    }\n}\n/**\n * The version number semver\n */\nTone.version = version;\n//# sourceMappingURL=Tone.js.map","/**\n * The threshold for correctness for operators. Less than one sample even\n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n/**\n * Test if A is greater than B\n */\nexport function GT(a, b) {\n    return a > b + EPSILON;\n}\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a, b) {\n    return GT(a, b) || EQ(a, b);\n}\n/**\n * Test if A is less than B\n */\nexport function LT(a, b) {\n    return a + EPSILON < b;\n}\n/**\n * Test if A is less than B\n */\nexport function EQ(a, b) {\n    return Math.abs(a - b) < EPSILON;\n}\n/**\n * Clamp the value within the given range\n */\nexport function clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n//# sourceMappingURL=Math.js.map","import { Tone } from \"../Tone.js\";\nimport { optionsFromArguments } from \"./Defaults.js\";\nimport { assert } from \"./Debug.js\";\nimport { EQ, GT, GTE, LT } from \"./Math.js\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n * @internal\n */\nexport class Timeline extends Tone {\n    constructor() {\n        super();\n        this.name = \"Timeline\";\n        /**\n         * The array of scheduled timeline events\n         */\n        this._timeline = [];\n        const options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n        this.memory = options.memory;\n        this.increasing = options.increasing;\n    }\n    static getDefaults() {\n        return {\n            memory: Infinity,\n            increasing: false,\n        };\n    }\n    /**\n     * The number of items in the timeline.\n     */\n    get length() {\n        return this._timeline.length;\n    }\n    /**\n     * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n     * @param event  The event object to insert into the timeline.\n     */\n    add(event) {\n        // the event needs to have a time attribute\n        assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n        event.time = event.time.valueOf();\n        if (this.increasing && this.length) {\n            const lastValue = this._timeline[this.length - 1];\n            assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n            this._timeline.push(event);\n        }\n        else {\n            const index = this._search(event.time);\n            this._timeline.splice(index + 1, 0, event);\n        }\n        // if the length is more than the memory, remove the previous ones\n        if (this.length > this.memory) {\n            const diff = this.length - this.memory;\n            this._timeline.splice(0, diff);\n        }\n        return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  {Object}  event  The event object to remove from the list.\n     * @returns {Timeline} this\n     */\n    remove(event) {\n        const index = this._timeline.indexOf(event);\n        if (index !== -1) {\n            this._timeline.splice(index, 1);\n        }\n        return this;\n    }\n    /**\n     * Get the nearest event whose time is less than or equal to the given time.\n     * @param  time  The time to query.\n     */\n    get(time, param = \"time\") {\n        const index = this._search(time, param);\n        if (index !== -1) {\n            return this._timeline[index];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Return the first event in the timeline without removing it\n     * @returns {Object} The first event object\n     * @deprecated\n     */\n    peek() {\n        return this._timeline[0];\n    }\n    /**\n     * Return the first event in the timeline and remove it\n     * @deprecated\n     */\n    shift() {\n        return this._timeline.shift();\n    }\n    /**\n     * Get the event which is scheduled after the given time.\n     * @param  time  The time to query.\n     */\n    getAfter(time, param = \"time\") {\n        const index = this._search(time, param);\n        if (index + 1 < this._timeline.length) {\n            return this._timeline[index + 1];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Get the event before the event at the given time.\n     * @param  time  The time to query.\n     */\n    getBefore(time) {\n        const len = this._timeline.length;\n        // if it's after the last item, return the last item\n        if (len > 0 && this._timeline[len - 1].time < time) {\n            return this._timeline[len - 1];\n        }\n        const index = this._search(time);\n        if (index - 1 >= 0) {\n            return this._timeline[index - 1];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Cancel events at and after the given time\n     * @param  after  The time to query.\n     */\n    cancel(after) {\n        if (this._timeline.length > 1) {\n            let index = this._search(after);\n            if (index >= 0) {\n                if (EQ(this._timeline[index].time, after)) {\n                    // get the first item with that time\n                    for (let i = index; i >= 0; i--) {\n                        if (EQ(this._timeline[i].time, after)) {\n                            index = i;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    this._timeline = this._timeline.slice(0, index);\n                }\n                else {\n                    this._timeline = this._timeline.slice(0, index + 1);\n                }\n            }\n            else {\n                this._timeline = [];\n            }\n        }\n        else if (this._timeline.length === 1) {\n            // the first item's time\n            if (GTE(this._timeline[0].time, after)) {\n                this._timeline = [];\n            }\n        }\n        return this;\n    }\n    /**\n     * Cancel events before or equal to the given time.\n     * @param  time  The time to cancel before.\n     */\n    cancelBefore(time) {\n        const index = this._search(time);\n        if (index >= 0) {\n            this._timeline = this._timeline.slice(index + 1);\n        }\n        return this;\n    }\n    /**\n     * Returns the previous event if there is one. null otherwise\n     * @param  event The event to find the previous one of\n     * @return The event right before the given event\n     */\n    previousEvent(event) {\n        const index = this._timeline.indexOf(event);\n        if (index > 0) {\n            return this._timeline[index - 1];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Does a binary search on the timeline array and returns the\n     * nearest event index whose time is after or equal to the given time.\n     * If a time is searched before the first index in the timeline, -1 is returned.\n     * If the time is after the end, the index of the last item is returned.\n     */\n    _search(time, param = \"time\") {\n        if (this._timeline.length === 0) {\n            return -1;\n        }\n        let beginning = 0;\n        const len = this._timeline.length;\n        let end = len;\n        if (len > 0 && this._timeline[len - 1][param] <= time) {\n            return len - 1;\n        }\n        while (beginning < end) {\n            // calculate the midpoint for roughly equal partition\n            let midPoint = Math.floor(beginning + (end - beginning) / 2);\n            const event = this._timeline[midPoint];\n            const nextEvent = this._timeline[midPoint + 1];\n            if (EQ(event[param], time)) {\n                // choose the last one that has the same time\n                for (let i = midPoint; i < this._timeline.length; i++) {\n                    const testEvent = this._timeline[i];\n                    if (EQ(testEvent[param], time)) {\n                        midPoint = i;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                return midPoint;\n            }\n            else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n                return midPoint;\n            }\n            else if (GT(event[param], time)) {\n                // search lower\n                end = midPoint;\n            }\n            else {\n                // search upper\n                beginning = midPoint + 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Internal iterator. Applies extra safety checks for\n     * removing items from the array.\n     */\n    _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {\n        this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n    }\n    /**\n     * Iterate over everything in the array\n     * @param  callback The callback to invoke with every item\n     */\n    forEach(callback) {\n        this._iterate(callback);\n        return this;\n    }\n    /**\n     * Iterate over everything in the array at or before the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachBefore(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        const upperBound = this._search(time);\n        if (upperBound !== -1) {\n            this._iterate(callback, 0, upperBound);\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array after the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAfter(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        const lowerBound = this._search(time);\n        this._iterate(callback, lowerBound + 1);\n        return this;\n    }\n    /**\n     * Iterate over everything in the array between the startTime and endTime.\n     * The timerange is inclusive of the startTime, but exclusive of the endTime.\n     * range = [startTime, endTime).\n     * @param  startTime The time to check if items are before\n     * @param  endTime The end of the test interval.\n     * @param  callback The callback to invoke with every item\n     */\n    forEachBetween(startTime, endTime, callback) {\n        let lowerBound = this._search(startTime);\n        let upperBound = this._search(endTime);\n        if (lowerBound !== -1 && upperBound !== -1) {\n            if (this._timeline[lowerBound].time !== startTime) {\n                lowerBound += 1;\n            }\n            // exclusive of the end time\n            if (this._timeline[upperBound].time === endTime) {\n                upperBound -= 1;\n            }\n            this._iterate(callback, lowerBound, upperBound);\n        }\n        else if (lowerBound === -1) {\n            this._iterate(callback, 0, upperBound);\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array at or after the given time. Similar to\n     * forEachAfter, but includes the item(s) at the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachFrom(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        let lowerBound = this._search(time);\n        // work backwards until the event time is less than time\n        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n            lowerBound--;\n        }\n        this._iterate(callback, lowerBound + 1);\n        return this;\n    }\n    /**\n     * Iterate over everything in the array at the given time\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAtTime(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        const upperBound = this._search(time);\n        if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n            let lowerBound = upperBound;\n            for (let i = upperBound; i >= 0; i--) {\n                if (EQ(this._timeline[i].time, time)) {\n                    lowerBound = i;\n                }\n                else {\n                    break;\n                }\n            }\n            this._iterate((event) => {\n                callback(event);\n            }, lowerBound, upperBound);\n        }\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._timeline = [];\n        return this;\n    }\n}\n//# sourceMappingURL=Timeline.js.map","/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext = [];\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb) {\n    notifyNewContext.push(cb);\n}\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx) {\n    // add any additional modules\n    notifyNewContext.forEach((cb) => cb(ctx));\n}\n/**\n * Array of callbacks to invoke when a new context is closed\n */\nconst notifyCloseContext = [];\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb) {\n    notifyCloseContext.push(cb);\n}\nexport function closeContext(ctx) {\n    // remove any additional modules\n    notifyCloseContext.forEach((cb) => cb(ctx));\n}\n//# sourceMappingURL=ContextInitialization.js.map","import { Tone } from \"../Tone.js\";\nimport { isUndef } from \"./TypeCheck.js\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"Emitter\";\n    }\n    /**\n     * Bind a callback to a specific event.\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    on(event, callback) {\n        // split the event\n        const events = event.split(/\\W+/);\n        events.forEach((eventName) => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (!this._events.hasOwnProperty(eventName)) {\n                this._events[eventName] = [];\n            }\n            this._events[eventName].push(callback);\n        });\n        return this;\n    }\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    once(event, callback) {\n        const boundCallback = (...args) => {\n            // invoke the callback\n            callback(...args);\n            // remove the event\n            this.off(event, boundCallback);\n        };\n        this.on(event, boundCallback);\n        return this;\n    }\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n    off(event, callback) {\n        const events = event.split(/\\W+/);\n        events.forEach((eventName) => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (this._events.hasOwnProperty(eventName)) {\n                if (isUndef(callback)) {\n                    this._events[eventName] = [];\n                }\n                else {\n                    const eventList = this._events[eventName];\n                    for (let i = eventList.length - 1; i >= 0; i--) {\n                        if (eventList[i] === callback) {\n                            eventList.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        });\n        return this;\n    }\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n    emit(event, ...args) {\n        if (this._events) {\n            if (this._events.hasOwnProperty(event)) {\n                const eventList = this._events[event].slice(0);\n                for (let i = 0, len = eventList.length; i < len; i++) {\n                    eventList[i].apply(this, args);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n    static mixin(constr) {\n        // instance._events = {};\n        [\"on\", \"once\", \"off\", \"emit\"].forEach((name) => {\n            const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n            Object.defineProperty(constr.prototype, name, property);\n        });\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._events = undefined;\n        return this;\n    }\n}\n//# sourceMappingURL=Emitter.js.map","import { Emitter } from \"../util/Emitter.js\";\nexport class BaseContext extends Emitter {\n    constructor() {\n        super(...arguments);\n        this.isOffline = false;\n    }\n    /*\n     * This is a placeholder so that JSON.stringify does not throw an error\n     * This matches what JSON.stringify(audioContext) returns on a native\n     * audioContext instance.\n     */\n    toJSON() {\n        return {};\n    }\n}\n//# sourceMappingURL=BaseContext.js.map","import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker.js\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { createAudioContext, createAudioWorkletNode, } from \"./AudioContext.js\";\nimport { closeContext, initializeContext } from \"./ContextInitialization.js\";\nimport { BaseContext } from \"./BaseContext.js\";\nimport { assert } from \"../util/Debug.js\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n    constructor() {\n        var _a, _b;\n        super();\n        this.name = \"Context\";\n        /**\n         * An object containing all of the constants AudioBufferSourceNodes\n         */\n        this._constants = new Map();\n        /**\n         * All of the setTimeout events.\n         */\n        this._timeouts = new Timeline();\n        /**\n         * The timeout id counter\n         */\n        this._timeoutIds = 0;\n        /**\n         * Private indicator if the context has been initialized\n         */\n        this._initialized = false;\n        /**\n         * Private indicator if a close() has been called on the context, since close is async\n         */\n        this._closeStarted = false;\n        /**\n         * Indicates if the context is an OfflineAudioContext or an AudioContext\n         */\n        this.isOffline = false;\n        //--------------------------------------------\n        // AUDIO WORKLET\n        //--------------------------------------------\n        /**\n         * Maps a module name to promise of the addModule method\n         */\n        this._workletPromise = null;\n        const options = optionsFromArguments(Context.getDefaults(), arguments, [\n            \"context\",\n        ]);\n        if (options.context) {\n            this._context = options.context;\n            // custom context provided, latencyHint unknown (unless explicitly provided in options)\n            this._latencyHint = ((_a = arguments[0]) === null || _a === void 0 ? void 0 : _a.latencyHint) || \"\";\n        }\n        else {\n            this._context = createAudioContext({\n                latencyHint: options.latencyHint,\n            });\n            this._latencyHint = options.latencyHint;\n        }\n        this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval, this._context.sampleRate);\n        this.on(\"tick\", this._timeoutLoop.bind(this));\n        // fwd events from the context\n        this._context.onstatechange = () => {\n            this.emit(\"statechange\", this.state);\n        };\n        // if no custom updateInterval provided, updateInterval will be derived by lookAhead setter\n        this[((_b = arguments[0]) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(\"updateInterval\"))\n            ? \"_lookAhead\"\n            : \"lookAhead\"] = options.lookAhead;\n    }\n    static getDefaults() {\n        return {\n            clockSource: \"worker\",\n            latencyHint: \"interactive\",\n            lookAhead: 0.1,\n            updateInterval: 0.05,\n        };\n    }\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    initialize() {\n        if (!this._initialized) {\n            // add any additional modules\n            initializeContext(this);\n            this._initialized = true;\n        }\n        return this;\n    }\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAnalyser() {\n        return this._context.createAnalyser();\n    }\n    createOscillator() {\n        return this._context.createOscillator();\n    }\n    createBufferSource() {\n        return this._context.createBufferSource();\n    }\n    createBiquadFilter() {\n        return this._context.createBiquadFilter();\n    }\n    createBuffer(numberOfChannels, length, sampleRate) {\n        return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    }\n    createChannelMerger(numberOfInputs) {\n        return this._context.createChannelMerger(numberOfInputs);\n    }\n    createChannelSplitter(numberOfOutputs) {\n        return this._context.createChannelSplitter(numberOfOutputs);\n    }\n    createConstantSource() {\n        return this._context.createConstantSource();\n    }\n    createConvolver() {\n        return this._context.createConvolver();\n    }\n    createDelay(maxDelayTime) {\n        return this._context.createDelay(maxDelayTime);\n    }\n    createDynamicsCompressor() {\n        return this._context.createDynamicsCompressor();\n    }\n    createGain() {\n        return this._context.createGain();\n    }\n    createIIRFilter(feedForward, feedback) {\n        // @ts-ignore\n        return this._context.createIIRFilter(feedForward, feedback);\n    }\n    createPanner() {\n        return this._context.createPanner();\n    }\n    createPeriodicWave(real, imag, constraints) {\n        return this._context.createPeriodicWave(real, imag, constraints);\n    }\n    createStereoPanner() {\n        return this._context.createStereoPanner();\n    }\n    createWaveShaper() {\n        return this._context.createWaveShaper();\n    }\n    createMediaStreamSource(stream) {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamSource(stream);\n    }\n    createMediaElementSource(element) {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaElementSource(element);\n    }\n    createMediaStreamDestination() {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamDestination();\n    }\n    decodeAudioData(audioData) {\n        return this._context.decodeAudioData(audioData);\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get currentTime() {\n        return this._context.currentTime;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get state() {\n        return this._context.state;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get sampleRate() {\n        return this._context.sampleRate;\n    }\n    /**\n     * The listener\n     */\n    get listener() {\n        this.initialize();\n        return this._listener;\n    }\n    set listener(l) {\n        assert(!this._initialized, \"The listener cannot be set after initialization.\");\n        this._listener = l;\n    }\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n    get transport() {\n        this.initialize();\n        return this._transport;\n    }\n    set transport(t) {\n        assert(!this._initialized, \"The transport cannot be set after initialization.\");\n        this._transport = t;\n    }\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n    get draw() {\n        this.initialize();\n        return this._draw;\n    }\n    set draw(d) {\n        assert(!this._initialized, \"Draw cannot be set after initialization.\");\n        this._draw = d;\n    }\n    /**\n     * A reference to the Context's destination node.\n     */\n    get destination() {\n        this.initialize();\n        return this._destination;\n    }\n    set destination(d) {\n        assert(!this._initialized, \"The destination cannot be set after initialization.\");\n        this._destination = d;\n    }\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using {@link addAudioWorkletModule}.\n     */\n    createAudioWorkletNode(name, options) {\n        return createAudioWorkletNode(this.rawContext, name, options);\n    }\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     */\n    addAudioWorkletModule(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n            if (!this._workletPromise) {\n                this._workletPromise = this.rawContext.audioWorklet.addModule(url);\n            }\n            yield this._workletPromise;\n        });\n    }\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n    workletsAreReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            (yield this._workletPromise) ? this._workletPromise : Promise.resolve();\n        });\n    }\n    //---------------------------\n    // TICKER\n    //---------------------------\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. Setting to 0 will result in the lowest practial interval\n     * based on context properties. context.updateInterval + context.lookAhead\n     * gives you the total latency between scheduling an event and hearing it.\n     */\n    get updateInterval() {\n        return this._ticker.updateInterval;\n    }\n    set updateInterval(interval) {\n        this._ticker.updateInterval = interval;\n    }\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n    get clockSource() {\n        return this._ticker.type;\n    }\n    set clockSource(type) {\n        this._ticker.type = type;\n    }\n    /**\n     * The amount of time into the future events are scheduled. Giving Web Audio\n     * a short amount of time into the future to schedule events can reduce clicks and\n     * improve performance. This value can be set to 0 to get the lowest latency.\n     * Adjusting this value also affects the {@link updateInterval}.\n     */\n    get lookAhead() {\n        return this._lookAhead;\n    }\n    set lookAhead(time) {\n        this._lookAhead = time;\n        // if lookAhead is 0, default to .01 updateInterval\n        this.updateInterval = time ? time / 2 : 0.01;\n    }\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance).\n     * @example\n     * // prioritize sustained playback\n     * const context = new Tone.Context({ latencyHint: \"playback\" });\n     * // set this context as the global Context\n     * Tone.setContext(context);\n     * // the global context is gettable with Tone.getContext()\n     * console.log(Tone.getContext().latencyHint);\n     */\n    get latencyHint() {\n        return this._latencyHint;\n    }\n    /**\n     * The unwrapped AudioContext or OfflineAudioContext\n     */\n    get rawContext() {\n        return this._context;\n    }\n    /**\n     * The current audio context time plus a short {@link lookAhead}.\n     * @example\n     * setInterval(() => {\n     * \tconsole.log(\"now\", Tone.now());\n     * }, 100);\n     */\n    now() {\n        return this._context.currentTime + this._lookAhead;\n    }\n    /**\n     * The current audio context time without the {@link lookAhead}.\n     * In most cases it is better to use {@link now} instead of {@link immediate} since\n     * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}\n     * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.\n     */\n    immediate() {\n        return this._context.currentTime;\n    }\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext.\n     * @see {@link start}\n     */\n    resume() {\n        if (isAudioContext(this._context)) {\n            return this._context.resume();\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Close the context. Once closed, the context can no longer be used and\n     * any AudioNodes created from the context will be silent.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (isAudioContext(this._context) &&\n                this.state !== \"closed\" &&\n                !this._closeStarted) {\n                this._closeStarted = true;\n                yield this._context.close();\n            }\n            if (this._initialized) {\n                closeContext(this);\n            }\n        });\n    }\n    /**\n     * **Internal** Generate a looped buffer at some constant value.\n     */\n    getConstant(val) {\n        if (this._constants.has(val)) {\n            return this._constants.get(val);\n        }\n        else {\n            const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n            const arr = buffer.getChannelData(0);\n            for (let i = 0; i < arr.length; i++) {\n                arr[i] = val;\n            }\n            const constant = this._context.createBufferSource();\n            constant.channelCount = 1;\n            constant.channelCountMode = \"explicit\";\n            constant.buffer = buffer;\n            constant.loop = true;\n            constant.start(0);\n            this._constants.set(val, constant);\n            return constant;\n        }\n    }\n    /**\n     * Clean up. Also closes the audio context.\n     */\n    dispose() {\n        super.dispose();\n        this._ticker.dispose();\n        this._timeouts.dispose();\n        Object.keys(this._constants).map((val) => this._constants[val].disconnect());\n        this.close();\n        return this;\n    }\n    //---------------------------\n    // TIMEOUTS\n    //---------------------------\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n    _timeoutLoop() {\n        const now = this.now();\n        this._timeouts.forEachBefore(now, (event) => {\n            // invoke the callback\n            event.callback();\n            this._timeouts.remove(event);\n        });\n    }\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n    setTimeout(fn, timeout) {\n        this._timeoutIds++;\n        const now = this.now();\n        this._timeouts.add({\n            callback: fn,\n            id: this._timeoutIds,\n            time: now + timeout,\n        });\n        return this._timeoutIds;\n    }\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n    clearTimeout(id) {\n        this._timeouts.forEach((event) => {\n            if (event.id === id) {\n                this._timeouts.remove(event);\n            }\n        });\n        return this;\n    }\n    /**\n     * Clear the function scheduled by {@link setInterval}\n     */\n    clearInterval(id) {\n        return this.clearTimeout(id);\n    }\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n    setInterval(fn, interval) {\n        const id = ++this._timeoutIds;\n        const intervalFn = () => {\n            const now = this.now();\n            this._timeouts.add({\n                callback: () => {\n                    // invoke the callback\n                    fn();\n                    // invoke the event to repeat it\n                    intervalFn();\n                },\n                id,\n                time: now + interval,\n            });\n        };\n        // kick it off\n        intervalFn();\n        return id;\n    }\n}\n//# sourceMappingURL=Context.js.map","import { __awaiter } from \"tslib\";\nimport { BaseContext } from \"./BaseContext.js\";\nexport class DummyContext extends BaseContext {\n    constructor() {\n        super(...arguments);\n        this.lookAhead = 0;\n        this.latencyHint = 0;\n        this.isOffline = false;\n    }\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAnalyser() {\n        return {};\n    }\n    createOscillator() {\n        return {};\n    }\n    createBufferSource() {\n        return {};\n    }\n    createBiquadFilter() {\n        return {};\n    }\n    createBuffer(_numberOfChannels, _length, _sampleRate) {\n        return {};\n    }\n    createChannelMerger(_numberOfInputs) {\n        return {};\n    }\n    createChannelSplitter(_numberOfOutputs) {\n        return {};\n    }\n    createConstantSource() {\n        return {};\n    }\n    createConvolver() {\n        return {};\n    }\n    createDelay(_maxDelayTime) {\n        return {};\n    }\n    createDynamicsCompressor() {\n        return {};\n    }\n    createGain() {\n        return {};\n    }\n    createIIRFilter(_feedForward, _feedback) {\n        return {};\n    }\n    createPanner() {\n        return {};\n    }\n    createPeriodicWave(_real, _imag, _constraints) {\n        return {};\n    }\n    createStereoPanner() {\n        return {};\n    }\n    createWaveShaper() {\n        return {};\n    }\n    createMediaStreamSource(_stream) {\n        return {};\n    }\n    createMediaElementSource(_element) {\n        return {};\n    }\n    createMediaStreamDestination() {\n        return {};\n    }\n    decodeAudioData(_audioData) {\n        return Promise.resolve({});\n    }\n    //---------------------------\n    // TONE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAudioWorkletNode(_name, _options) {\n        return {};\n    }\n    get rawContext() {\n        return {};\n    }\n    addAudioWorkletModule(_url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve();\n        });\n    }\n    resume() {\n        return Promise.resolve();\n    }\n    setTimeout(_fn, _timeout) {\n        return 0;\n    }\n    clearTimeout(_id) {\n        return this;\n    }\n    setInterval(_fn, _interval) {\n        return 0;\n    }\n    clearInterval(_id) {\n        return this;\n    }\n    getConstant(_val) {\n        return {};\n    }\n    get currentTime() {\n        return 0;\n    }\n    get state() {\n        return {};\n    }\n    get sampleRate() {\n        return 0;\n    }\n    get listener() {\n        return {};\n    }\n    get transport() {\n        return {};\n    }\n    get draw() {\n        return {};\n    }\n    set draw(_d) { }\n    get destination() {\n        return {};\n    }\n    set destination(_d) { }\n    now() {\n        return 0;\n    }\n    immediate() {\n        return 0;\n    }\n}\n//# sourceMappingURL=DummyContext.js.map","import { isArray } from \"./TypeCheck.js\";\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target, property) {\n    if (isArray(property)) {\n        property.forEach((str) => readOnly(target, str));\n    }\n    else {\n        Object.defineProperty(target, property, {\n            enumerable: true,\n            writable: false,\n        });\n    }\n}\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target, property) {\n    if (isArray(property)) {\n        property.forEach((str) => writable(target, str));\n    }\n    else {\n        Object.defineProperty(target, property, {\n            writable: true,\n        });\n    }\n}\nexport const noOp = () => {\n    // no operation here!\n};\n//# sourceMappingURL=Interface.js.map","import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global.js\";\nimport { Tone } from \"../Tone.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { noOp } from \"../util/Interface.js\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck.js\";\nimport { assert } from \"../util/Debug.js\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n    constructor() {\n        super();\n        this.name = \"ToneAudioBuffer\";\n        /**\n         * Callback when the buffer is loaded.\n         */\n        this.onload = noOp;\n        const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n        this.reverse = options.reverse;\n        this.onload = options.onload;\n        if (isString(options.url)) {\n            // initiate the download\n            this.load(options.url).catch(options.onerror);\n        }\n        else if (options.url) {\n            this.set(options.url);\n        }\n    }\n    static getDefaults() {\n        return {\n            onerror: noOp,\n            onload: noOp,\n            reverse: false,\n        };\n    }\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    get sampleRate() {\n        if (this._buffer) {\n            return this._buffer.sampleRate;\n        }\n        else {\n            return getContext().sampleRate;\n        }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n    set(buffer) {\n        if (buffer instanceof ToneAudioBuffer) {\n            // if it's loaded, set it\n            if (buffer.loaded) {\n                this._buffer = buffer.get();\n            }\n            else {\n                // otherwise when it's loaded, invoke it's callback\n                buffer.onload = () => {\n                    this.set(buffer);\n                    this.onload(this);\n                };\n            }\n        }\n        else {\n            this._buffer = buffer;\n        }\n        // reverse it initially\n        if (this._reversed) {\n            this._reverse();\n        }\n        return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n    get() {\n        return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doneLoading = ToneAudioBuffer.load(url).then((audioBuffer) => {\n                this.set(audioBuffer);\n                // invoke the onload method\n                this.onload(this);\n            });\n            ToneAudioBuffer.downloads.push(doneLoading);\n            try {\n                yield doneLoading;\n            }\n            finally {\n                // remove the downloaded file\n                const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n                ToneAudioBuffer.downloads.splice(index, 1);\n            }\n            return this;\n        });\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this._buffer = undefined;\n        return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n    fromArray(array) {\n        const isMultidimensional = isArray(array) && array[0].length > 0;\n        const channels = isMultidimensional ? array.length : 1;\n        const len = isMultidimensional\n            ? array[0].length\n            : array.length;\n        const context = getContext();\n        const buffer = context.createBuffer(channels, len, context.sampleRate);\n        const multiChannelArray = !isMultidimensional && channels === 1\n            ? [array]\n            : array;\n        for (let c = 0; c < channels; c++) {\n            buffer.copyToChannel(multiChannelArray[c], c);\n        }\n        this._buffer = buffer;\n        return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n    toMono(chanNum) {\n        if (isNumber(chanNum)) {\n            this.fromArray(this.toArray(chanNum));\n        }\n        else {\n            let outputArray = new Float32Array(this.length);\n            const numChannels = this.numberOfChannels;\n            for (let channel = 0; channel < numChannels; channel++) {\n                const channelArray = this.toArray(channel);\n                for (let i = 0; i < channelArray.length; i++) {\n                    outputArray[i] += channelArray[i];\n                }\n            }\n            // divide by the number of channels\n            outputArray = outputArray.map((sample) => sample / numChannels);\n            this.fromArray(outputArray);\n        }\n        return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n    toArray(channel) {\n        if (isNumber(channel)) {\n            return this.getChannelData(channel);\n        }\n        else if (this.numberOfChannels === 1) {\n            return this.toArray(0);\n        }\n        else {\n            const ret = [];\n            for (let c = 0; c < this.numberOfChannels; c++) {\n                ret[c] = this.getChannelData(c);\n            }\n            return ret;\n        }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n    getChannelData(channel) {\n        if (this._buffer) {\n            return this._buffer.getChannelData(channel);\n        }\n        else {\n            return new Float32Array(0);\n        }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n    slice(start, end = this.duration) {\n        assert(this.loaded, \"Buffer is not loaded\");\n        const startSamples = Math.floor(start * this.sampleRate);\n        const endSamples = Math.floor(end * this.sampleRate);\n        assert(startSamples < endSamples, \"The start time must be less than the end time\");\n        const length = endSamples - startSamples;\n        const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n        for (let channel = 0; channel < this.numberOfChannels; channel++) {\n            retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n        }\n        return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n    _reverse() {\n        if (this.loaded) {\n            for (let i = 0; i < this.numberOfChannels; i++) {\n                this.getChannelData(i).reverse();\n            }\n        }\n        return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n    get loaded() {\n        return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n    get duration() {\n        if (this._buffer) {\n            return this._buffer.duration;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n    get length() {\n        if (this._buffer) {\n            return this._buffer.length;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n    get numberOfChannels() {\n        if (this._buffer) {\n            return this._buffer.numberOfChannels;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Reverse the buffer.\n     */\n    get reverse() {\n        return this._reversed;\n    }\n    set reverse(rev) {\n        if (this._reversed !== rev) {\n            this._reversed = rev;\n            this._reverse();\n        }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n    static fromArray(array) {\n        return new ToneAudioBuffer().fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n    static fromUrl(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buffer = new ToneAudioBuffer();\n            return yield buffer.load(url);\n        });\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n    static load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // make sure there is a slash between the baseUrl and the url\n            const baseUrl = ToneAudioBuffer.baseUrl === \"\" ||\n                ToneAudioBuffer.baseUrl.endsWith(\"/\")\n                ? ToneAudioBuffer.baseUrl\n                : ToneAudioBuffer.baseUrl + \"/\";\n            const response = yield fetch(baseUrl + url);\n            if (!response.ok) {\n                throw new Error(`could not load url: ${url}`);\n            }\n            const arrayBuffer = yield response.arrayBuffer();\n            const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n            return audioBuffer;\n        });\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n    static supportsType(url) {\n        const extensions = url.split(\".\");\n        const extension = extensions[extensions.length - 1];\n        const response = document\n            .createElement(\"audio\")\n            .canPlayType(\"audio/\" + extension);\n        return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n    static loaded() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // this makes sure that the function is always async\n            yield Promise.resolve();\n            while (ToneAudioBuffer.downloads.length) {\n                yield ToneAudioBuffer.downloads[0];\n            }\n        });\n    }\n}\n//-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n/**\n * A path which is prefixed before every url.\n */\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\nToneAudioBuffer.downloads = [];\n//# sourceMappingURL=ToneAudioBuffer.js.map","import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext.js\";\nimport { Context } from \"../context/Context.js\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n    constructor() {\n        super({\n            clockSource: \"offline\",\n            context: isOfflineAudioContext(arguments[0])\n                ? arguments[0]\n                : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n            lookAhead: 0,\n            updateInterval: isOfflineAudioContext(arguments[0])\n                ? 128 / arguments[0].sampleRate\n                : 128 / arguments[2],\n        });\n        this.name = \"OfflineContext\";\n        /**\n         * An artificial clock source\n         */\n        this._currentTime = 0;\n        this.isOffline = true;\n        this._duration = isOfflineAudioContext(arguments[0])\n            ? arguments[0].length / arguments[0].sampleRate\n            : arguments[1];\n    }\n    /**\n     * Override the now method to point to the internal clock time\n     */\n    now() {\n        return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n    get currentTime() {\n        return this._currentTime;\n    }\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    _renderClock(asynchronous) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let index = 0;\n            while (this._duration - this._currentTime >= 0) {\n                // invoke all the callbacks on that time\n                this.emit(\"tick\");\n                // increment the clock in block-sized chunks\n                this._currentTime += 128 / this.sampleRate;\n                // yield once a second of audio\n                index++;\n                const yieldEvery = Math.floor(this.sampleRate / 128);\n                if (asynchronous && index % yieldEvery === 0) {\n                    yield new Promise((done) => setTimeout(done, 1));\n                }\n            }\n        });\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n    render() {\n        return __awaiter(this, arguments, void 0, function* (asynchronous = true) {\n            yield this.workletsAreReady();\n            yield this._renderClock(asynchronous);\n            const buffer = yield this._context.startRendering();\n            return new ToneAudioBuffer(buffer);\n        });\n    }\n    /**\n     * Close the context\n     */\n    close() {\n        return Promise.resolve();\n    }\n}\n//# sourceMappingURL=OfflineContext.js.map","import { version } from \"../version.js\";\nimport { hasAudioContext, theWindow, } from \"./context/AudioContext.js\";\nimport { Context } from \"./context/Context.js\";\nimport { DummyContext } from \"./context/DummyContext.js\";\nimport { OfflineContext } from \"./context/OfflineContext.js\";\nimport { isAudioContext, isOfflineAudioContext, } from \"./util/AdvancedTypeCheck.js\";\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext = new DummyContext();\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext = dummyContext;\n/**\n * Returns the default system-wide {@link Context}\n * @category Core\n */\nexport function getContext() {\n    if (globalContext === dummyContext && hasAudioContext) {\n        setContext(new Context());\n    }\n    return globalContext;\n}\n/**\n * Set the default audio context\n * @param context\n * @param disposeOld Pass `true` if you don't need the old context to dispose it.\n * @category Core\n */\nexport function setContext(context, disposeOld = false) {\n    if (disposeOld) {\n        globalContext.dispose();\n    }\n    if (isAudioContext(context)) {\n        globalContext = new Context(context);\n    }\n    else if (isOfflineAudioContext(context)) {\n        globalContext = new OfflineContext(context);\n    }\n    else {\n        globalContext = context;\n    }\n}\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\nexport function start() {\n    return globalContext.resume();\n}\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n    let prefix = \"v\";\n    if (version === \"dev\") {\n        prefix = \"\";\n    }\n    const printString = ` * Tone.js ${prefix}${version} * `;\n    // eslint-disable-next-line no-console\n    console.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n//# sourceMappingURL=Global.js.map","/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent) {\n    const piFactor = 0.5 * Math.PI;\n    return Math.sin(percent * piFactor);\n}\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db) {\n    return Math.pow(10, db / 20);\n}\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain) {\n    return 20 * (Math.log(gain) / Math.LN10);\n}\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval) {\n    return Math.pow(2, interval / 12);\n}\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4 = 440;\nexport function getA4() {\n    return A4;\n}\nexport function setA4(freq) {\n    A4 = freq;\n}\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\nexport function ftom(frequency) {\n    return Math.round(ftomf(frequency));\n}\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency) {\n    return 69 + 12 * Math.log2(frequency / A4);\n}\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\nexport function mtof(midi) {\n    return A4 * Math.pow(2, (midi - 69) / 12);\n}\n//# sourceMappingURL=Conversions.js.map","import { Tone } from \"../Tone.js\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck.js\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport class TimeBaseClass extends Tone {\n    /**\n     * @param context The context associated with the time value. Used to compute\n     * Transport and context-relative timing.\n     * @param  value  The time value as a number, string or object\n     * @param  units  Unit values\n     */\n    constructor(context, value, units) {\n        super();\n        /**\n         * The default units\n         */\n        this.defaultUnits = \"s\";\n        this._val = value;\n        this._units = units;\n        this.context = context;\n        this._expressions = this._getExpressions();\n    }\n    /**\n     * All of the time encoding expressions\n     */\n    _getExpressions() {\n        return {\n            hz: {\n                method: (value) => {\n                    return this._frequencyToUnits(parseFloat(value));\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n            },\n            i: {\n                method: (value) => {\n                    return this._ticksToUnits(parseInt(value, 10));\n                },\n                regexp: /^(\\d+)i$/i,\n            },\n            m: {\n                method: (value) => {\n                    return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n                },\n                regexp: /^(\\d+)m$/i,\n            },\n            n: {\n                method: (value, dot) => {\n                    const numericValue = parseInt(value, 10);\n                    const scalar = dot === \".\" ? 1.5 : 1;\n                    if (numericValue === 1) {\n                        return (this._beatsToUnits(this._getTimeSignature()) *\n                            scalar);\n                    }\n                    else {\n                        return (this._beatsToUnits(4 / numericValue) *\n                            scalar);\n                    }\n                },\n                regexp: /^(\\d+)n(\\.?)$/i,\n            },\n            number: {\n                method: (value) => {\n                    return this._expressions[this.defaultUnits].method.call(this, value);\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)$/,\n            },\n            s: {\n                method: (value) => {\n                    return this._secondsToUnits(parseFloat(value));\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)s$/,\n            },\n            samples: {\n                method: (value) => {\n                    return (parseInt(value, 10) /\n                        this.context.sampleRate);\n                },\n                regexp: /^(\\d+)samples$/,\n            },\n            t: {\n                method: (value) => {\n                    const numericValue = parseInt(value, 10);\n                    return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n                },\n                regexp: /^(\\d+)t$/i,\n            },\n            tr: {\n                method: (m, q, s) => {\n                    let total = 0;\n                    if (m && m !== \"0\") {\n                        total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n                    }\n                    if (q && q !== \"0\") {\n                        total += this._beatsToUnits(parseFloat(q));\n                    }\n                    if (s && s !== \"0\") {\n                        total += this._beatsToUnits(parseFloat(s) / 4);\n                    }\n                    return total;\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n            },\n        };\n    }\n    //-------------------------------------\n    // \tVALUE OF\n    //-------------------------------------\n    /**\n     * Evaluate the time value. Returns the time in seconds.\n     */\n    valueOf() {\n        if (this._val instanceof TimeBaseClass) {\n            this.fromType(this._val);\n        }\n        if (isUndef(this._val)) {\n            return this._noArg();\n        }\n        else if (isString(this._val) && isUndef(this._units)) {\n            for (const units in this._expressions) {\n                if (this._expressions[units].regexp.test(this._val.trim())) {\n                    this._units = units;\n                    break;\n                }\n            }\n        }\n        else if (isObject(this._val)) {\n            let total = 0;\n            for (const typeName in this._val) {\n                if (isDefined(this._val[typeName])) {\n                    const quantity = this._val[typeName];\n                    const time = \n                    // @ts-ignore\n                    new this.constructor(this.context, typeName).valueOf() *\n                        quantity;\n                    total += time;\n                }\n            }\n            return total;\n        }\n        if (isDefined(this._units)) {\n            const expr = this._expressions[this._units];\n            const matching = this._val.toString().trim().match(expr.regexp);\n            if (matching) {\n                return expr.method.apply(this, matching.slice(1));\n            }\n            else {\n                return expr.method.call(this, this._val);\n            }\n        }\n        else if (isString(this._val)) {\n            return parseFloat(this._val);\n        }\n        else {\n            return this._val;\n        }\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS\n    //-------------------------------------\n    /**\n     * Returns the value of a frequency in the current units\n     */\n    _frequencyToUnits(freq) {\n        return (1 / freq);\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return ((60 / this._getBpm()) * beats);\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return seconds;\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return ((ticks * this._beatsToUnits(1)) / this._getPPQ());\n    }\n    /**\n     * With no arguments, return 'now'\n     */\n    _noArg() {\n        return this._now();\n    }\n    //-------------------------------------\n    // \tTEMPO CONVERSIONS\n    //-------------------------------------\n    /**\n     * Return the bpm\n     */\n    _getBpm() {\n        return this.context.transport.bpm.value;\n    }\n    /**\n     * Return the timeSignature\n     */\n    _getTimeSignature() {\n        return this.context.transport.timeSignature;\n    }\n    /**\n     * Return the PPQ or 192 if Transport is not available\n     */\n    _getPPQ() {\n        return this.context.transport.PPQ;\n    }\n    //-------------------------------------\n    // \tCONVERSION INTERFACE\n    //-------------------------------------\n    /**\n     * Coerce a time type into this units type.\n     * @param type Any time type units\n     */\n    fromType(type) {\n        this._units = undefined;\n        switch (this.defaultUnits) {\n            case \"s\":\n                this._val = type.toSeconds();\n                break;\n            case \"i\":\n                this._val = type.toTicks();\n                break;\n            case \"hz\":\n                this._val = type.toFrequency();\n                break;\n            case \"midi\":\n                this._val = type.toMidi();\n                break;\n        }\n        return this;\n    }\n    /**\n     * Return the value in hertz\n     */\n    toFrequency() {\n        return 1 / this.toSeconds();\n    }\n    /**\n     * Return the time in samples\n     */\n    toSamples() {\n        return this.toSeconds() * this.context.sampleRate;\n    }\n    /**\n     * Return the time in milliseconds.\n     */\n    toMilliseconds() {\n        return this.toSeconds() * 1000;\n    }\n}\n//# sourceMappingURL=TimeBase.js.map","import { getContext } from \"../Global.js\";\nimport { ftom } from \"./Conversions.js\";\nimport { TimeBaseClass, } from \"./TimeBase.js\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass extends TimeBaseClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"TimeClass\";\n    }\n    _getExpressions() {\n        return Object.assign(super._getExpressions(), {\n            now: {\n                method: (capture) => {\n                    return (this._now() +\n                        new this.constructor(this.context, capture).valueOf());\n                },\n                regexp: /^\\+(.+)/,\n            },\n            quantize: {\n                method: (capture) => {\n                    const quantTo = new TimeClass(this.context, capture).valueOf();\n                    return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n                },\n                regexp: /^@(.+)/,\n            },\n        });\n    }\n    /**\n     * Quantize the time by the given subdivision. Optionally add a\n     * percentage which will move the time value towards the ideal\n     * quantized value by that percentage.\n     * @param  subdiv    The subdivision to quantize to\n     * @param  percent  Move the time value towards the quantized value by a percentage.\n     * @example\n     * Tone.Time(21).quantize(2); // returns 22\n     * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n     */\n    quantize(subdiv, percent = 1) {\n        const subdivision = new this.constructor(this.context, subdiv).valueOf();\n        const value = this.valueOf();\n        const multiple = Math.round(value / subdivision);\n        const ideal = multiple * subdivision;\n        const diff = ideal - value;\n        return (value + diff * percent);\n    }\n    //-------------------------------------\n    // CONVERSIONS\n    //-------------------------------------\n    /**\n     * Convert a Time to Notation. The notation values are will be the\n     * closest representation between 1m to 128th note.\n     * @return {Notation}\n     * @example\n     * // if the Transport is at 120bpm:\n     * Tone.Time(2).toNotation(); // returns \"1m\"\n     */\n    toNotation() {\n        const time = this.toSeconds();\n        const testNotations = [\"1m\"];\n        for (let power = 1; power < 9; power++) {\n            const subdiv = Math.pow(2, power);\n            testNotations.push((subdiv + \"n.\"));\n            testNotations.push((subdiv + \"n\"));\n            testNotations.push((subdiv + \"t\"));\n        }\n        testNotations.push(\"0\");\n        // find the closets notation representation\n        let closest = testNotations[0];\n        let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n        testNotations.forEach((notation) => {\n            const notationSeconds = new TimeClass(this.context, notation).toSeconds();\n            if (Math.abs(notationSeconds - time) <\n                Math.abs(closestSeconds - time)) {\n                closest = notation;\n                closestSeconds = notationSeconds;\n            }\n        });\n        return closest;\n    }\n    /**\n     * Return the time encoded as Bars:Beats:Sixteenths.\n     */\n    toBarsBeatsSixteenths() {\n        const quarterTime = this._beatsToUnits(1);\n        let quarters = this.valueOf() / quarterTime;\n        quarters = parseFloat(quarters.toFixed(4));\n        const measures = Math.floor(quarters / this._getTimeSignature());\n        let sixteenths = (quarters % 1) * 4;\n        quarters = Math.floor(quarters) % this._getTimeSignature();\n        const sixteenthString = sixteenths.toString();\n        if (sixteenthString.length > 3) {\n            // the additional parseFloat removes insignificant trailing zeroes\n            sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n        }\n        const progress = [measures, quarters, sixteenths];\n        return progress.join(\":\");\n    }\n    /**\n     * Return the time in ticks.\n     */\n    toTicks() {\n        const quarterTime = this._beatsToUnits(1);\n        const quarters = this.valueOf() / quarterTime;\n        return quarters * this._getPPQ();\n    }\n    /**\n     * Return the time in seconds.\n     */\n    toSeconds() {\n        return this.valueOf();\n    }\n    /**\n     * Return the value as a midi note.\n     */\n    toMidi() {\n        return ftom(this.toFrequency());\n    }\n    _now() {\n        return this.context.now();\n    }\n}\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use {@link TimeClass}\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value, units) {\n    return new TimeClass(getContext(), value, units);\n}\n//# sourceMappingURL=Time.js.map","/* eslint-disable key-spacing */\nimport { getContext } from \"../Global.js\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions.js\";\nimport { ftom, getA4, setA4 } from \"./Conversions.js\";\nimport { TimeClass } from \"./Time.js\";\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `valueOf` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass extends TimeClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"Frequency\";\n        this.defaultUnits = \"hz\";\n    }\n    /**\n     * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n     * to generate all the other pitch values from notes. A4's values in Hertz.\n     */\n    static get A4() {\n        return getA4();\n    }\n    static set A4(freq) {\n        setA4(freq);\n    }\n    //-------------------------------------\n    // \tAUGMENT BASE EXPRESSIONS\n    //-------------------------------------\n    _getExpressions() {\n        return Object.assign({}, super._getExpressions(), {\n            midi: {\n                regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n                method(value) {\n                    if (this.defaultUnits === \"midi\") {\n                        return value;\n                    }\n                    else {\n                        return FrequencyClass.mtof(value);\n                    }\n                },\n            },\n            note: {\n                regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,\n                method(pitch, octave) {\n                    const index = noteToScaleIndex[pitch.toLowerCase()];\n                    const noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n                    if (this.defaultUnits === \"midi\") {\n                        return noteNumber;\n                    }\n                    else {\n                        return FrequencyClass.mtof(noteNumber);\n                    }\n                },\n            },\n            tr: {\n                regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n                method(m, q, s) {\n                    let total = 1;\n                    if (m && m !== \"0\") {\n                        total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n                    }\n                    if (q && q !== \"0\") {\n                        total *= this._beatsToUnits(parseFloat(q));\n                    }\n                    if (s && s !== \"0\") {\n                        total *= this._beatsToUnits(parseFloat(s) / 4);\n                    }\n                    return total;\n                },\n            },\n        });\n    }\n    //-------------------------------------\n    // \tEXPRESSIONS\n    //-------------------------------------\n    /**\n     * Transposes the frequency by the given number of semitones.\n     * @return  A new transposed frequency\n     * @example\n     * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n     */\n    transpose(interval) {\n        return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n    }\n    /**\n     * Takes an array of semitone intervals and returns\n     * an array of frequencies transposed by those intervals.\n     * @return  Returns an array of Frequencies\n     * @example\n     * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n     */\n    harmonize(intervals) {\n        return intervals.map((interval) => {\n            return this.transpose(interval);\n        });\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS\n    //-------------------------------------\n    /**\n     * Return the value of the frequency as a MIDI note\n     * @example\n     * Tone.Frequency(\"C4\").toMidi(); // 60\n     */\n    toMidi() {\n        return ftom(this.valueOf());\n    }\n    /**\n     * Return the value of the frequency in Scientific Pitch Notation\n     * @example\n     * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n     */\n    toNote() {\n        const freq = this.toFrequency();\n        const log = Math.log2(freq / FrequencyClass.A4);\n        let noteNumber = Math.round(12 * log) + 57;\n        const octave = Math.floor(noteNumber / 12);\n        if (octave < 0) {\n            noteNumber += -12 * octave;\n        }\n        const noteName = scaleIndexToNote[noteNumber % 12];\n        return (noteName + octave.toString());\n    }\n    /**\n     * Return the duration of one cycle in seconds.\n     */\n    toSeconds() {\n        return 1 / super.toSeconds();\n    }\n    /**\n     * Return the duration of one cycle in ticks\n     */\n    toTicks() {\n        const quarterTime = this._beatsToUnits(1);\n        const quarters = this.valueOf() / quarterTime;\n        return Math.floor(quarters * this._getPPQ());\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS HELPERS\n    //-------------------------------------\n    /**\n     * With no arguments, return 0\n     */\n    _noArg() {\n        return 0;\n    }\n    /**\n     * Returns the value of a frequency in the current units\n     */\n    _frequencyToUnits(freq) {\n        return freq;\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return (1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())));\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return (1 / super._beatsToUnits(beats));\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return (1 / seconds);\n    }\n    /**\n     * Convert a MIDI note to frequency value.\n     * @param  midi The midi number to convert.\n     * @return The corresponding frequency value\n     */\n    static mtof(midi) {\n        return mtof(midi);\n    }\n    /**\n     * Convert a frequency value to a MIDI note.\n     * @param frequency The value to frequency value to convert.\n     */\n    static ftom(frequency) {\n        return ftom(frequency);\n    }\n}\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n/**\n * Note to scale index.\n * @hidden\n */\nconst noteToScaleIndex = {\n    cbbb: -3,\n    cbb: -2,\n    cb: -1,\n    c: 0,\n    \"c#\": 1,\n    cx: 2,\n    \"c##\": 2,\n    \"c###\": 3,\n    \"cx#\": 3,\n    \"c#x\": 3,\n    dbbb: -1,\n    dbb: 0,\n    db: 1,\n    d: 2,\n    \"d#\": 3,\n    dx: 4,\n    \"d##\": 4,\n    \"d###\": 5,\n    \"dx#\": 5,\n    \"d#x\": 5,\n    ebbb: 1,\n    ebb: 2,\n    eb: 3,\n    e: 4,\n    \"e#\": 5,\n    ex: 6,\n    \"e##\": 6,\n    \"e###\": 7,\n    \"ex#\": 7,\n    \"e#x\": 7,\n    fbbb: 2,\n    fbb: 3,\n    fb: 4,\n    f: 5,\n    \"f#\": 6,\n    fx: 7,\n    \"f##\": 7,\n    \"f###\": 8,\n    \"fx#\": 8,\n    \"f#x\": 8,\n    gbbb: 4,\n    gbb: 5,\n    gb: 6,\n    g: 7,\n    \"g#\": 8,\n    gx: 9,\n    \"g##\": 9,\n    \"g###\": 10,\n    \"gx#\": 10,\n    \"g#x\": 10,\n    abbb: 6,\n    abb: 7,\n    ab: 8,\n    a: 9,\n    \"a#\": 10,\n    ax: 11,\n    \"a##\": 11,\n    \"a###\": 12,\n    \"ax#\": 12,\n    \"a#x\": 12,\n    bbbb: 8,\n    bbb: 9,\n    bb: 10,\n    b: 11,\n    \"b#\": 12,\n    bx: 13,\n    \"b##\": 13,\n    \"b###\": 14,\n    \"bx#\": 14,\n    \"b#x\": 14,\n};\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\n    \"C\",\n    \"C#\",\n    \"D\",\n    \"D#\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"G\",\n    \"G#\",\n    \"A\",\n    \"A#\",\n    \"B\",\n];\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n * @example\n * const midi = Tone.Frequency(\"C3\").toMidi();\n * console.log(midi);\n * @example\n * const hertz = Tone.Frequency(38, \"midi\").toFrequency();\n * console.log(hertz);\n */\nexport function Frequency(value, units) {\n    return new FrequencyClass(getContext(), value, units);\n}\n//# sourceMappingURL=Frequency.js.map","import { getContext } from \"../Global.js\";\nimport { TimeClass } from \"./Time.js\";\n/**\n * TransportTime is a time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass extends TimeClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"TransportTime\";\n    }\n    /**\n     * Return the current time in whichever context is relevant\n     */\n    _now() {\n        return this.context.transport.seconds;\n    }\n}\n/**\n * TransportTime is a time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value, units) {\n    return new TransportTimeClass(getContext(), value, units);\n}\n//# sourceMappingURL=TransportTime.js.map","import { getContext } from \"../Global.js\";\nimport { Tone } from \"../Tone.js\";\nimport { FrequencyClass } from \"../type/Frequency.js\";\nimport { TimeClass } from \"../type/Time.js\";\nimport { TransportTimeClass } from \"../type/TransportTime.js\";\nimport { assertUsedScheduleTime } from \"../util/Debug.js\";\nimport { getDefaultsFromInstance, optionsFromArguments, } from \"../util/Defaults.js\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef, } from \"../util/TypeCheck.js\";\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport class ToneWithContext extends Tone {\n    constructor() {\n        super();\n        const options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n        if (this.defaultContext) {\n            this.context = this.defaultContext;\n        }\n        else {\n            this.context = options.context;\n        }\n    }\n    static getDefaults() {\n        return {\n            context: getContext(),\n        };\n    }\n    /**\n     * Return the current time of the Context clock plus the lookAhead.\n     * @example\n     * setInterval(() => {\n     * \tconsole.log(Tone.now());\n     * }, 100);\n     */\n    now() {\n        return this.context.currentTime + this.context.lookAhead;\n    }\n    /**\n     * Return the current time of the Context clock without any lookAhead.\n     * @example\n     * setInterval(() => {\n     * \tconsole.log(Tone.immediate());\n     * }, 100);\n     */\n    immediate() {\n        return this.context.currentTime;\n    }\n    /**\n     * The duration in seconds of one sample.\n     */\n    get sampleTime() {\n        return 1 / this.context.sampleRate;\n    }\n    /**\n     * The number of seconds of 1 processing block (128 samples)\n     * @example\n     * console.log(Tone.Destination.blockTime);\n     */\n    get blockTime() {\n        return 128 / this.context.sampleRate;\n    }\n    /**\n     * Convert the incoming time to seconds.\n     * This is calculated against the current {@link TransportClass} bpm\n     * @example\n     * const gain = new Tone.Gain();\n     * setInterval(() => console.log(gain.toSeconds(\"4n\")), 100);\n     * // ramp the tempo to 60 bpm over 30 seconds\n     * Tone.getTransport().bpm.rampTo(60, 30);\n     */\n    toSeconds(time) {\n        assertUsedScheduleTime(time);\n        return new TimeClass(this.context, time).toSeconds();\n    }\n    /**\n     * Convert the input to a frequency number\n     * @example\n     * const gain = new Tone.Gain();\n     * console.log(gain.toFrequency(\"4n\"));\n     */\n    toFrequency(freq) {\n        return new FrequencyClass(this.context, freq).toFrequency();\n    }\n    /**\n     * Convert the input time into ticks\n     * @example\n     * const gain = new Tone.Gain();\n     * console.log(gain.toTicks(\"4n\"));\n     */\n    toTicks(time) {\n        return new TransportTimeClass(this.context, time).toTicks();\n    }\n    //-------------------------------------\n    // \tGET/SET\n    //-------------------------------------\n    /**\n     * Get a subset of the properties which are in the partial props\n     */\n    _getPartialProperties(props) {\n        const options = this.get();\n        // remove attributes from the prop that are not in the partial\n        Object.keys(options).forEach((name) => {\n            if (isUndef(props[name])) {\n                delete options[name];\n            }\n        });\n        return options;\n    }\n    /**\n     * Get the object's attributes.\n     * @example\n     * const osc = new Tone.Oscillator();\n     * console.log(osc.get());\n     */\n    get() {\n        const defaults = getDefaultsFromInstance(this);\n        Object.keys(defaults).forEach((attribute) => {\n            if (Reflect.has(this, attribute)) {\n                const member = this[attribute];\n                if (isDefined(member) &&\n                    isDefined(member.value) &&\n                    isDefined(member.setValueAtTime)) {\n                    defaults[attribute] = member.value;\n                }\n                else if (member instanceof ToneWithContext) {\n                    defaults[attribute] = member._getPartialProperties(defaults[attribute]);\n                    // otherwise make sure it's a serializable type\n                }\n                else if (isArray(member) ||\n                    isNumber(member) ||\n                    isString(member) ||\n                    isBoolean(member)) {\n                    defaults[attribute] = member;\n                }\n                else {\n                    // remove all undefined and unserializable attributes\n                    delete defaults[attribute];\n                }\n            }\n        });\n        return defaults;\n    }\n    /**\n     * Set multiple properties at once with an object.\n     * @example\n     * const filter = new Tone.Filter().toDestination();\n     * // set values using an object\n     * filter.set({\n     * \tfrequency: \"C6\",\n     * \ttype: \"highpass\"\n     * });\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3\").connect(filter);\n     * player.autostart = true;\n     */\n    set(props) {\n        Object.keys(props).forEach((attribute) => {\n            if (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n                if (this[attribute] &&\n                    isDefined(this[attribute].value) &&\n                    isDefined(this[attribute].setValueAtTime)) {\n                    // small optimization\n                    if (this[attribute].value !== props[attribute]) {\n                        this[attribute].value = props[attribute];\n                    }\n                }\n                else if (this[attribute] instanceof ToneWithContext) {\n                    this[attribute].set(props[attribute]);\n                }\n                else {\n                    this[attribute] = props[attribute];\n                }\n            }\n        });\n        return this;\n    }\n}\n//# sourceMappingURL=ToneWithContext.js.map","import { Timeline } from \"./Timeline.js\";\nimport { assertRange } from \"./Debug.js\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n * @internal\n */\nexport class StateTimeline extends Timeline {\n    constructor(initial = \"stopped\") {\n        super();\n        this.name = \"StateTimeline\";\n        this._initial = initial;\n        this.setStateAtTime(this._initial, 0);\n    }\n    /**\n     * Returns the scheduled state scheduled before or at\n     * the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     */\n    getValueAtTime(time) {\n        const event = this.get(time);\n        if (event !== null) {\n            return event.state;\n        }\n        else {\n            return this._initial;\n        }\n    }\n    /**\n     * Add a state to the timeline.\n     * @param  state The name of the state to set.\n     * @param  time  The time to query.\n     * @param options Any additional options that are needed in the timeline.\n     */\n    setStateAtTime(state, time, options) {\n        assertRange(time, 0);\n        this.add(Object.assign({}, options, {\n            state,\n            time,\n        }));\n        return this;\n    }\n    /**\n     * Return the event before the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check before\n     * @return  The event with the given state before the time\n     */\n    getLastState(state, time) {\n        // time = this.toSeconds(time);\n        const index = this._search(time);\n        for (let i = index; i >= 0; i--) {\n            const event = this._timeline[i];\n            if (event.state === state) {\n                return event;\n            }\n        }\n    }\n    /**\n     * Return the event after the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check from\n     * @return  The event with the given state after the time\n     */\n    getNextState(state, time) {\n        // time = this.toSeconds(time);\n        const index = this._search(time);\n        if (index !== -1) {\n            for (let i = index; i < this._timeline.length; i++) {\n                const event = this._timeline[i];\n                if (event.state === state) {\n                    return event;\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=StateTimeline.js.map","import { dbToGain, gainToDb } from \"../type/Conversions.js\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { ToneWithContext } from \"./ToneWithContext.js\";\nimport { EQ } from \"../util/Math.js\";\nimport { assert, assertRange } from \"../util/Debug.js\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param extends ToneWithContext {\n    constructor() {\n        const options = optionsFromArguments(Param.getDefaults(), arguments, [\n            \"param\",\n            \"units\",\n            \"convert\",\n        ]);\n        super(options);\n        this.name = \"Param\";\n        this.overridden = false;\n        /**\n         * The minimum output value\n         */\n        this._minOutput = 1e-7;\n        assert(isDefined(options.param) &&\n            (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n        while (!isAudioParam(options.param)) {\n            options.param = options.param._param;\n        }\n        this._swappable = isDefined(options.swappable)\n            ? options.swappable\n            : false;\n        if (this._swappable) {\n            this.input = this.context.createGain();\n            // initialize\n            this._param = options.param;\n            this.input.connect(this._param);\n        }\n        else {\n            this._param = this.input = options.param;\n        }\n        this._events = new Timeline(1000);\n        this._initialValue = this._param.defaultValue;\n        this.units = options.units;\n        this.convert = options.convert;\n        this._minValue = options.minValue;\n        this._maxValue = options.maxValue;\n        // if the value is defined, set it immediately\n        if (isDefined(options.value) &&\n            options.value !== this._toType(this._initialValue)) {\n            this.setValueAtTime(options.value, 0);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            convert: true,\n            units: \"number\",\n        });\n    }\n    get value() {\n        const now = this.now();\n        return this.getValueAtTime(now);\n    }\n    set value(value) {\n        this.cancelScheduledValues(this.now());\n        this.setValueAtTime(value, this.now());\n    }\n    get minValue() {\n        // if it's not the default minValue, return it\n        if (isDefined(this._minValue)) {\n            return this._minValue;\n        }\n        else if (this.units === \"time\" ||\n            this.units === \"frequency\" ||\n            this.units === \"normalRange\" ||\n            this.units === \"positive\" ||\n            this.units === \"transportTime\" ||\n            this.units === \"ticks\" ||\n            this.units === \"bpm\" ||\n            this.units === \"hertz\" ||\n            this.units === \"samples\") {\n            return 0;\n        }\n        else if (this.units === \"audioRange\") {\n            return -1;\n        }\n        else if (this.units === \"decibels\") {\n            return -Infinity;\n        }\n        else {\n            return this._param.minValue;\n        }\n    }\n    get maxValue() {\n        if (isDefined(this._maxValue)) {\n            return this._maxValue;\n        }\n        else if (this.units === \"normalRange\" ||\n            this.units === \"audioRange\") {\n            return 1;\n        }\n        else {\n            return this._param.maxValue;\n        }\n    }\n    /**\n     * Type guard based on the unit name\n     */\n    _is(arg, type) {\n        return this.units === type;\n    }\n    /**\n     * Make sure the value is always in the defined range\n     */\n    _assertRange(value) {\n        if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n            assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n        }\n        return value;\n    }\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n    _fromType(val) {\n        if (this.convert && !this.overridden) {\n            if (this._is(val, \"time\")) {\n                return this.toSeconds(val);\n            }\n            else if (this._is(val, \"decibels\")) {\n                return dbToGain(val);\n            }\n            else if (this._is(val, \"frequency\")) {\n                return this.toFrequency(val);\n            }\n            else {\n                return val;\n            }\n        }\n        else if (this.overridden) {\n            // if it's overridden, should only schedule 0s\n            return 0;\n        }\n        else {\n            return val;\n        }\n    }\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n    _toType(val) {\n        if (this.convert && this.units === \"decibels\") {\n            return gainToDb(val);\n        }\n        else {\n            return val;\n        }\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n    setValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        const numericValue = this._fromType(value);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n        this._assertRange(numericValue);\n        this.log(this.units, \"setValueAtTime\", value, computedTime);\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: numericValue,\n        });\n        this._param.setValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    getValueAtTime(time) {\n        const computedTime = Math.max(this.toSeconds(time), 0);\n        const after = this._events.getAfter(computedTime);\n        const before = this._events.get(computedTime);\n        let value = this._initialValue;\n        // if it was set by\n        if (before === null) {\n            value = this._initialValue;\n        }\n        else if (before.type === \"setTargetAtTime\" &&\n            (after === null || after.type === \"setValueAtTime\")) {\n            const previous = this._events.getBefore(before.time);\n            let previousVal;\n            if (previous === null) {\n                previousVal = this._initialValue;\n            }\n            else {\n                previousVal = previous.value;\n            }\n            if (before.type === \"setTargetAtTime\") {\n                value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n            }\n        }\n        else if (after === null) {\n            value = before.value;\n        }\n        else if (after.type === \"linearRampToValueAtTime\" ||\n            after.type === \"exponentialRampToValueAtTime\") {\n            let beforeValue = before.value;\n            if (before.type === \"setTargetAtTime\") {\n                const previous = this._events.getBefore(before.time);\n                if (previous === null) {\n                    beforeValue = this._initialValue;\n                }\n                else {\n                    beforeValue = previous.value;\n                }\n            }\n            if (after.type === \"linearRampToValueAtTime\") {\n                value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n            else {\n                value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n        }\n        else {\n            value = before.value;\n        }\n        return this._toType(value);\n    }\n    setRampPoint(time) {\n        time = this.toSeconds(time);\n        let currentVal = this.getValueAtTime(time);\n        this.cancelAndHoldAtTime(time);\n        if (this._fromType(currentVal) === 0) {\n            currentVal = this._toType(this._minOutput);\n        }\n        this.setValueAtTime(currentVal, time);\n        return this;\n    }\n    linearRampToValueAtTime(value, endTime) {\n        const numericValue = this._fromType(value);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        this._assertRange(numericValue);\n        this._events.add({\n            time: computedTime,\n            type: \"linearRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n        this._param.linearRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, endTime) {\n        let numericValue = this._fromType(value);\n        // the value can't be 0\n        numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n        this._assertRange(numericValue);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        // store the event\n        this._events.add({\n            time: computedTime,\n            type: \"exponentialRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n        this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialApproachValueAtTime(value, startTime, rampTime);\n        return this;\n    }\n    exponentialApproachValueAtTime(value, time, rampTime) {\n        time = this.toSeconds(time);\n        rampTime = this.toSeconds(rampTime);\n        const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n        this.setTargetAtTime(value, time, timeConstant);\n        // at 90% start a linear ramp to the final value\n        this.cancelAndHoldAtTime(time + rampTime * 0.9);\n        this.linearRampToValueAtTime(value, time + rampTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        const numericValue = this._fromType(value);\n        // The value will never be able to approach without timeConstant > 0.\n        assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n        const computedTime = this.toSeconds(startTime);\n        this._assertRange(numericValue);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n        this._events.add({\n            constant: timeConstant,\n            time: computedTime,\n            type: \"setTargetAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n        this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n        duration = this.toSeconds(duration);\n        startTime = this.toSeconds(startTime);\n        const startingValue = this._fromType(values[0]) * scaling;\n        this.setValueAtTime(this._toType(startingValue), startTime);\n        const segTime = duration / (values.length - 1);\n        for (let i = 1; i < values.length; i++) {\n            const numericValue = this._fromType(values[i]) * scaling;\n            this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n        }\n        return this;\n    }\n    cancelScheduledValues(time) {\n        const computedTime = this.toSeconds(time);\n        assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n        this._events.cancel(computedTime);\n        this._param.cancelScheduledValues(computedTime);\n        this.log(this.units, \"cancelScheduledValues\", computedTime);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n        // remove the schedule events\n        assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n        this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n        // if there is an event at the given computedTime\n        // and that even is not a \"set\"\n        const before = this._events.get(computedTime);\n        const after = this._events.getAfter(computedTime);\n        if (before && EQ(before.time, computedTime)) {\n            // remove everything after\n            if (after) {\n                this._param.cancelScheduledValues(after.time);\n                this._events.cancel(after.time);\n            }\n            else {\n                this._param.cancelAndHoldAtTime(computedTime);\n                this._events.cancel(computedTime + this.sampleTime);\n            }\n        }\n        else if (after) {\n            this._param.cancelScheduledValues(after.time);\n            // cancel the next event(s)\n            this._events.cancel(after.time);\n            if (after.type === \"linearRampToValueAtTime\") {\n                this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n            else if (after.type === \"exponentialRampToValueAtTime\") {\n                this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n        }\n        // set the value at the given time\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: valueAtTime,\n        });\n        this._param.setValueAtTime(valueAtTime, computedTime);\n        return this;\n    }\n    rampTo(value, rampTime = 0.1, startTime) {\n        if (this.units === \"frequency\" ||\n            this.units === \"bpm\" ||\n            this.units === \"decibels\") {\n            this.exponentialRampTo(value, rampTime, startTime);\n        }\n        else {\n            this.linearRampTo(value, rampTime, startTime);\n        }\n        return this;\n    }\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n    apply(param) {\n        const now = this.context.currentTime;\n        // set the param's value at the current time and schedule everything else\n        param.setValueAtTime(this.getValueAtTime(now), now);\n        // if the previous event was a curve, then set the rest of it\n        const previousEvent = this._events.get(now);\n        if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n            // approx it until the next event with linear ramps\n            const nextEvent = this._events.getAfter(previousEvent.time);\n            // or for 2 seconds if there is no event\n            const endTime = nextEvent ? nextEvent.time : now + 2;\n            const subdivisions = (endTime - now) / 10;\n            for (let i = now; i < endTime; i += subdivisions) {\n                param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n            }\n        }\n        this._events.forEachAfter(this.context.currentTime, (event) => {\n            if (event.type === \"cancelScheduledValues\") {\n                param.cancelScheduledValues(event.time);\n            }\n            else if (event.type === \"setTargetAtTime\") {\n                param.setTargetAtTime(event.value, event.time, event.constant);\n            }\n            else {\n                param[event.type](event.value, event.time);\n            }\n        });\n        return this;\n    }\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n    setParam(param) {\n        assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n        const input = this.input;\n        input.disconnect(this._param);\n        this.apply(param);\n        this._param = param;\n        input.connect(this._param);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._events.dispose();\n        return this;\n    }\n    get defaultValue() {\n        return this._toType(this._param.defaultValue);\n    }\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n    _exponentialApproach(t0, v0, v1, timeConstant, t) {\n        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    }\n    // Calculates the the value along the curve produced by linearRampToValueAtTime\n    _linearInterpolate(t0, v0, t1, v1, t) {\n        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    }\n    // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n    _exponentialInterpolate(t0, v0, t1, v1, t) {\n        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    }\n}\n//# sourceMappingURL=Param.js.map","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { Param } from \"./Param.js\";\nimport { ToneWithContext } from \"./ToneWithContext.js\";\nimport { assert, warn } from \"../util/Debug.js\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n * @category Core\n */\nexport class ToneAudioNode extends ToneWithContext {\n    constructor() {\n        super(...arguments);\n        /**\n         * List all of the node that must be set to match the ChannelProperties\n         */\n        this._internalChannels = [];\n    }\n    /**\n     * The number of inputs feeding into the AudioNode.\n     * For source nodes, this will be 0.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfInputs);\n     */\n    get numberOfInputs() {\n        if (isDefined(this.input)) {\n            if (isAudioParam(this.input) || this.input instanceof Param) {\n                return 1;\n            }\n            else {\n                return this.input.numberOfInputs;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n    get numberOfOutputs() {\n        if (isDefined(this.output)) {\n            return this.output.numberOfOutputs;\n        }\n        else {\n            return 0;\n        }\n    }\n    //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n    _isAudioNode(node) {\n        return (isDefined(node) &&\n            (node instanceof ToneAudioNode || isAudioNode(node)));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n    _getInternalNodes() {\n        const nodeList = this._internalChannels.slice(0);\n        if (this._isAudioNode(this.input)) {\n            nodeList.push(this.input);\n        }\n        if (this._isAudioNode(this.output)) {\n            if (this.input !== this.output) {\n                nodeList.push(this.output);\n            }\n        }\n        return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n    _setChannelProperties(options) {\n        const nodeList = this._getInternalNodes();\n        nodeList.forEach((node) => {\n            node.channelCount = options.channelCount;\n            node.channelCountMode = options.channelCountMode;\n            node.channelInterpretation = options.channelInterpretation;\n        });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n    _getChannelProperties() {\n        const nodeList = this._getInternalNodes();\n        assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n        // use the first node to get properties\n        // they should all be the same\n        const node = nodeList[0];\n        return {\n            channelCount: node.channelCount,\n            channelCountMode: node.channelCountMode,\n            channelInterpretation: node.channelInterpretation,\n        };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n    get channelCount() {\n        return this._getChannelProperties().channelCount;\n    }\n    set channelCount(channelCount) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCount }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n    get channelCountMode() {\n        return this._getChannelProperties().channelCountMode;\n    }\n    set channelCountMode(channelCountMode) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCountMode }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n    get channelInterpretation() {\n        return this._getChannelProperties().channelInterpretation;\n    }\n    set channelInterpretation(channelInterpretation) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelInterpretation }));\n    }\n    //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n    connect(destination, outputNum = 0, inputNum = 0) {\n        connect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n    toDestination() {\n        this.connect(this.context.destination);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @see {@link toDestination}\n     * @deprecated\n     */\n    toMaster() {\n        warn(\"toMaster() has been renamed toDestination()\");\n        return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n    disconnect(destination, outputNum = 0, inputNum = 0) {\n        disconnect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n    chain(...nodes) {\n        connectSeries(this, ...nodes);\n        return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n    fan(...nodes) {\n        nodes.forEach((node) => this.connect(node));\n        return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n    dispose() {\n        super.dispose();\n        if (isDefined(this.input)) {\n            if (this.input instanceof ToneAudioNode) {\n                this.input.dispose();\n            }\n            else if (isAudioNode(this.input)) {\n                this.input.disconnect();\n            }\n        }\n        if (isDefined(this.output)) {\n            if (this.output instanceof ToneAudioNode) {\n                this.output.dispose();\n            }\n            else if (isAudioNode(this.output)) {\n                this.output.disconnect();\n            }\n        }\n        this._internalChannels = [];\n        return this;\n    }\n}\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes) {\n    const first = nodes.shift();\n    nodes.reduce((prev, current) => {\n        if (prev instanceof ToneAudioNode) {\n            prev.connect(current);\n        }\n        else if (isAudioNode(prev)) {\n            connect(prev, current);\n        }\n        return current;\n    }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n    assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n    if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n        assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n    }\n    assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n    // resolve the input of the dstNode\n    while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n        if (isDefined(dstNode.input)) {\n            dstNode = dstNode.input;\n        }\n    }\n    while (srcNode instanceof ToneAudioNode) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    // make the connection\n    if (isAudioParam(dstNode)) {\n        srcNode.connect(dstNode, outputNumber);\n    }\n    else {\n        srcNode.connect(dstNode, outputNumber, inputNumber);\n    }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    // resolve the destination node\n    if (isDefined(dstNode)) {\n        while (dstNode instanceof ToneAudioNode) {\n            dstNode = dstNode.input;\n        }\n    }\n    // resolve the src node\n    while (!isAudioNode(srcNode)) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    if (isAudioParam(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber);\n    }\n    else if (isAudioNode(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber, inputNumber);\n    }\n    else {\n        srcNode.disconnect();\n    }\n}\n/**\n * Connect the output of one or more source nodes to a single destination node\n * @param nodes One or more source nodes followed by one destination node\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n * const player1 = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n * const filter = new Tone.Filter(\"G5\").toDestination();\n * // connect nodes to a common destination\n * Tone.fanIn(player, player1, filter);\n */\nexport function fanIn(...nodes) {\n    const dstNode = nodes.pop();\n    if (isDefined(dstNode)) {\n        nodes.forEach((node) => connect(node, dstNode));\n    }\n}\n//# sourceMappingURL=ToneAudioNode.js.map","import { Param } from \"../context/Param.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport { ToneAudioNode } from \"./ToneAudioNode.js\";\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst gainNode = new Tone.Gain(0).toDestination();\n * \tconst osc = new Tone.Oscillator(30).connect(gainNode).start();\n * \tgainNode.gain.rampTo(1, 0.1);\n * \tgainNode.gain.rampTo(0, 0.4, 0.2);\n * }, 0.7, 1);\n */\nexport class Gain extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Gain.getDefaults(), arguments, [\n            \"gain\",\n            \"units\",\n        ]);\n        super(options);\n        this.name = \"Gain\";\n        /**\n         * The wrapped GainNode.\n         */\n        this._gainNode = this.context.createGain();\n        // input = output\n        this.input = this._gainNode;\n        this.output = this._gainNode;\n        this.gain = new Param({\n            context: this.context,\n            convert: options.convert,\n            param: this._gainNode.gain,\n            units: options.units,\n            value: options.gain,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n        readOnly(this, \"gain\");\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            convert: true,\n            gain: 1,\n            units: \"gain\",\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._gainNode.disconnect();\n        this.gain.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Gain.js.map","import { Gain } from \"../core/context/Gain.js\";\nimport { ToneAudioNode, } from \"../core/context/ToneAudioNode.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { assert } from \"../core/util/Debug.js\";\n/**\n * Base class for fire-and-forget nodes\n */\nexport class OneShotSource extends ToneAudioNode {\n    constructor(options) {\n        super(options);\n        /**\n         * The callback to invoke after the\n         * source is done playing.\n         */\n        this.onended = noOp;\n        /**\n         * The start time\n         */\n        this._startTime = -1;\n        /**\n         * The stop time\n         */\n        this._stopTime = -1;\n        /**\n         * The id of the timeout\n         */\n        this._timeout = -1;\n        /**\n         * The public output node\n         */\n        this.output = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        /**\n         * The output gain node.\n         */\n        this._gainNode = this.output;\n        /**\n         * Get the playback state at the given time\n         */\n        this.getStateAtTime = function (time) {\n            const computedTime = this.toSeconds(time);\n            if (this._startTime !== -1 &&\n                computedTime >= this._startTime &&\n                (this._stopTime === -1 || computedTime <= this._stopTime)) {\n                return \"started\";\n            }\n            else {\n                return \"stopped\";\n            }\n        };\n        this._fadeIn = options.fadeIn;\n        this._fadeOut = options.fadeOut;\n        this._curve = options.curve;\n        this.onended = options.onended;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            curve: \"linear\",\n            fadeIn: 0,\n            fadeOut: 0,\n            onended: noOp,\n        });\n    }\n    /**\n     * Start the source at the given time\n     * @param  time When to start the source\n     */\n    _startGain(time, gain = 1) {\n        assert(this._startTime === -1, \"Source cannot be started more than once\");\n        // apply a fade in envelope\n        const fadeInTime = this.toSeconds(this._fadeIn);\n        // record the start time\n        this._startTime = time + fadeInTime;\n        this._startTime = Math.max(this._startTime, this.context.currentTime);\n        // schedule the envelope\n        if (fadeInTime > 0) {\n            this._gainNode.gain.setValueAtTime(0, time);\n            if (this._curve === \"linear\") {\n                this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n            }\n            else {\n                this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n            }\n        }\n        else {\n            this._gainNode.gain.setValueAtTime(gain, time);\n        }\n        return this;\n    }\n    /**\n     * Stop the source node at the given time.\n     * @param time When to stop the source\n     */\n    stop(time) {\n        this.log(\"stop\", time);\n        this._stopGain(this.toSeconds(time));\n        return this;\n    }\n    /**\n     * Stop the source at the given time\n     * @param  time When to stop the source\n     */\n    _stopGain(time) {\n        assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n        // cancel the previous stop\n        this.cancelStop();\n        // the fadeOut time\n        const fadeOutTime = this.toSeconds(this._fadeOut);\n        // schedule the stop callback\n        this._stopTime = this.toSeconds(time) + fadeOutTime;\n        this._stopTime = Math.max(this._stopTime, this.now());\n        if (fadeOutTime > 0) {\n            // start the fade out curve at the given time\n            if (this._curve === \"linear\") {\n                this._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n            }\n            else {\n                this._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n            }\n        }\n        else {\n            // stop any ongoing ramps, and set the value to 0\n            this._gainNode.gain.cancelAndHoldAtTime(time);\n            this._gainNode.gain.setValueAtTime(0, time);\n        }\n        this.context.clearTimeout(this._timeout);\n        this._timeout = this.context.setTimeout(() => {\n            // allow additional time for the exponential curve to fully decay\n            const additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n            this._stopSource(this.now() + additionalTail);\n            this._onended();\n        }, this._stopTime - this.context.currentTime);\n        return this;\n    }\n    /**\n     * Invoke the onended callback\n     */\n    _onended() {\n        if (this.onended === noOp) {\n            return;\n        }\n        this.onended(this);\n        // overwrite onended to make sure it only is called once\n        this.onended = noOp;\n        // dispose when it's ended to free up for garbage collection only in the online context\n        if (!this.context.isOffline) {\n            const disposeCallback = () => this.dispose();\n            if (typeof requestIdleCallback !== \"undefined\") {\n                requestIdleCallback(disposeCallback);\n            }\n            else {\n                setTimeout(disposeCallback, 10);\n            }\n        }\n    }\n    /**\n     * Get the playback state at the current time\n     */\n    get state() {\n        return this.getStateAtTime(this.now());\n    }\n    /**\n     * Cancel a scheduled stop event\n     */\n    cancelStop() {\n        this.log(\"cancelStop\");\n        assert(this._startTime !== -1, \"Source is not started\");\n        // cancel the stop envelope\n        this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n        this.context.clearTimeout(this._timeout);\n        this._stopTime = -1;\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._gainNode.dispose();\n        this.onended = noOp;\n        return this;\n    }\n}\n//# sourceMappingURL=OneShotSource.js.map","import { connect } from \"../core/context/ToneAudioNode.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { OneShotSource, } from \"../source/OneShotSource.js\";\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource extends OneShotSource {\n    constructor() {\n        const options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n        super(options);\n        this.name = \"ToneConstantSource\";\n        /**\n         * The signal generator\n         */\n        this._source = this.context.createConstantSource();\n        connect(this._source, this._gainNode);\n        this.offset = new Param({\n            context: this.context,\n            convert: options.convert,\n            param: this._source.offset,\n            units: options.units,\n            value: options.offset,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            convert: true,\n            offset: 1,\n            units: \"number\",\n        });\n    }\n    /**\n     * Start the source node at the given time\n     * @param  time When to start the source\n     */\n    start(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        this._startGain(computedTime);\n        this._source.start(computedTime);\n        return this;\n    }\n    _stopSource(time) {\n        this._source.stop(time);\n    }\n    dispose() {\n        super.dispose();\n        if (this.state === \"started\") {\n            this.stop();\n        }\n        this._source.disconnect();\n        this.offset.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneConstantSource.js.map","import { Param } from \"../core/context/Param.js\";\nimport { ToneAudioNode, } from \"../core/context/ToneAudioNode.js\";\nimport { connect } from \"../core/context/ToneAudioNode.js\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { ToneConstantSource } from \"./ToneConstantSource.js\";\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\nexport class Signal extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Signal.getDefaults(), arguments, [\n            \"value\",\n            \"units\",\n        ]);\n        super(options);\n        this.name = \"Signal\";\n        /**\n         * Indicates if the value should be overridden on connection.\n         */\n        this.override = true;\n        this.output = this._constantSource = new ToneConstantSource({\n            context: this.context,\n            convert: options.convert,\n            offset: options.value,\n            units: options.units,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n        this._constantSource.start(0);\n        this.input = this._param = this._constantSource.offset;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            convert: true,\n            units: \"number\",\n            value: 0,\n        });\n    }\n    connect(destination, outputNum = 0, inputNum = 0) {\n        // start it only when connected to something\n        connectSignal(this, destination, outputNum, inputNum);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._param.dispose();\n        this._constantSource.dispose();\n        return this;\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // just a proxy for the ConstantSourceNode's offset AudioParam\n    // all docs are generated from AbstractParam.ts\n    //-------------------------------------\n    setValueAtTime(value, time) {\n        this._param.setValueAtTime(value, time);\n        return this;\n    }\n    getValueAtTime(time) {\n        return this._param.getValueAtTime(time);\n    }\n    setRampPoint(time) {\n        this._param.setRampPoint(time);\n        return this;\n    }\n    linearRampToValueAtTime(value, time) {\n        this._param.linearRampToValueAtTime(value, time);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, time) {\n        this._param.exponentialRampToValueAtTime(value, time);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        this._param.exponentialRampTo(value, rampTime, startTime);\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        this._param.linearRampTo(value, rampTime, startTime);\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        this._param.targetRampTo(value, rampTime, startTime);\n        return this;\n    }\n    exponentialApproachValueAtTime(value, time, rampTime) {\n        this._param.exponentialApproachValueAtTime(value, time, rampTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        this._param.setTargetAtTime(value, startTime, timeConstant);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling) {\n        this._param.setValueCurveAtTime(values, startTime, duration, scaling);\n        return this;\n    }\n    cancelScheduledValues(time) {\n        this._param.cancelScheduledValues(time);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        this._param.cancelAndHoldAtTime(time);\n        return this;\n    }\n    rampTo(value, rampTime, startTime) {\n        this._param.rampTo(value, rampTime, startTime);\n        return this;\n    }\n    get value() {\n        return this._param.value;\n    }\n    set value(value) {\n        this._param.value = value;\n    }\n    get convert() {\n        return this._param.convert;\n    }\n    set convert(convert) {\n        this._param.convert = convert;\n    }\n    get units() {\n        return this._param.units;\n    }\n    get overridden() {\n        return this._param.overridden;\n    }\n    set overridden(overridden) {\n        this._param.overridden = overridden;\n    }\n    get maxValue() {\n        return this._param.maxValue;\n    }\n    get minValue() {\n        return this._param.minValue;\n    }\n    /**\n     * @see {@link Param.apply}.\n     */\n    apply(param) {\n        this._param.apply(param);\n        return this;\n    }\n}\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal, destination, outputNum, inputNum) {\n    if (destination instanceof Param ||\n        isAudioParam(destination) ||\n        (destination instanceof Signal && destination.override)) {\n        // cancel changes\n        destination.cancelScheduledValues(0);\n        // reset the value\n        destination.setValueAtTime(0, 0);\n        // mark the value as overridden\n        if (destination instanceof Signal) {\n            destination.overridden = true;\n        }\n    }\n    connect(signal, destination, outputNum, inputNum);\n}\n//# sourceMappingURL=Signal.js.map","import { Param } from \"../context/Param.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isUndef } from \"../util/TypeCheck.js\";\n/**\n * A Param class just for computing ticks. Similar to the {@link Param} class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam extends Param {\n    constructor() {\n        const options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n        super(options);\n        this.name = \"TickParam\";\n        /**\n         * The timeline which tracks all of the automations.\n         */\n        this._events = new Timeline(Infinity);\n        /**\n         * The internal holder for the multiplier value\n         */\n        this._multiplier = 1;\n        // set the multiplier\n        this._multiplier = options.multiplier;\n        // clear the ticks from the beginning\n        this._events.cancel(0);\n        // set an initial event\n        this._events.add({\n            ticks: 0,\n            time: 0,\n            type: \"setValueAtTime\",\n            value: this._fromType(options.value),\n        });\n        this.setValueAtTime(options.value, 0);\n    }\n    static getDefaults() {\n        return Object.assign(Param.getDefaults(), {\n            multiplier: 1,\n            units: \"hertz\",\n            value: 1,\n        });\n    }\n    setTargetAtTime(value, time, constant) {\n        // approximate it with multiple linear ramps\n        time = this.toSeconds(time);\n        this.setRampPoint(time);\n        const computedValue = this._fromType(value);\n        // start from previously scheduled value\n        const prevEvent = this._events.get(time);\n        const segments = Math.round(Math.max(1 / constant, 1));\n        for (let i = 0; i <= segments; i++) {\n            const segTime = constant * i + time;\n            const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n            this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n        }\n        return this;\n    }\n    setValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        super.setValueAtTime(value, time);\n        const event = this._events.get(computedTime);\n        const previousEvent = this._events.previousEvent(event);\n        const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n        event.ticks = Math.max(ticksUntilTime, 0);\n        return this;\n    }\n    linearRampToValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        super.linearRampToValueAtTime(value, time);\n        const event = this._events.get(computedTime);\n        const previousEvent = this._events.previousEvent(event);\n        const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n        event.ticks = Math.max(ticksUntilTime, 0);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, time) {\n        // aproximate it with multiple linear ramps\n        time = this.toSeconds(time);\n        const computedVal = this._fromType(value);\n        // start from previously scheduled value\n        const prevEvent = this._events.get(time);\n        // approx 10 segments per second\n        const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n        const segmentDur = (time - prevEvent.time) / segments;\n        for (let i = 0; i <= segments; i++) {\n            const segTime = segmentDur * i + prevEvent.time;\n            const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n            this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n        }\n        return this;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  event The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n    _getTicksUntilEvent(event, time) {\n        if (event === null) {\n            event = {\n                ticks: 0,\n                time: 0,\n                type: \"setValueAtTime\",\n                value: 0,\n            };\n        }\n        else if (isUndef(event.ticks)) {\n            const previousEvent = this._events.previousEvent(event);\n            event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n        }\n        const val0 = this._fromType(this.getValueAtTime(event.time));\n        let val1 = this._fromType(this.getValueAtTime(time));\n        // if it's right on the line, take the previous value\n        const onTheLineEvent = this._events.get(time);\n        if (onTheLineEvent &&\n            onTheLineEvent.time === time &&\n            onTheLineEvent.type === \"setValueAtTime\") {\n            val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n        }\n        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  time The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n    getTicksAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const event = this._events.get(computedTime);\n        return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n    }\n    /**\n     * Return the elapsed time of the number of ticks from the given time\n     * @param ticks The number of ticks to calculate\n     * @param  time The time to get the next tick from\n     * @return The duration of the number of ticks from the given time in seconds\n     */\n    getDurationOfTicks(ticks, time) {\n        const computedTime = this.toSeconds(time);\n        const currentTick = this.getTicksAtTime(time);\n        return this.getTimeOfTick(currentTick + ticks) - computedTime;\n    }\n    /**\n     * Given a tick, returns the time that tick occurs at.\n     * @return The time that the tick occurs.\n     */\n    getTimeOfTick(tick) {\n        const before = this._events.get(tick, \"ticks\");\n        const after = this._events.getAfter(tick, \"ticks\");\n        if (before && before.ticks === tick) {\n            return before.time;\n        }\n        else if (before &&\n            after &&\n            after.type === \"linearRampToValueAtTime\" &&\n            before.value !== after.value) {\n            const val0 = this._fromType(this.getValueAtTime(before.time));\n            const val1 = this._fromType(this.getValueAtTime(after.time));\n            const delta = (val1 - val0) / (after.time - before.time);\n            const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n            const sol1 = (-val0 + k) / delta;\n            const sol2 = (-val0 - k) / delta;\n            return (sol1 > 0 ? sol1 : sol2) + before.time;\n        }\n        else if (before) {\n            if (before.value === 0) {\n                return Infinity;\n            }\n            else {\n                return before.time + (tick - before.ticks) / before.value;\n            }\n        }\n        else {\n            return tick / this._initialValue;\n        }\n    }\n    /**\n     * Convert some number of ticks their the duration in seconds accounting\n     * for any automation curves starting at the given time.\n     * @param  ticks The number of ticks to convert to seconds.\n     * @param  when  When along the automation timeline to convert the ticks.\n     * @return The duration in seconds of the ticks.\n     */\n    ticksToTime(ticks, when) {\n        return this.getDurationOfTicks(ticks, when);\n    }\n    /**\n     * The inverse of {@link ticksToTime}. Convert a duration in\n     * seconds to the corresponding number of ticks accounting for any\n     * automation curves starting at the given time.\n     * @param  duration The time interval to convert to ticks.\n     * @param  when When along the automation timeline to convert the ticks.\n     * @return The duration in ticks.\n     */\n    timeToTicks(duration, when) {\n        const computedTime = this.toSeconds(when);\n        const computedDuration = this.toSeconds(duration);\n        const startTicks = this.getTicksAtTime(computedTime);\n        const endTicks = this.getTicksAtTime(computedTime + computedDuration);\n        return endTicks - startTicks;\n    }\n    /**\n     * Convert from the type when the unit value is BPM\n     */\n    _fromType(val) {\n        if (this.units === \"bpm\" && this.multiplier) {\n            return 1 / (60 / val / this.multiplier);\n        }\n        else {\n            return super._fromType(val);\n        }\n    }\n    /**\n     * Special case of type conversion where the units === \"bpm\"\n     */\n    _toType(val) {\n        if (this.units === \"bpm\" && this.multiplier) {\n            return ((val / this.multiplier) * 60);\n        }\n        else {\n            return super._toType(val);\n        }\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n    get multiplier() {\n        return this._multiplier;\n    }\n    set multiplier(m) {\n        // get and reset the current value with the new multiplier\n        // might be necessary to clear all the previous values\n        const currentVal = this.value;\n        this._multiplier = m;\n        this.cancelScheduledValues(0);\n        this.setValueAtTime(currentVal, 0);\n    }\n}\n//# sourceMappingURL=TickParam.js.map","import { Signal } from \"../../signal/Signal.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { TickParam } from \"./TickParam.js\";\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal extends Signal {\n    constructor() {\n        const options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n        super(options);\n        this.name = \"TickSignal\";\n        this.input = this._param = new TickParam({\n            context: this.context,\n            convert: options.convert,\n            multiplier: options.multiplier,\n            param: this._constantSource.offset,\n            units: options.units,\n            value: options.value,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(Signal.getDefaults(), {\n            multiplier: 1,\n            units: \"hertz\",\n            value: 1,\n        });\n    }\n    ticksToTime(ticks, when) {\n        return this._param.ticksToTime(ticks, when);\n    }\n    timeToTicks(duration, when) {\n        return this._param.timeToTicks(duration, when);\n    }\n    getTimeOfTick(tick) {\n        return this._param.getTimeOfTick(tick);\n    }\n    getDurationOfTicks(ticks, time) {\n        return this._param.getDurationOfTicks(ticks, time);\n    }\n    getTicksAtTime(time) {\n        return this._param.getTicksAtTime(time);\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n    get multiplier() {\n        return this._param.multiplier;\n    }\n    set multiplier(m) {\n        this._param.multiplier = m;\n    }\n    dispose() {\n        super.dispose();\n        this._param.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=TickSignal.js.map","import { ToneWithContext, } from \"../context/ToneWithContext.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport { StateTimeline, } from \"../util/StateTimeline.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { TickSignal } from \"./TickSignal.js\";\nimport { EQ } from \"../util/Math.js\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n    constructor() {\n        const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n        super(options);\n        this.name = \"TickSource\";\n        /**\n         * The state timeline\n         */\n        this._state = new StateTimeline();\n        /**\n         * The offset values of the ticks\n         */\n        this._tickOffset = new Timeline();\n        /**\n         * Memoized values of getTicksAtTime at events with state other than \"started\"\n         */\n        this._ticksAtTime = new Timeline();\n        /**\n         * Memoized values of getSecondsAtTime at events with state other than \"started\"\n         */\n        this._secondsAtTime = new Timeline();\n        this.frequency = new TickSignal({\n            context: this.context,\n            units: options.units,\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        // set the initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // add the first event\n        this.setTicksAtTime(0, 0);\n    }\n    static getDefaults() {\n        return Object.assign({\n            frequency: 1,\n            units: \"hertz\",\n        }, ToneWithContext.getDefaults());\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n    start(time, offset) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (isDefined(offset)) {\n                this.setTicksAtTime(offset, computedTime);\n            }\n            this._ticksAtTime.cancel(computedTime);\n            this._secondsAtTime.cancel(computedTime);\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        // cancel the previous stop\n        if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n            const event = this._state.get(computedTime);\n            if (event && event.time > 0) {\n                this._tickOffset.cancel(event.time);\n                this._state.cancel(event.time);\n            }\n        }\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this.setTicksAtTime(0, computedTime);\n        this._ticksAtTime.cancel(computedTime);\n        this._secondsAtTime.cancel(computedTime);\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n            this._ticksAtTime.cancel(computedTime);\n            this._secondsAtTime.cancel(computedTime);\n        }\n        return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n    cancel(time) {\n        time = this.toSeconds(time);\n        this._state.cancel(time);\n        this._tickOffset.cancel(time);\n        this._ticksAtTime.cancel(time);\n        this._secondsAtTime.cancel(time);\n        return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n    getTicksAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n        // get previously memoized ticks if available\n        const memoizedEvent = this._ticksAtTime.get(computedTime);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = {\n            state: \"paused\",\n            time: computedTime,\n        };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = memoizedEvent ? memoizedEvent : stopEvent;\n        let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;\n        let eventToMemoize = null;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, (e) => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedTicks = offsetEvent.ticks;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedTicks +=\n                    this.frequency.getTicksAtTime(e.time) -\n                        this.frequency.getTicksAtTime(periodStartTime);\n                // do not memoize the temporary event\n                if (e.time !== tmpEvent.time) {\n                    eventToMemoize = {\n                        state: e.state,\n                        time: e.time,\n                        ticks: elapsedTicks,\n                    };\n                }\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // memoize the ticks at the most recent event with state other than \"started\"\n        if (eventToMemoize) {\n            this._ticksAtTime.add(eventToMemoize);\n        }\n        // return the ticks\n        return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n    get ticks() {\n        return this.getTicksAtTime(this.now());\n    }\n    set ticks(t) {\n        this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n    get seconds() {\n        return this.getSecondsAtTime(this.now());\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this.frequency.timeToTicks(s, now);\n        this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        time = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", time);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time };\n        this._state.add(tmpEvent);\n        // get previously memoized seconds if available\n        const memoizedEvent = this._secondsAtTime.get(time);\n        // keep track of the previous offset event\n        let lastState = memoizedEvent ? memoizedEvent : stopEvent;\n        let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;\n        let eventToMemoize = null;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(lastState.time, time + this.sampleTime, (e) => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedSeconds = offsetEvent.seconds;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedSeconds += e.time - periodStartTime;\n                // do not memoize the temporary event\n                if (e.time !== tmpEvent.time) {\n                    eventToMemoize = {\n                        state: e.state,\n                        time: e.time,\n                        seconds: elapsedSeconds,\n                    };\n                }\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // memoize the seconds at the most recent event with state other than \"started\"\n        if (eventToMemoize) {\n            this._secondsAtTime.add(eventToMemoize);\n        }\n        // return the seconds\n        return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        time = this.toSeconds(time);\n        this._tickOffset.cancel(time);\n        this._tickOffset.add({\n            seconds: this.frequency.getDurationOfTicks(ticks, time),\n            ticks,\n            time,\n        });\n        this._ticksAtTime.cancel(time);\n        this._secondsAtTime.cancel(time);\n        return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n    getStateAtTime(time) {\n        time = this.toSeconds(time);\n        return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        const offset = this._tickOffset.get(before);\n        const event = this._state.get(before);\n        const startTime = Math.max(offset.time, event.time);\n        const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n        return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n    forEachTickBetween(startTime, endTime, callback) {\n        // only iterate through the sections where it is \"started\"\n        let lastStateEvent = this._state.get(startTime);\n        this._state.forEachBetween(startTime, endTime, (event) => {\n            if (lastStateEvent &&\n                lastStateEvent.state === \"started\" &&\n                event.state !== \"started\") {\n                this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n            }\n            lastStateEvent = event;\n        });\n        let error = null;\n        if (lastStateEvent && lastStateEvent.state === \"started\") {\n            const maxStartTime = Math.max(lastStateEvent.time, startTime);\n            // figure out the difference between the frequency ticks and the\n            const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n            const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n            const diff = startTicks - ticksAtStart;\n            let offset = Math.ceil(diff) - diff;\n            // guard against floating point issues\n            offset = EQ(offset, 1) ? 0 : offset;\n            let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n            while (nextTickTime < endTime) {\n                try {\n                    callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n                }\n                catch (e) {\n                    error = e;\n                    break;\n                }\n                nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n            }\n        }\n        if (error) {\n            throw error;\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._state.dispose();\n        this._tickOffset.dispose();\n        this._ticksAtTime.dispose();\n        this._secondsAtTime.dispose();\n        this.frequency.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=TickSource.js.map","import { ToneWithContext, } from \"../context/ToneWithContext.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { noOp, readOnly } from \"../util/Interface.js\";\nimport { StateTimeline } from \"../util/StateTimeline.js\";\nimport { TickSource } from \"./TickSource.js\";\nimport { assertContextRunning } from \"../util/Debug.js\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n    constructor() {\n        const options = optionsFromArguments(Clock.getDefaults(), arguments, [\n            \"callback\",\n            \"frequency\",\n        ]);\n        super(options);\n        this.name = \"Clock\";\n        /**\n         * The callback function to invoke at the scheduled tick.\n         */\n        this.callback = noOp;\n        /**\n         * The last time the loop callback was invoked\n         */\n        this._lastUpdate = 0;\n        /**\n         * Keep track of the playback state\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * Context bound reference to the _loop method\n         * This is necessary to remove the event in the end.\n         */\n        this._boundLoop = this._loop.bind(this);\n        this.callback = options.callback;\n        this._tickSource = new TickSource({\n            context: this.context,\n            frequency: options.frequency,\n            units: options.units,\n        });\n        this._lastUpdate = 0;\n        this.frequency = this._tickSource.frequency;\n        readOnly(this, \"frequency\");\n        // add an initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // bind a callback to the worker thread\n        this.context.on(\"tick\", this._boundLoop);\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            callback: noOp,\n            frequency: 1,\n            units: \"hertz\",\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this._state.getValueAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n    start(time, offset) {\n        // make sure the context is running\n        assertContextRunning(this.context);\n        // start the loop\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            this._tickSource.start(computedTime, offset);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"start\", computedTime, offset);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"stop\", computedTime);\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this._tickSource.stop(computedTime);\n        if (computedTime < this._lastUpdate) {\n            this.emit(\"stop\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n            this._tickSource.pause(computedTime);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"pause\", computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n    get ticks() {\n        return Math.ceil(this.getTicksAtTime(this.now()));\n    }\n    set ticks(t) {\n        this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n    get seconds() {\n        return this._tickSource.seconds;\n    }\n    set seconds(s) {\n        this._tickSource.seconds = s;\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        this._tickSource.setTicksAtTime(ticks, time);\n        return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n    nextTickTime(offset, when) {\n        const computedTime = this.toSeconds(when);\n        const currentTick = this.getTicksAtTime(computedTime);\n        return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n    _loop() {\n        const startTime = this._lastUpdate;\n        const endTime = this.now();\n        this._lastUpdate = endTime;\n        this.log(\"loop\", startTime, endTime);\n        if (startTime !== endTime) {\n            // the state change events\n            this._state.forEachBetween(startTime, endTime, (e) => {\n                switch (e.state) {\n                    case \"started\":\n                        const offset = this._tickSource.getTicksAtTime(e.time);\n                        this.emit(\"start\", e.time, offset);\n                        break;\n                    case \"stopped\":\n                        if (e.time !== 0) {\n                            this.emit(\"stop\", e.time);\n                        }\n                        break;\n                    case \"paused\":\n                        this.emit(\"pause\", e.time);\n                        break;\n                }\n            });\n            // the tick callbacks\n            this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n                this.callback(time, ticks);\n            });\n        }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n    getStateAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.context.off(\"tick\", this._boundLoop);\n        this._tickSource.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Clock);\n//# sourceMappingURL=Clock.js.map","import { Gain } from \"../../core/context/Gain.js\";\nimport { ToneAudioNode, } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\nexport class Volume extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Volume.getDefaults(), arguments, [\n            \"volume\",\n        ]);\n        super(options);\n        this.name = \"Volume\";\n        this.input = this.output = new Gain({\n            context: this.context,\n            gain: options.volume,\n            units: \"decibels\",\n        });\n        this.volume = this.output.gain;\n        readOnly(this, \"volume\");\n        this._unmutedVolume = options.volume;\n        // set the mute initially\n        this.mute = options.mute;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0,\n        });\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const vol = new Tone.Volume(-12).toDestination();\n     * const osc = new Tone.Oscillator().connect(vol).start();\n     * // mute the output\n     * vol.mute = true;\n     */\n    get mute() {\n        return this.volume.value === -Infinity;\n    }\n    set mute(mute) {\n        if (!this.mute && mute) {\n            this._unmutedVolume = this.volume.value;\n            // maybe it should ramp here?\n            this.volume.value = -Infinity;\n        }\n        else if (this.mute && !mute) {\n            this.volume.value = this._unmutedVolume;\n        }\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this.input.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Volume.js.map","import { Volume } from \"../../component/channel/Volume.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization.js\";\nimport { Gain } from \"./Gain.js\";\nimport { connectSeries, ToneAudioNode, } from \"./ToneAudioNode.js\";\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.getDestination());\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\nexport class DestinationClass extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(DestinationClass.getDefaults(), arguments);\n        super(options);\n        this.name = \"Destination\";\n        this.input = new Volume({ context: this.context });\n        this.output = new Gain({ context: this.context });\n        /**\n         * The volume of the master output in decibels. -Infinity is silent, and 0 is no change.\n         * @example\n         * const osc = new Tone.Oscillator().toDestination();\n         * osc.start();\n         * // ramp the volume down to silent over 10 seconds\n         * Tone.getDestination().volume.rampTo(-Infinity, 10);\n         */\n        this.volume = this.input.volume;\n        connectSeries(this.input, this.output, this.context.rawContext.destination);\n        this.mute = options.mute;\n        this._internalChannels = [\n            this.input,\n            this.context.rawContext.destination,\n            this.output,\n        ];\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0,\n        });\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const oscillator = new Tone.Oscillator().start().toDestination();\n     * setTimeout(() => {\n     * \t// mute the output\n     * \tTone.Destination.mute = true;\n     * }, 1000);\n     */\n    get mute() {\n        return this.input.mute;\n    }\n    set mute(mute) {\n        this.input.mute = mute;\n    }\n    /**\n     * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n     * chained in the master effects chain.\n     * @param args All arguments will be connected in a row and the Master will be routed through it.\n     * @example\n     * // route all audio through a filter and compressor\n     * const lowpass = new Tone.Filter(800, \"lowpass\");\n     * const compressor = new Tone.Compressor(-18);\n     * Tone.Destination.chain(lowpass, compressor);\n     */\n    chain(...args) {\n        this.input.disconnect();\n        args.unshift(this.input);\n        args.push(this.output);\n        connectSeries(...args);\n        return this;\n    }\n    /**\n     * The maximum number of channels the system can output\n     * @example\n     * console.log(Tone.Destination.maxChannelCount);\n     */\n    get maxChannelCount() {\n        return this.context.rawContext.destination.maxChannelCount;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit((context) => {\n    context.destination = new DestinationClass({ context });\n});\nonContextClose((context) => {\n    context.destination.dispose();\n});\n//# sourceMappingURL=Destination.js.map","import { ToneAudioNode } from \"./ToneAudioNode.js\";\nimport { Param } from \"./Param.js\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization.js\";\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with {@link Panner3D} makes up the Web Audio API's 3D panning system. Panner3D allows you\n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context.\n */\nexport class ListenerClass extends ToneAudioNode {\n    constructor() {\n        super(...arguments);\n        this.name = \"Listener\";\n        this.positionX = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.positionX,\n        });\n        this.positionY = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.positionY,\n        });\n        this.positionZ = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.positionZ,\n        });\n        this.forwardX = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.forwardX,\n        });\n        this.forwardY = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.forwardY,\n        });\n        this.forwardZ = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.forwardZ,\n        });\n        this.upX = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.upX,\n        });\n        this.upY = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.upY,\n        });\n        this.upZ = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.upZ,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            positionX: 0,\n            positionY: 0,\n            positionZ: 0,\n            forwardX: 0,\n            forwardY: 0,\n            forwardZ: -1,\n            upX: 0,\n            upY: 1,\n            upZ: 0,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this.positionX.dispose();\n        this.positionY.dispose();\n        this.positionZ.dispose();\n        this.forwardX.dispose();\n        this.forwardY.dispose();\n        this.forwardZ.dispose();\n        this.upX.dispose();\n        this.upY.dispose();\n        this.upZ.dispose();\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit((context) => {\n    context.listener = new ListenerClass({ context });\n});\nonContextClose((context) => {\n    context.listener.dispose();\n});\n//# sourceMappingURL=Listener.js.map","import { Tone } from \"../Tone.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { noOp } from \"../util/Interface.js\";\nimport { isString } from \"../util/TypeCheck.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\nimport { assert } from \"../util/Debug.js\";\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tA1: \"https://tonejs.github.io/audio/casio/A1.mp3\",\n * \tA2: \"https://tonejs.github.io/audio/casio/A2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"A2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t A1: \"A1.mp3\",\n * \t\t A2: \"A2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/audio/casio/\"\n * });\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n    constructor() {\n        super();\n        this.name = \"ToneAudioBuffers\";\n        /**\n         * All of the buffers\n         */\n        this._buffers = new Map();\n        /**\n         * Keep track of the number of loaded buffers\n         */\n        this._loadingCount = 0;\n        const options = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n        this.baseUrl = options.baseUrl;\n        // add each one\n        Object.keys(options.urls).forEach((name) => {\n            this._loadingCount++;\n            const url = options.urls[name];\n            this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);\n        });\n    }\n    static getDefaults() {\n        return {\n            baseUrl: \"\",\n            onerror: noOp,\n            onload: noOp,\n            urls: {},\n        };\n    }\n    /**\n     * True if the buffers object has a buffer by that name.\n     * @param  name  The key or index of the buffer.\n     */\n    has(name) {\n        return this._buffers.has(name.toString());\n    }\n    /**\n     * Get a buffer by name. If an array was loaded,\n     * then use the array index.\n     * @param  name  The key or index of the buffer.\n     */\n    get(name) {\n        assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n        return this._buffers.get(name.toString());\n    }\n    /**\n     * A buffer was loaded. decrement the counter.\n     */\n    _bufferLoaded(callback) {\n        this._loadingCount--;\n        if (this._loadingCount === 0 && callback) {\n            callback();\n        }\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n    get loaded() {\n        return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n    }\n    /**\n     * Add a buffer by name and url to the Buffers\n     * @param  name      A unique name to give the buffer\n     * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     * @param  onerror  Invoked if the buffer can't be loaded\n     */\n    add(name, url, callback = noOp, onerror = noOp) {\n        if (isString(url)) {\n            // don't include the baseUrl if the url is a base64 encoded sound\n            if (this.baseUrl &&\n                url.trim().substring(0, 11).toLowerCase() === \"data:audio/\") {\n                this.baseUrl = \"\";\n            }\n            this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));\n        }\n        else {\n            this._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));\n        }\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._buffers.forEach((buffer) => buffer.dispose());\n        this._buffers.clear();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneAudioBuffers.js.map","import { getContext } from \"../Global.js\";\nimport { TransportTimeClass } from \"./TransportTime.js\";\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"Ticks\";\n        this.defaultUnits = \"i\";\n    }\n    /**\n     * Get the current time in the given units\n     */\n    _now() {\n        return this.context.transport.ticks;\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return this._getPPQ() * beats;\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return Math.floor((seconds / (60 / this._getBpm())) * this._getPPQ());\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return ticks;\n    }\n    /**\n     * Return the time in ticks\n     */\n    toTicks() {\n        return this.valueOf();\n    }\n    /**\n     * Return the time in seconds\n     */\n    toSeconds() {\n        return (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n    }\n}\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value, units) {\n    return new TicksClass(getContext(), value, units);\n}\n//# sourceMappingURL=Ticks.js.map","import { ToneWithContext, } from \"../context/ToneWithContext.js\";\nimport { Timeline } from \"./Timeline.js\";\nimport { onContextClose, onContextInit, } from \"../context/ContextInitialization.js\";\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport class DrawClass extends ToneWithContext {\n    constructor() {\n        super(...arguments);\n        this.name = \"Draw\";\n        /**\n         * The duration after which events are not invoked.\n         */\n        this.expiration = 0.25;\n        /**\n         * The amount of time before the scheduled time\n         * that the callback can be invoked. Default is\n         * half the time of an animation frame (0.008 seconds).\n         */\n        this.anticipation = 0.008;\n        /**\n         * All of the events.\n         */\n        this._events = new Timeline();\n        /**\n         * The draw loop\n         */\n        this._boundDrawLoop = this._drawLoop.bind(this);\n        /**\n         * The animation frame id\n         */\n        this._animationFrame = -1;\n    }\n    /**\n     * Schedule a function at the given time to be invoked\n     * on the nearest animation frame.\n     * @param  callback  Callback is invoked at the given time.\n     * @param  time      The time relative to the AudioContext time to invoke the callback.\n     * @example\n     * Tone.Transport.scheduleRepeat(time => {\n     * \tTone.Draw.schedule(() => console.log(time), time);\n     * }, 1);\n     * Tone.Transport.start();\n     */\n    schedule(callback, time) {\n        this._events.add({\n            callback,\n            time: this.toSeconds(time),\n        });\n        // start the draw loop on the first event\n        if (this._events.length === 1) {\n            this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n        }\n        return this;\n    }\n    /**\n     * Cancel events scheduled after the given time\n     * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n     */\n    cancel(after) {\n        this._events.cancel(this.toSeconds(after));\n        return this;\n    }\n    /**\n     * The draw loop\n     */\n    _drawLoop() {\n        const now = this.context.currentTime;\n        this._events.forEachBefore(now + this.anticipation, (event) => {\n            if (now - event.time <= this.expiration) {\n                event.callback();\n            }\n            this._events.remove(event);\n        });\n        if (this._events.length > 0) {\n            this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n        }\n    }\n    dispose() {\n        super.dispose();\n        this._events.dispose();\n        cancelAnimationFrame(this._animationFrame);\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit((context) => {\n    context.draw = new DrawClass({ context });\n});\nonContextClose((context) => {\n    context.draw.dispose();\n});\n//# sourceMappingURL=Draw.js.map","import { Tone } from \"../Tone.js\";\nimport { isDefined } from \"./TypeCheck.js\";\nimport { assert } from \"./Debug.js\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n * @internal\n */\nexport class IntervalTimeline extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"IntervalTimeline\";\n        /**\n         * The root node of the inteval tree\n         */\n        this._root = null;\n        /**\n         * Keep track of the length of the timeline.\n         */\n        this._length = 0;\n    }\n    /**\n     * The event to add to the timeline. All events must\n     * have a time and duration value\n     * @param  event  The event to add to the timeline\n     */\n    add(event) {\n        assert(isDefined(event.time), \"Events must have a time property\");\n        assert(isDefined(event.duration), \"Events must have a duration parameter\");\n        event.time = event.time.valueOf();\n        let node = new IntervalNode(event.time, event.time + event.duration, event);\n        if (this._root === null) {\n            this._root = node;\n        }\n        else {\n            this._root.insert(node);\n        }\n        this._length++;\n        // Restructure tree to be balanced\n        while (node !== null) {\n            node.updateHeight();\n            node.updateMax();\n            this._rebalance(node);\n            node = node.parent;\n        }\n        return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  event  The event to remove from the timeline\n     */\n    remove(event) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(event.time, results);\n            for (const node of results) {\n                if (node.event === event) {\n                    this._removeNode(node);\n                    this._length--;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of items in the timeline.\n     * @readOnly\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Remove events whose time time is after the given time\n     * @param  after  The time to query.\n     */\n    cancel(after) {\n        this.forEachFrom(after, (event) => this.remove(event));\n        return this;\n    }\n    /**\n     * Set the root node as the given node\n     */\n    _setRoot(node) {\n        this._root = node;\n        if (this._root !== null) {\n            this._root.parent = null;\n        }\n    }\n    /**\n     * Replace the references to the node in the node's parent\n     * with the replacement node.\n     */\n    _replaceNodeInParent(node, replacement) {\n        if (node.parent !== null) {\n            if (node.isLeftChild()) {\n                node.parent.left = replacement;\n            }\n            else {\n                node.parent.right = replacement;\n            }\n            this._rebalance(node.parent);\n        }\n        else {\n            this._setRoot(replacement);\n        }\n    }\n    /**\n     * Remove the node from the tree and replace it with\n     * a successor which follows the schema.\n     */\n    _removeNode(node) {\n        if (node.left === null && node.right === null) {\n            this._replaceNodeInParent(node, null);\n        }\n        else if (node.right === null) {\n            this._replaceNodeInParent(node, node.left);\n        }\n        else if (node.left === null) {\n            this._replaceNodeInParent(node, node.right);\n        }\n        else {\n            const balance = node.getBalance();\n            let replacement;\n            let temp = null;\n            if (balance > 0) {\n                if (node.left.right === null) {\n                    replacement = node.left;\n                    replacement.right = node.right;\n                    temp = replacement;\n                }\n                else {\n                    replacement = node.left.right;\n                    while (replacement.right !== null) {\n                        replacement = replacement.right;\n                    }\n                    if (replacement.parent) {\n                        replacement.parent.right = replacement.left;\n                        temp = replacement.parent;\n                        replacement.left = node.left;\n                        replacement.right = node.right;\n                    }\n                }\n            }\n            else if (node.right.left === null) {\n                replacement = node.right;\n                replacement.left = node.left;\n                temp = replacement;\n            }\n            else {\n                replacement = node.right.left;\n                while (replacement.left !== null) {\n                    replacement = replacement.left;\n                }\n                if (replacement.parent) {\n                    replacement.parent.left = replacement.right;\n                    temp = replacement.parent;\n                    replacement.left = node.left;\n                    replacement.right = node.right;\n                }\n            }\n            if (node.parent !== null) {\n                if (node.isLeftChild()) {\n                    node.parent.left = replacement;\n                }\n                else {\n                    node.parent.right = replacement;\n                }\n            }\n            else {\n                this._setRoot(replacement);\n            }\n            if (temp) {\n                this._rebalance(temp);\n            }\n        }\n        node.dispose();\n    }\n    /**\n     * Rotate the tree to the left\n     */\n    _rotateLeft(node) {\n        const parent = node.parent;\n        const isLeftChild = node.isLeftChild();\n        // Make node.right the new root of this sub tree (instead of node)\n        const pivotNode = node.right;\n        if (pivotNode) {\n            node.right = pivotNode.left;\n            pivotNode.left = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    }\n    /**\n     * Rotate the tree to the right\n     */\n    _rotateRight(node) {\n        const parent = node.parent;\n        const isLeftChild = node.isLeftChild();\n        // Make node.left the new root of this sub tree (instead of node)\n        const pivotNode = node.left;\n        if (pivotNode) {\n            node.left = pivotNode.right;\n            pivotNode.right = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    }\n    /**\n     * Balance the BST\n     */\n    _rebalance(node) {\n        const balance = node.getBalance();\n        if (balance > 1 && node.left) {\n            if (node.left.getBalance() < 0) {\n                this._rotateLeft(node.left);\n            }\n            else {\n                this._rotateRight(node);\n            }\n        }\n        else if (balance < -1 && node.right) {\n            if (node.right.getBalance() > 0) {\n                this._rotateRight(node.right);\n            }\n            else {\n                this._rotateLeft(node);\n            }\n        }\n    }\n    /**\n     * Get an event whose time and duration span the give time. Will\n     * return the match whose \"time\" value is closest to the given time.\n     * @return  The event which spans the desired time\n     */\n    get(time) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(time, results);\n            if (results.length > 0) {\n                let max = results[0];\n                for (let i = 1; i < results.length; i++) {\n                    if (results[i].low > max.low) {\n                        max = results[i];\n                    }\n                }\n                return max.event;\n            }\n        }\n        return null;\n    }\n    /**\n     * Iterate over everything in the timeline.\n     * @param  callback The callback to invoke with every item\n     */\n    forEach(callback) {\n        if (this._root !== null) {\n            const allNodes = [];\n            this._root.traverse((node) => allNodes.push(node));\n            allNodes.forEach((node) => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array in which the given time\n     * overlaps with the time and duration time of the event.\n     * @param  time The time to check if items are overlapping\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAtTime(time, callback) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(time, results);\n            results.forEach((node) => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array in which the time is greater\n     * than or equal to the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachFrom(time, callback) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.searchAfter(time, results);\n            results.forEach((node) => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        if (this._root !== null) {\n            this._root.traverse((node) => node.dispose());\n        }\n        this._root = null;\n        return this;\n    }\n}\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n    constructor(low, high, event) {\n        // the nodes to the left\n        this._left = null;\n        // the nodes to the right\n        this._right = null;\n        // the parent node\n        this.parent = null;\n        // the number of child nodes\n        this.height = 0;\n        this.event = event;\n        // the low value\n        this.low = low;\n        // the high value\n        this.high = high;\n        // the high value for this and all child nodes\n        this.max = this.high;\n    }\n    /**\n     * Insert a node into the correct spot in the tree\n     */\n    insert(node) {\n        if (node.low <= this.low) {\n            if (this.left === null) {\n                this.left = node;\n            }\n            else {\n                this.left.insert(node);\n            }\n        }\n        else if (this.right === null) {\n            this.right = node;\n        }\n        else {\n            this.right.insert(node);\n        }\n    }\n    /**\n     * Search the tree for nodes which overlap\n     * with the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    search(point, results) {\n        // If p is to the right of the rightmost point of any interval\n        // in this node and all children, there won't be any matches.\n        if (point > this.max) {\n            return;\n        }\n        // Search left children\n        if (this.left !== null) {\n            this.left.search(point, results);\n        }\n        // Check this node\n        if (this.low <= point && this.high > point) {\n            results.push(this);\n        }\n        // If p is to the left of the time of this interval,\n        // then it can't be in any child to the right.\n        if (this.low > point) {\n            return;\n        }\n        // Search right children\n        if (this.right !== null) {\n            this.right.search(point, results);\n        }\n    }\n    /**\n     * Search the tree for nodes which are less\n     * than the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    searchAfter(point, results) {\n        // Check this node\n        if (this.low >= point) {\n            results.push(this);\n            if (this.left !== null) {\n                this.left.searchAfter(point, results);\n            }\n        }\n        // search the right side\n        if (this.right !== null) {\n            this.right.searchAfter(point, results);\n        }\n    }\n    /**\n     * Invoke the callback on this element and both it's branches\n     * @param  {Function}  callback\n     */\n    traverse(callback) {\n        callback(this);\n        if (this.left !== null) {\n            this.left.traverse(callback);\n        }\n        if (this.right !== null) {\n            this.right.traverse(callback);\n        }\n    }\n    /**\n     * Update the height of the node\n     */\n    updateHeight() {\n        if (this.left !== null && this.right !== null) {\n            this.height = Math.max(this.left.height, this.right.height) + 1;\n        }\n        else if (this.right !== null) {\n            this.height = this.right.height + 1;\n        }\n        else if (this.left !== null) {\n            this.height = this.left.height + 1;\n        }\n        else {\n            this.height = 0;\n        }\n    }\n    /**\n     * Update the height of the node\n     */\n    updateMax() {\n        this.max = this.high;\n        if (this.left !== null) {\n            this.max = Math.max(this.max, this.left.max);\n        }\n        if (this.right !== null) {\n            this.max = Math.max(this.max, this.right.max);\n        }\n    }\n    /**\n     * The balance is how the leafs are distributed on the node\n     * @return  Negative numbers are balanced to the right\n     */\n    getBalance() {\n        let balance = 0;\n        if (this.left !== null && this.right !== null) {\n            balance = this.left.height - this.right.height;\n        }\n        else if (this.left !== null) {\n            balance = this.left.height + 1;\n        }\n        else if (this.right !== null) {\n            balance = -(this.right.height + 1);\n        }\n        return balance;\n    }\n    /**\n     * @returns true if this node is the left child of its parent\n     */\n    isLeftChild() {\n        return this.parent !== null && this.parent.left === this;\n    }\n    /**\n     * get/set the left node\n     */\n    get left() {\n        return this._left;\n    }\n    set left(node) {\n        this._left = node;\n        if (node !== null) {\n            node.parent = this;\n        }\n        this.updateHeight();\n        this.updateMax();\n    }\n    /**\n     * get/set the right node\n     */\n    get right() {\n        return this._right;\n    }\n    set right(node) {\n        this._right = node;\n        if (node !== null) {\n            node.parent = this;\n        }\n        this.updateHeight();\n        this.updateMax();\n    }\n    /**\n     * null out references.\n     */\n    dispose() {\n        this.parent = null;\n        this._left = null;\n        this._right = null;\n        this.event = null;\n    }\n}\n//# sourceMappingURL=IntervalTimeline.js.map","import { Timeline } from \"./Timeline.js\";\nimport { Tone } from \"../Tone.js\";\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue extends Tone {\n    /**\n     * @param initialValue The value to return if there is no scheduled values\n     */\n    constructor(initialValue) {\n        super();\n        this.name = \"TimelineValue\";\n        /**\n         * The timeline which stores the values\n         */\n        this._timeline = new Timeline({\n            memory: 10,\n        });\n        this._initialValue = initialValue;\n    }\n    /**\n     * Set the value at the given time\n     */\n    set(value, time) {\n        this._timeline.add({\n            value,\n            time,\n        });\n        return this;\n    }\n    /**\n     * Get the value at the given time\n     */\n    get(time) {\n        const event = this._timeline.get(time);\n        if (event) {\n            return event.value;\n        }\n        else {\n            return this._initialValue;\n        }\n    }\n}\n//# sourceMappingURL=TimelineValue.js.map","import { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { ToneAudioNode, } from \"../core/context/ToneAudioNode.js\";\nimport { connectSignal } from \"./Signal.js\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport class SignalOperator extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\n            \"context\",\n        ]));\n    }\n    connect(destination, outputNum = 0, inputNum = 0) {\n        connectSignal(this, destination, outputNum, inputNum);\n        return this;\n    }\n}\n//# sourceMappingURL=SignalOperator.js.map","import { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { Signal } from \"./Signal.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator {\n    constructor() {\n        const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n        super(options);\n        this.name = \"WaveShaper\";\n        /**\n         * the waveshaper node\n         */\n        this._shaper = this.context.createWaveShaper();\n        /**\n         * The input to the waveshaper node.\n         */\n        this.input = this._shaper;\n        /**\n         * The output from the waveshaper node\n         */\n        this.output = this._shaper;\n        if (isArray(options.mapping) ||\n            options.mapping instanceof Float32Array) {\n            this.curve = Float32Array.from(options.mapping);\n        }\n        else if (isFunction(options.mapping)) {\n            this.setMap(options.mapping, options.length);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(Signal.getDefaults(), {\n            length: 1024,\n        });\n    }\n    /**\n     * Uses a mapping function to set the value of the curve.\n     * @param mapping The function used to define the values.\n     *                The mapping function take two arguments:\n     *                the first is the value at the current position\n     *                which goes from -1 to 1 over the number of elements\n     *                in the curve array. The second argument is the array position.\n     * @example\n     * const shaper = new Tone.WaveShaper();\n     * // map the input signal from [-1, 1] to [0, 10]\n     * shaper.setMap((val, index) => (val + 1) * 5);\n     */\n    setMap(mapping, length = 1024) {\n        const array = new Float32Array(length);\n        for (let i = 0, len = length; i < len; i++) {\n            const normalized = (i / (len - 1)) * 2 - 1;\n            array[i] = mapping(normalized, i);\n        }\n        this.curve = array;\n        return this;\n    }\n    /**\n     * The array to set as the waveshaper curve. For linear curves\n     * array length does not make much difference, but for complex curves\n     * longer arrays will provide smoother interpolation.\n     */\n    get curve() {\n        return this._shaper.curve;\n    }\n    set curve(mapping) {\n        this._shaper.curve = mapping;\n    }\n    /**\n     * Specifies what type of oversampling (if any) should be used when\n     * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n     */\n    get oversample() {\n        return this._shaper.oversample;\n    }\n    set oversample(oversampling) {\n        const isOverSampleType = [\"none\", \"2x\", \"4x\"].some((str) => str.includes(oversampling));\n        assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n        this._shaper.oversample = oversampling;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._shaper.disconnect();\n        return this;\n    }\n}\n//# sourceMappingURL=WaveShaper.js.map","import { WaveShaper } from \"./WaveShaper.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n/**\n * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]\n *\n * @example\n * const pow = new Tone.Pow(2);\n * const sig = new Tone.Signal(0.5).connect(pow);\n * // output of pow is 0.25.\n * @category Signal\n */\nexport class Pow extends SignalOperator {\n    constructor() {\n        const options = optionsFromArguments(Pow.getDefaults(), arguments, [\n            \"value\",\n        ]);\n        super(options);\n        this.name = \"Pow\";\n        this._exponentScaler =\n            this.input =\n                this.output =\n                    new WaveShaper({\n                        context: this.context,\n                        mapping: this._expFunc(options.value),\n                        length: 8192,\n                    });\n        this._exponent = options.value;\n    }\n    static getDefaults() {\n        return Object.assign(SignalOperator.getDefaults(), {\n            value: 1,\n        });\n    }\n    /**\n     * the function which maps the waveshaper\n     * @param exponent exponent value\n     */\n    _expFunc(exponent) {\n        return (val) => {\n            return Math.pow(Math.abs(val), exponent);\n        };\n    }\n    /**\n     * The value of the exponent.\n     */\n    get value() {\n        return this._exponent;\n    }\n    set value(exponent) {\n        this._exponent = exponent;\n        this._exponentScaler.setMap(this._expFunc(this._exponent));\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._exponentScaler.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Pow.js.map","import { noOp } from \"../util/Interface.js\";\n/**\n * TransportEvent is an internal class used by {@link TransportClass}\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n    /**\n     * @param transport The transport object which the event belongs to\n     */\n    constructor(transport, opts) {\n        /**\n         * The unique id of the event\n         */\n        this.id = TransportEvent._eventId++;\n        /**\n         * The remaining value between the passed in time, and Math.floor(time).\n         * This value is later added back when scheduling to get sub-tick precision.\n         */\n        this._remainderTime = 0;\n        const options = Object.assign(TransportEvent.getDefaults(), opts);\n        this.transport = transport;\n        this.callback = options.callback;\n        this._once = options.once;\n        this.time = Math.floor(options.time);\n        this._remainderTime = options.time - this.time;\n    }\n    static getDefaults() {\n        return {\n            callback: noOp,\n            once: false,\n            time: 0,\n        };\n    }\n    /**\n     * Get the time and remainder time.\n     */\n    get floatTime() {\n        return this.time + this._remainderTime;\n    }\n    /**\n     * Invoke the event callback.\n     * @param  time  The AudioContext time in seconds of the event\n     */\n    invoke(time) {\n        if (this.callback) {\n            const tickDuration = this.transport.bpm.getDurationOfTicks(1, time);\n            this.callback(time + this._remainderTime * tickDuration);\n            if (this._once) {\n                this.transport.clear(this.id);\n            }\n        }\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        this.callback = undefined;\n        return this;\n    }\n}\n/**\n * Current ID counter\n */\nTransportEvent._eventId = 0;\n//# sourceMappingURL=TransportEvent.js.map","import { TicksClass } from \"../type/Ticks.js\";\nimport { TransportEvent } from \"./TransportEvent.js\";\nimport { GT, LT } from \"../util/Math.js\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n    /**\n     * @param transport The transport object which the event belongs to\n     */\n    constructor(transport, opts) {\n        super(transport, opts);\n        /**\n         * The ID of the current timeline event\n         */\n        this._currentId = -1;\n        /**\n         * The ID of the next timeline event\n         */\n        this._nextId = -1;\n        /**\n         * The time of the next event\n         */\n        this._nextTick = this.time;\n        /**\n         * a reference to the bound start method\n         */\n        this._boundRestart = this._restart.bind(this);\n        const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n        this.duration = options.duration;\n        this._interval = options.interval;\n        this._nextTick = options.time;\n        this.transport.on(\"start\", this._boundRestart);\n        this.transport.on(\"loopStart\", this._boundRestart);\n        this.transport.on(\"ticks\", this._boundRestart);\n        this.context = this.transport.context;\n        this._restart();\n    }\n    static getDefaults() {\n        return Object.assign({}, TransportEvent.getDefaults(), {\n            duration: Infinity,\n            interval: 1,\n            once: false,\n        });\n    }\n    /**\n     * Invoke the callback. Returns the tick time which\n     * the next event should be scheduled at.\n     * @param  time  The AudioContext time in seconds of the event\n     */\n    invoke(time) {\n        // create more events if necessary\n        this._createEvents(time);\n        // call the super class\n        super.invoke(time);\n    }\n    /**\n     * Create an event on the transport on the nextTick\n     */\n    _createEvent() {\n        if (LT(this._nextTick, this.floatTime + this.duration)) {\n            return this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n        }\n        return -1;\n    }\n    /**\n     * Push more events onto the timeline to keep up with the position of the timeline\n     */\n    _createEvents(time) {\n        // schedule the next event\n        // const ticks = this.transport.getTicksAtTime(time);\n        // if the next tick is within the bounds set by \"duration\"\n        if (LT(this._nextTick + this._interval, this.floatTime + this.duration)) {\n            this._nextTick += this._interval;\n            this._currentId = this._nextId;\n            this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n        }\n    }\n    /**\n     * Re-compute the events when the transport time has changed from a start/ticks/loopStart event\n     */\n    _restart(time) {\n        this.transport.clear(this._currentId);\n        this.transport.clear(this._nextId);\n        // start at the first event\n        this._nextTick = this.floatTime;\n        const ticks = this.transport.getTicksAtTime(time);\n        if (GT(ticks, this.time)) {\n            // the event is not being scheduled from the beginning and should be offset\n            this._nextTick =\n                this.floatTime +\n                    Math.ceil((ticks - this.floatTime) / this._interval) *\n                        this._interval;\n        }\n        this._currentId = this._createEvent();\n        this._nextTick += this._interval;\n        this._nextId = this._createEvent();\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.transport.clear(this._currentId);\n        this.transport.clear(this._nextId);\n        this.transport.off(\"start\", this._boundRestart);\n        this.transport.off(\"loopStart\", this._boundRestart);\n        this.transport.off(\"ticks\", this._boundRestart);\n        return this;\n    }\n}\n//# sourceMappingURL=TransportRepeatEvent.js.map","import { TimeClass } from \"../../core/type/Time.js\";\nimport { TimelineValue } from \"../../core/util/TimelineValue.js\";\nimport { Pow } from \"../../signal/Pow.js\";\nimport { onContextClose, onContextInit, } from \"../context/ContextInitialization.js\";\nimport { Gain } from \"../context/Gain.js\";\nimport { ToneWithContext, } from \"../context/ToneWithContext.js\";\nimport { TicksClass } from \"../type/Ticks.js\";\nimport { TransportTimeClass } from \"../type/TransportTime.js\";\nimport { enterScheduledCallback } from \"../util/Debug.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { readOnly, writable } from \"../util/Interface.js\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isArray, isDefined } from \"../util/TypeCheck.js\";\nimport { Clock } from \"./Clock.js\";\nimport { TransportEvent } from \"./TransportEvent.js\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent.js\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.getTransport().scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.getTransport().start();\n * @category Core\n */\nexport class TransportClass extends ToneWithContext {\n    constructor() {\n        const options = optionsFromArguments(TransportClass.getDefaults(), arguments);\n        super(options);\n        this.name = \"Transport\";\n        //-------------------------------------\n        // \tLOOPING\n        //-------------------------------------\n        /**\n         * If the transport loops or not.\n         */\n        this._loop = new TimelineValue(false);\n        /**\n         * The loop start position in ticks\n         */\n        this._loopStart = 0;\n        /**\n         * The loop end position in ticks\n         */\n        this._loopEnd = 0;\n        //-------------------------------------\n        // \tTIMELINE EVENTS\n        //-------------------------------------\n        /**\n         * All the events in an object to keep track by ID\n         */\n        this._scheduledEvents = {};\n        /**\n         * The scheduled events.\n         */\n        this._timeline = new Timeline();\n        /**\n         * Repeated events\n         */\n        this._repeatedEvents = new IntervalTimeline();\n        /**\n         * All of the synced Signals\n         */\n        this._syncedSignals = [];\n        /**\n         * The swing amount\n         */\n        this._swingAmount = 0;\n        // CLOCK/TEMPO\n        this._ppq = options.ppq;\n        this._clock = new Clock({\n            callback: this._processTick.bind(this),\n            context: this.context,\n            frequency: 0,\n            units: \"bpm\",\n        });\n        this._bindClockEvents();\n        this.bpm = this._clock.frequency;\n        this._clock.frequency.multiplier = options.ppq;\n        this.bpm.setValueAtTime(options.bpm, 0);\n        readOnly(this, \"bpm\");\n        this._timeSignature = options.timeSignature;\n        // SWING\n        this._swingTicks = options.ppq / 2; // 8n\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            bpm: 120,\n            loopEnd: \"4m\",\n            loopStart: 0,\n            ppq: 192,\n            swing: 0,\n            swingSubdivision: \"8n\",\n            timeSignature: 4,\n        });\n    }\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    _processTick(tickTime, ticks) {\n        // do the loop test\n        if (this._loop.get(tickTime)) {\n            if (ticks >= this._loopEnd) {\n                this.emit(\"loopEnd\", tickTime);\n                this._clock.setTicksAtTime(this._loopStart, tickTime);\n                ticks = this._loopStart;\n                this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n                this.emit(\"loop\", tickTime);\n            }\n        }\n        // handle swing\n        if (this._swingAmount > 0 &&\n            ticks % this._ppq !== 0 && // not on a downbeat\n            ticks % (this._swingTicks * 2) !== 0) {\n            // add some swing\n            const progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n            const amount = Math.sin(progress * Math.PI) * this._swingAmount;\n            tickTime +=\n                new TicksClass(this.context, (this._swingTicks * 2) / 3).toSeconds() * amount;\n        }\n        // invoke the timeline events scheduled on this tick\n        enterScheduledCallback(true);\n        this._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));\n        enterScheduledCallback(false);\n    }\n    //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.getTransport().schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n    schedule(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.getTransport().scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n    scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n        const event = new TransportRepeatEvent(this, {\n            callback,\n            duration: new TimeClass(this.context, duration).toTicks(),\n            interval: new TimeClass(this.context, interval).toTicks(),\n            time: new TransportTimeClass(this.context, startTime).toTicks(),\n        });\n        // kick it off if the Transport is started\n        // @ts-ignore\n        return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n    scheduleOnce(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            once: true,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n    clear(eventId) {\n        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n            const item = this._scheduledEvents[eventId.toString()];\n            item.timeline.remove(item.event);\n            item.event.dispose();\n            delete this._scheduledEvents[eventId.toString()];\n        }\n        return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n    _addEvent(event, timeline) {\n        this._scheduledEvents[event.id.toString()] = {\n            event,\n            timeline,\n        };\n        timeline.add(event);\n        return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n    cancel(after = 0) {\n        const computedAfter = this.toTicks(after);\n        this._timeline.forEachFrom(computedAfter, (event) => this.clear(event.id));\n        this._repeatedEvents.forEachFrom(computedAfter, (event) => this.clear(event.id));\n        return this;\n    }\n    //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n    _bindClockEvents() {\n        this._clock.on(\"start\", (time, offset) => {\n            offset = new TicksClass(this.context, offset).toSeconds();\n            this.emit(\"start\", time, offset);\n        });\n        this._clock.on(\"stop\", (time) => {\n            this.emit(\"stop\", time);\n        });\n        this._clock.on(\"pause\", (time) => {\n            this.emit(\"pause\", time);\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n    get state() {\n        return this._clock.getStateAtTime(this.now());\n    }\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.getTransport().start(\"+1\", \"4:0:0\");\n     */\n    start(time, offset) {\n        // start the context\n        this.context.resume();\n        let offsetTicks;\n        if (isDefined(offset)) {\n            offsetTicks = this.toTicks(offset);\n        }\n        // start the clock\n        this._clock.start(time, offsetTicks);\n        return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.getTransport().stop();\n     */\n    stop(time) {\n        this._clock.stop(time);\n        return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n    pause(time) {\n        this._clock.pause(time);\n        return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n    toggle(time) {\n        time = this.toSeconds(time);\n        if (this._clock.getStateAtTime(time) !== \"started\") {\n            this.start(time);\n        }\n        else {\n            this.stop(time);\n        }\n        return this;\n    }\n    //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.getTransport().timeSignature = 4;\n     * // 7/8\n     * Tone.getTransport().timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.getTransport().timeSignature; // returns 3.5\n     */\n    get timeSignature() {\n        return this._timeSignature;\n    }\n    set timeSignature(timeSig) {\n        if (isArray(timeSig)) {\n            timeSig = (timeSig[0] / timeSig[1]) * 4;\n        }\n        this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n    get loopStart() {\n        return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    }\n    set loopStart(startPosition) {\n        this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n    get loopEnd() {\n        return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    }\n    set loopEnd(endPosition) {\n        this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n    get loop() {\n        return this._loop.get(this.now());\n    }\n    set loop(loop) {\n        this._loop.set(loop, this.now());\n    }\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.getTransport().setLoopPoints(0, \"1m\");\n     * Tone.getTransport().loop = true;\n     */\n    setLoopPoints(startPosition, endPosition) {\n        this.loopStart = startPosition;\n        this.loopEnd = endPosition;\n        return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n    get swing() {\n        return this._swingAmount;\n    }\n    set swing(amount) {\n        // scale the values to a normal range\n        this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n    get swingSubdivision() {\n        return new TicksClass(this.context, this._swingTicks).toNotation();\n    }\n    set swingSubdivision(subdivision) {\n        this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n    get position() {\n        const now = this.now();\n        const ticks = this._clock.getTicksAtTime(now);\n        return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    }\n    set position(progress) {\n        const ticks = this.toTicks(progress);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds.\n     * Setting the value will jump to that position right away.\n     */\n    get seconds() {\n        return this._clock.seconds;\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this._clock.frequency.timeToTicks(s, now);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the Transport.loop = false.\n     */\n    get progress() {\n        if (this.loop) {\n            const now = this.now();\n            const ticks = this._clock.getTicksAtTime(now);\n            return ((ticks - this._loopStart) / (this._loopEnd - this._loopStart));\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The Transport's current tick position.\n     */\n    get ticks() {\n        return this._clock.ticks;\n    }\n    set ticks(t) {\n        if (this._clock.ticks !== t) {\n            const now = this.now();\n            // stop everything synced to the transport\n            if (this.state === \"started\") {\n                const ticks = this._clock.getTicksAtTime(now);\n                // schedule to start on the next tick, #573\n                const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n                const time = now + remainingTick;\n                this.emit(\"stop\", time);\n                this._clock.setTicksAtTime(t, time);\n                // restart it with the new time\n                this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n            }\n            else {\n                this.emit(\"ticks\", now);\n                this._clock.setTicksAtTime(t, now);\n            }\n        }\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return this._clock.getTicksAtTime(time);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n    get PPQ() {\n        return this._clock.frequency.multiplier;\n    }\n    set PPQ(ppq) {\n        this._clock.frequency.multiplier = ppq;\n    }\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.getTransport().start();\n     * Tone.getTransport().nextSubdivision(\"4n\");\n     */\n    nextSubdivision(subdivision) {\n        subdivision = this.toTicks(subdivision);\n        if (this.state !== \"started\") {\n            // if the transport's not started, return 0\n            return 0;\n        }\n        else {\n            const now = this.now();\n            // the remainder of the current ticks and the subdivision\n            const transportPos = this.getTicksAtTime(now);\n            const remainingTicks = subdivision - (transportPos % subdivision);\n            return this._clock.nextTickTime(remainingTicks, now);\n        }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n    syncSignal(signal, ratio) {\n        const now = this.now();\n        let source = this.bpm;\n        let sourceValue = 1 / (60 / source.getValueAtTime(now) / this.PPQ);\n        let nodes = [];\n        // If the signal is in the time domain, sync it to the reciprocal of\n        // the tempo instead of the tempo.\n        if (signal.units === \"time\") {\n            // The input to Pow should be in the range [1 / 4096, 1], where\n            // where 4096 is half of the buffer size of Pow's waveshaper.\n            // Pick a scaling factor based on the initial tempo that ensures\n            // that the initial input is in this range, while leaving room for\n            // tempo changes.\n            const scaleFactor = 1 / 64 / sourceValue;\n            const scaleBefore = new Gain(scaleFactor);\n            const reciprocal = new Pow(-1);\n            const scaleAfter = new Gain(scaleFactor);\n            // @ts-ignore\n            source.chain(scaleBefore, reciprocal, scaleAfter);\n            source = scaleAfter;\n            sourceValue = 1 / sourceValue;\n            nodes = [scaleBefore, reciprocal, scaleAfter];\n        }\n        if (!ratio) {\n            // get the sync ratio\n            if (signal.getValueAtTime(now) !== 0) {\n                ratio = signal.getValueAtTime(now) / sourceValue;\n            }\n            else {\n                ratio = 0;\n            }\n        }\n        const ratioSignal = new Gain(ratio);\n        // @ts-ignore\n        source.connect(ratioSignal);\n        // @ts-ignore\n        ratioSignal.connect(signal._param);\n        nodes.push(ratioSignal);\n        this._syncedSignals.push({\n            initial: signal.value,\n            nodes: nodes,\n            signal,\n        });\n        signal.value = 0;\n        return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * @see {@link syncSignal}.\n     */\n    unsyncSignal(signal) {\n        for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n            const syncedSignal = this._syncedSignals[i];\n            if (syncedSignal.signal === signal) {\n                syncedSignal.nodes.forEach((node) => node.dispose());\n                syncedSignal.signal.value = syncedSignal.initial;\n                this._syncedSignals.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._clock.dispose();\n        writable(this, \"bpm\");\n        this._timeline.dispose();\n        this._repeatedEvents.dispose();\n        return this;\n    }\n}\nEmitter.mixin(TransportClass);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit((context) => {\n    context.transport = new TransportClass({ context });\n});\nonContextClose((context) => {\n    context.transport.dispose();\n});\n//# sourceMappingURL=Transport.js.map","import { Volume } from \"../component/channel/Volume.js\";\nimport \"../core/context/Destination.js\";\nimport \"../core/clock/Transport.js\";\nimport { ToneAudioNode, } from \"../core/context/ToneAudioNode.js\";\nimport { defaultArg } from \"../core/util/Defaults.js\";\nimport { noOp, readOnly } from \"../core/util/Interface.js\";\nimport { StateTimeline, } from \"../core/util/StateTimeline.js\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck.js\";\nimport { assert, assertContextRunning } from \"../core/util/Debug.js\";\nimport { GT } from \"../core/util/Math.js\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport class Source extends ToneAudioNode {\n    constructor(options) {\n        super(options);\n        /**\n         * Sources have no inputs\n         */\n        this.input = undefined;\n        /**\n         * Keep track of the scheduled state.\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * The synced `start` callback function from the transport\n         */\n        this._synced = false;\n        /**\n         * Keep track of all of the scheduled event ids\n         */\n        this._scheduled = [];\n        /**\n         * Placeholder functions for syncing/unsyncing to transport\n         */\n        this._syncedStart = noOp;\n        this._syncedStop = noOp;\n        this._state.memory = 100;\n        this._state.increasing = true;\n        this._volume = this.output = new Volume({\n            context: this.context,\n            mute: options.mute,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n        this.onstop = options.onstop;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            onstop: noOp,\n            volume: 0,\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    get state() {\n        if (this._synced) {\n            if (this.context.transport.state === \"started\") {\n                return this._state.getValueAtTime(this.context.transport.seconds);\n            }\n            else {\n                return \"stopped\";\n            }\n        }\n        else {\n            return this._state.getValueAtTime(this.now());\n        }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n    _clampToCurrentTime(time) {\n        if (this._synced) {\n            return time;\n        }\n        else {\n            return Math.max(time, this.context.currentTime);\n        }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n    start(time, offset, duration) {\n        let computedTime = isUndef(time) && this._synced\n            ? this.context.transport.seconds\n            : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        // if it's started, stop it and restart it\n        if (!this._synced &&\n            this._state.getValueAtTime(computedTime) === \"started\") {\n            // time should be strictly greater than the previous start time\n            assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            this.log(\"restart\", computedTime);\n            this.restart(computedTime, offset, duration);\n        }\n        else {\n            this.log(\"start\", computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (this._synced) {\n                // add the offset time to the event\n                const event = this._state.get(computedTime);\n                if (event) {\n                    event.offset = this.toSeconds(defaultArg(offset, 0));\n                    event.duration = duration\n                        ? this.toSeconds(duration)\n                        : undefined;\n                }\n                const sched = this.context.transport.schedule((t) => {\n                    this._start(t, offset, duration);\n                }, computedTime);\n                this._scheduled.push(sched);\n                // if the transport is already started\n                // and the time is greater than where the transport is\n                if (this.context.transport.state === \"started\" &&\n                    this.context.transport.getSecondsAtTime(this.immediate()) >\n                        computedTime) {\n                    this._syncedStart(this.now(), this.context.transport.seconds);\n                }\n            }\n            else {\n                assertContextRunning(this.context);\n                this._start(computedTime, offset, duration);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n    stop(time) {\n        let computedTime = isUndef(time) && this._synced\n            ? this.context.transport.seconds\n            : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        if (this._state.getValueAtTime(computedTime) === \"started\" ||\n            isDefined(this._state.getNextState(\"started\", computedTime))) {\n            this.log(\"stop\", computedTime);\n            if (!this._synced) {\n                this._stop(computedTime);\n            }\n            else {\n                const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n                this._scheduled.push(sched);\n            }\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"stopped\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Restart the source.\n     */\n    restart(time, offset, duration) {\n        time = this.toSeconds(time);\n        if (this._state.getValueAtTime(time) === \"started\") {\n            this._state.cancel(time);\n            this._restart(time, offset, duration);\n        }\n        return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n    sync() {\n        if (!this._synced) {\n            this._synced = true;\n            this._syncedStart = (time, offset) => {\n                if (GT(offset, 0)) {\n                    // get the playback state at that time\n                    const stateEvent = this._state.get(offset);\n                    // listen for start events which may occur in the middle of the sync'ed time\n                    if (stateEvent &&\n                        stateEvent.state === \"started\" &&\n                        stateEvent.time !== offset) {\n                        // get the offset\n                        const startOffset = offset - this.toSeconds(stateEvent.time);\n                        let duration;\n                        if (stateEvent.duration) {\n                            duration =\n                                this.toSeconds(stateEvent.duration) -\n                                    startOffset;\n                        }\n                        this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n                    }\n                }\n            };\n            this._syncedStop = (time) => {\n                const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n                if (this._state.getValueAtTime(seconds) === \"started\") {\n                    this._stop(time);\n                }\n            };\n            this.context.transport.on(\"start\", this._syncedStart);\n            this.context.transport.on(\"loopStart\", this._syncedStart);\n            this.context.transport.on(\"stop\", this._syncedStop);\n            this.context.transport.on(\"pause\", this._syncedStop);\n            this.context.transport.on(\"loopEnd\", this._syncedStop);\n        }\n        return this;\n    }\n    /**\n     * Unsync the source to the Transport.\n     * @see {@link sync}\n     */\n    unsync() {\n        if (this._synced) {\n            this.context.transport.off(\"stop\", this._syncedStop);\n            this.context.transport.off(\"pause\", this._syncedStop);\n            this.context.transport.off(\"loopEnd\", this._syncedStop);\n            this.context.transport.off(\"start\", this._syncedStart);\n            this.context.transport.off(\"loopStart\", this._syncedStart);\n        }\n        this._synced = false;\n        // clear all of the scheduled ids\n        this._scheduled.forEach((id) => this.context.transport.clear(id));\n        this._scheduled = [];\n        this._state.cancel(0);\n        // stop it also\n        this._stop(0);\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.onstop = noOp;\n        this.unsync();\n        this._volume.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Source.js.map","import { connect } from \"../../core/context/ToneAudioNode.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { isDefined } from \"../../core/util/TypeCheck.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { OneShotSource, } from \"../OneShotSource.js\";\nimport { EQ, GTE, LT } from \"../../core/util/Math.js\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource {\n    constructor() {\n        const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n        super(options);\n        this.name = \"ToneBufferSource\";\n        /**\n         * The oscillator\n         */\n        this._source = this.context.createBufferSource();\n        this._internalChannels = [this._source];\n        /**\n         * indicators if the source has started/stopped\n         */\n        this._sourceStarted = false;\n        this._sourceStopped = false;\n        connect(this._source, this._gainNode);\n        this._source.onended = () => this._stopSource();\n        /**\n         * The playbackRate of the buffer\n         */\n        this.playbackRate = new Param({\n            context: this.context,\n            param: this._source.playbackRate,\n            units: \"positive\",\n            value: options.playbackRate,\n        });\n        // set some values initially\n        this.loop = options.loop;\n        this.loopStart = options.loopStart;\n        this.loopEnd = options.loopEnd;\n        this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n        this._internalChannels.push(this._source);\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            url: new ToneAudioBuffer(),\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            onload: noOp,\n            onerror: noOp,\n            playbackRate: 1,\n        });\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get fadeIn() {\n        return this._fadeIn;\n    }\n    set fadeIn(t) {\n        this._fadeIn = t;\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get fadeOut() {\n        return this._fadeOut;\n    }\n    set fadeOut(t) {\n        this._fadeOut = t;\n    }\n    /**\n     * The curve applied to the fades, either \"linear\" or \"exponential\"\n     */\n    get curve() {\n        return this._curve;\n    }\n    set curve(t) {\n        this._curve = t;\n    }\n    /**\n     * Start the buffer\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n     * @param  gain  The gain to play the buffer back at.\n     */\n    start(time, offset, duration, gain = 1) {\n        assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n        const computedTime = this.toSeconds(time);\n        // apply the gain envelope\n        this._startGain(computedTime, gain);\n        // if it's a loop the default offset is the loopstart point\n        if (this.loop) {\n            offset = defaultArg(offset, this.loopStart);\n        }\n        else {\n            // otherwise the default offset is 0\n            offset = defaultArg(offset, 0);\n        }\n        // make sure the offset is not less than 0\n        let computedOffset = Math.max(this.toSeconds(offset), 0);\n        // start the buffer source\n        if (this.loop) {\n            // modify the offset if it's greater than the loop time\n            const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n            const loopStart = this.toSeconds(this.loopStart);\n            const loopDuration = loopEnd - loopStart;\n            // move the offset back\n            if (GTE(computedOffset, loopEnd)) {\n                computedOffset =\n                    ((computedOffset - loopStart) % loopDuration) + loopStart;\n            }\n            // when the offset is very close to the duration, set it to 0\n            if (EQ(computedOffset, this.buffer.duration)) {\n                computedOffset = 0;\n            }\n        }\n        // this.buffer.loaded would have return false if the AudioBuffer was undefined\n        this._source.buffer = this.buffer.get();\n        this._source.loopEnd =\n            this.toSeconds(this.loopEnd) || this.buffer.duration;\n        if (LT(computedOffset, this.buffer.duration)) {\n            this._sourceStarted = true;\n            this._source.start(computedTime, computedOffset);\n        }\n        // if a duration is given, schedule a stop\n        if (isDefined(duration)) {\n            let computedDur = this.toSeconds(duration);\n            // make sure it's never negative\n            computedDur = Math.max(computedDur, 0);\n            this.stop(computedTime + computedDur);\n        }\n        return this;\n    }\n    _stopSource(time) {\n        if (!this._sourceStopped && this._sourceStarted) {\n            this._sourceStopped = true;\n            this._source.stop(this.toSeconds(time));\n            this._onended();\n        }\n    }\n    /**\n     * If loop is true, the loop will start at this position.\n     */\n    get loopStart() {\n        return this._source.loopStart;\n    }\n    set loopStart(loopStart) {\n        this._source.loopStart = this.toSeconds(loopStart);\n    }\n    /**\n     * If loop is true, the loop will end at this position.\n     */\n    get loopEnd() {\n        return this._source.loopEnd;\n    }\n    set loopEnd(loopEnd) {\n        this._source.loopEnd = this.toSeconds(loopEnd);\n    }\n    /**\n     * The audio buffer belonging to the player.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    set buffer(buffer) {\n        this._buffer.set(buffer);\n    }\n    /**\n     * If the buffer should loop once it's over.\n     */\n    get loop() {\n        return this._source.loop;\n    }\n    set loop(loop) {\n        this._source.loop = loop;\n        if (this._sourceStarted) {\n            this.cancelStop();\n        }\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._source.onended = null;\n        this._source.disconnect();\n        this._buffer.dispose();\n        this.playbackRate.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneBufferSource.js.map","import { __awaiter } from \"tslib\";\nimport { OfflineContext } from \"../../core/context/OfflineContext.js\";\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\nexport function generateWaveform(instance, length) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const duration = length / instance.context.sampleRate;\n        const context = new OfflineContext(1, duration, instance.context.sampleRate);\n        const clone = new instance.constructor(Object.assign(instance.get(), {\n            // should do 2 iterations\n            frequency: 2 / duration,\n            // zero out the detune\n            detune: 0,\n            context,\n        })).toDestination();\n        clone.start(0);\n        const buffer = yield context.render();\n        return buffer.getChannelData(0);\n    });\n}\n//# sourceMappingURL=OscillatorInterface.js.map","import { connect } from \"../../core/context/ToneAudioNode.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { OneShotSource } from \"../OneShotSource.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***{@link Oscillator} is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource {\n    constructor() {\n        const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        super(options);\n        this.name = \"ToneOscillatorNode\";\n        /**\n         * The oscillator\n         */\n        this._oscillator = this.context.createOscillator();\n        this._internalChannels = [this._oscillator];\n        connect(this._oscillator, this._gainNode);\n        this.type = options.type;\n        this.frequency = new Param({\n            context: this.context,\n            param: this._oscillator.frequency,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Param({\n            context: this.context,\n            param: this._oscillator.detune,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            type: \"sine\",\n        });\n    }\n    /**\n     * Start the oscillator node at the given time\n     * @param  time When to start the oscillator\n     */\n    start(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        this._startGain(computedTime);\n        this._oscillator.start(computedTime);\n        return this;\n    }\n    _stopSource(time) {\n        this._oscillator.stop(time);\n    }\n    /**\n     * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n     * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n     */\n    setPeriodicWave(periodicWave) {\n        this._oscillator.setPeriodicWave(periodicWave);\n        return this;\n    }\n    /**\n     * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n     */\n    get type() {\n        return this._oscillator.type;\n    }\n    set type(type) {\n        this._oscillator.type = type;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        if (this.state === \"started\") {\n            this.stop();\n        }\n        this._oscillator.disconnect();\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneOscillatorNode.js.map","import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { isDefined } from \"../../core/util/TypeCheck.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\nimport { clamp } from \"../../core/util/Math.js\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        super(options);\n        this.name = \"Oscillator\";\n        /**\n         * the main oscillator\n         */\n        this._oscillator = null;\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, \"detune\");\n        this._partials = options.partials;\n        this._partialCount = options.partialCount;\n        this._type = options.type;\n        if (options.partialCount && options.type !== \"custom\") {\n            this._type = (this.baseType +\n                options.partialCount.toString());\n        }\n        this.phase = options.phase;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            partialCount: 0,\n            partials: [],\n            phase: 0,\n            type: \"sine\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        const computedTime = this.toSeconds(time);\n        // new oscillator with previous values\n        const oscillator = new ToneOscillatorNode({\n            context: this.context,\n            onended: () => this.onstop(this),\n        });\n        this._oscillator = oscillator;\n        if (this._wave) {\n            this._oscillator.setPeriodicWave(this._wave);\n        }\n        else {\n            this._oscillator.type = this._type;\n        }\n        // connect the control signal to the oscillator frequency & detune\n        this._oscillator.connect(this.output);\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n        // start the oscillator\n        this._oscillator.start(computedTime);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._oscillator) {\n            this._oscillator.stop(computedTime);\n        }\n    }\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n    _restart(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"restart\", computedTime);\n        if (this._oscillator) {\n            this._oscillator.cancelStop();\n        }\n        this._state.cancel(computedTime);\n        return this;\n    }\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Tone.Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n    syncFrequency() {\n        this.context.transport.syncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * @see {@link syncFrequency}\n     */\n    unsyncFrequency() {\n        this.context.transport.unsyncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n    _getCachedPeriodicWave() {\n        if (this._type === \"custom\") {\n            const oscProps = Oscillator._periodicWaveCache.find((description) => {\n                return (description.phase === this._phase &&\n                    deepEquals(description.partials, this._partials));\n            });\n            return oscProps;\n        }\n        else {\n            const oscProps = Oscillator._periodicWaveCache.find((description) => {\n                return (description.type === this._type &&\n                    description.phase === this._phase);\n            });\n            this._partialCount = oscProps\n                ? oscProps.partialCount\n                : this._partialCount;\n            return oscProps;\n        }\n    }\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._type = type;\n        const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n        if (this._phase === 0 && isBasicType) {\n            this._wave = undefined;\n            this._partialCount = 0;\n            // just go with the basic approach\n            if (this._oscillator !== null) {\n                // already tested that it's a basic type\n                this._oscillator.type = type;\n            }\n        }\n        else {\n            // first check if the value is cached\n            const cache = this._getCachedPeriodicWave();\n            if (isDefined(cache)) {\n                const { partials, wave } = cache;\n                this._wave = wave;\n                this._partials = partials;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n            }\n            else {\n                const [real, imag] = this._getRealImaginary(type, this._phase);\n                const periodicWave = this.context.createPeriodicWave(real, imag);\n                this._wave = periodicWave;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n                // set the cache\n                Oscillator._periodicWaveCache.push({\n                    imag,\n                    partialCount: this._partialCount,\n                    partials: this._partials,\n                    phase: this._phase,\n                    real,\n                    type: this._type,\n                    wave: this._wave,\n                });\n                if (Oscillator._periodicWaveCache.length > 100) {\n                    Oscillator._periodicWaveCache.shift();\n                }\n            }\n        }\n    }\n    get baseType() {\n        return this._type.replace(this.partialCount.toString(), \"\");\n    }\n    set baseType(baseType) {\n        if (this.partialCount &&\n            this._type !== \"custom\" &&\n            baseType !== \"custom\") {\n            this.type = (baseType + this.partialCount);\n        }\n        else {\n            this.type = baseType;\n        }\n    }\n    get partialCount() {\n        return this._partialCount;\n    }\n    set partialCount(p) {\n        assertRange(p, 0);\n        let type = this._type;\n        const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n        if (partial) {\n            type = partial[1];\n        }\n        if (this._type !== \"custom\") {\n            if (p === 0) {\n                this.type = type;\n            }\n            else {\n                this.type = (type + p.toString());\n            }\n        }\n        else {\n            // extend or shorten the partials array\n            const fullPartials = new Float32Array(p);\n            // copy over the partials array\n            this._partials.forEach((v, i) => (fullPartials[i] = v));\n            this._partials = Array.from(fullPartials);\n            this.type = this._type;\n        }\n    }\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n    _getRealImaginary(type, phase) {\n        const fftSize = 4096;\n        let periodicWaveSize = fftSize / 2;\n        const real = new Float32Array(periodicWaveSize);\n        const imag = new Float32Array(periodicWaveSize);\n        let partialCount = 1;\n        if (type === \"custom\") {\n            partialCount = this._partials.length + 1;\n            this._partialCount = this._partials.length;\n            periodicWaveSize = partialCount;\n            // if the partial count is 0, don't bother doing any computation\n            if (this._partials.length === 0) {\n                return [real, imag];\n            }\n        }\n        else {\n            const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n            if (partial) {\n                partialCount = parseInt(partial[2], 10) + 1;\n                this._partialCount = parseInt(partial[2], 10);\n                type = partial[1];\n                partialCount = Math.max(partialCount, 2);\n                periodicWaveSize = partialCount;\n            }\n            else {\n                this._partialCount = 0;\n            }\n            this._partials = [];\n        }\n        for (let n = 1; n < periodicWaveSize; ++n) {\n            const piFactor = 2 / (n * Math.PI);\n            let b;\n            switch (type) {\n                case \"sine\":\n                    b = n <= partialCount ? 1 : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"square\":\n                    b = n & 1 ? 2 * piFactor : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"sawtooth\":\n                    b = piFactor * (n & 1 ? 1 : -1);\n                    this._partials[n - 1] = b;\n                    break;\n                case \"triangle\":\n                    if (n & 1) {\n                        b =\n                            2 *\n                                (piFactor * piFactor) *\n                                (((n - 1) >> 1) & 1 ? -1 : 1);\n                    }\n                    else {\n                        b = 0;\n                    }\n                    this._partials[n - 1] = b;\n                    break;\n                case \"custom\":\n                    b = this._partials[n - 1];\n                    break;\n                default:\n                    throw new TypeError(\"Oscillator: invalid type: \" + type);\n            }\n            if (b !== 0) {\n                real[n] = -b * Math.sin(phase * n);\n                imag[n] = b * Math.cos(phase * n);\n            }\n            else {\n                real[n] = 0;\n                imag[n] = 0;\n            }\n        }\n        return [real, imag];\n    }\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n    _inverseFFT(real, imag, phase) {\n        let sum = 0;\n        const len = real.length;\n        for (let i = 0; i < len; i++) {\n            sum +=\n                real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n        }\n        return sum;\n    }\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n    getInitialValue() {\n        const [real, imag] = this._getRealImaginary(this._type, 0);\n        let maxValue = 0;\n        const twoPi = Math.PI * 2;\n        const testPositions = 32;\n        // check for peaks in 16 places\n        for (let i = 0; i < testPositions; i++) {\n            maxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n        }\n        return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    }\n    get partials() {\n        return this._partials.slice(0, this.partialCount);\n    }\n    set partials(partials) {\n        this._partials = partials;\n        this._partialCount = this._partials.length;\n        if (partials.length) {\n            this.type = \"custom\";\n        }\n    }\n    get phase() {\n        return this._phase * (180 / Math.PI);\n    }\n    set phase(phase) {\n        this._phase = (phase * Math.PI) / 180;\n        // reset the type\n        this.type = this._type;\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._oscillator !== null) {\n            this._oscillator.dispose();\n        }\n        this._wave = undefined;\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\nOscillator._periodicWaveCache = [];\n//# sourceMappingURL=Oscillator.js.map","import { SignalOperator } from \"./SignalOperator.js\";\nimport { WaveShaper } from \"./WaveShaper.js\";\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * @see {@link GainToAudio}.\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator {\n    constructor() {\n        super(...arguments);\n        this.name = \"AudioToGain\";\n        /**\n         * The node which converts the audio ranges\n         */\n        this._norm = new WaveShaper({\n            context: this.context,\n            mapping: (x) => (x + 1) / 2,\n        });\n        /**\n         * The AudioRange input [-1, 1]\n         */\n        this.input = this._norm;\n        /**\n         * The GainRange output [0, 1]\n         */\n        this.output = this._norm;\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this._norm.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AudioToGain.js.map","import { Gain } from \"../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Signal } from \"./Signal.js\";\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\nexport class Multiply extends Signal {\n    constructor() {\n        const options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n        super(options);\n        this.name = \"Multiply\";\n        /**\n         * Indicates if the value should be overridden on connection\n         */\n        this.override = false;\n        this._mult =\n            this.input =\n                this.output =\n                    new Gain({\n                        context: this.context,\n                        minValue: options.minValue,\n                        maxValue: options.maxValue,\n                    });\n        this.factor = this._param = this._mult\n            .gain;\n        this.factor.setValueAtTime(options.value, 0);\n    }\n    static getDefaults() {\n        return Object.assign(Signal.getDefaults(), {\n            value: 0,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._mult.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Multiply.js.map","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { AudioToGain } from \"../../signal/AudioToGain.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * }, 0.2, 1);\n * @category Source\n */\nexport class AMOscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n        super(options);\n        this.name = \"AMOscillator\";\n        /**\n         * convert the -1,1 output to 0,1\n         */\n        this._modulationScale = new AudioToGain({ context: this.context });\n        /**\n         * the node where the modulation happens\n         */\n        this._modulationNode = new Gain({\n            context: this.context,\n        });\n        this._carrier = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: options.type,\n        });\n        (this.frequency = this._carrier.frequency),\n            (this.detune = this._carrier.detune);\n        this._modulator = new Oscillator({\n            context: this.context,\n            phase: options.phase,\n            type: options.modulationType,\n        });\n        this.harmonicity = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.harmonicity,\n        });\n        // connections\n        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n        this._carrier.chain(this._modulationNode, this.output);\n        readOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            harmonicity: 1,\n            modulationType: \"square\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._modulator.start(time);\n        this._carrier.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        this._modulator.stop(time);\n        this._carrier.stop(time);\n    }\n    _restart(time) {\n        this._modulator.restart(time);\n        this._carrier.restart(time);\n    }\n    /**\n     * The type of the carrier oscillator\n     */\n    get type() {\n        return this._carrier.type;\n    }\n    set type(type) {\n        this._carrier.type = type;\n    }\n    get baseType() {\n        return this._carrier.baseType;\n    }\n    set baseType(baseType) {\n        this._carrier.baseType = baseType;\n    }\n    get partialCount() {\n        return this._carrier.partialCount;\n    }\n    set partialCount(partialCount) {\n        this._carrier.partialCount = partialCount;\n    }\n    /**\n     * The type of the modulator oscillator\n     */\n    get modulationType() {\n        return this._modulator.type;\n    }\n    set modulationType(type) {\n        this._modulator.type = type;\n    }\n    get phase() {\n        return this._carrier.phase;\n    }\n    set phase(phase) {\n        this._carrier.phase = phase;\n        this._modulator.phase = phase;\n    }\n    get partials() {\n        return this._carrier.partials;\n    }\n    set partials(partials) {\n        this._carrier.partials = partials;\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.detune.dispose();\n        this.harmonicity.dispose();\n        this._carrier.dispose();\n        this._modulator.dispose();\n        this._modulationNode.dispose();\n        this._modulationScale.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AMOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n        super(options);\n        this.name = \"FMOscillator\";\n        /**\n         * the node where the modulation happens\n         */\n        this._modulationNode = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        this._carrier = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: 0,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: options.type,\n        });\n        this.detune = this._carrier.detune;\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this._modulator = new Oscillator({\n            context: this.context,\n            phase: options.phase,\n            type: options.modulationType,\n        });\n        this.harmonicity = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.harmonicity,\n        });\n        this.modulationIndex = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.modulationIndex,\n        });\n        // connections\n        this.frequency.connect(this._carrier.frequency);\n        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n        this.frequency.chain(this.modulationIndex, this._modulationNode);\n        this._modulator.connect(this._modulationNode.gain);\n        this._modulationNode.connect(this._carrier.frequency);\n        this._carrier.connect(this.output);\n        this.detune.connect(this._modulator.detune);\n        readOnly(this, [\n            \"modulationIndex\",\n            \"frequency\",\n            \"detune\",\n            \"harmonicity\",\n        ]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            harmonicity: 1,\n            modulationIndex: 2,\n            modulationType: \"square\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._modulator.start(time);\n        this._carrier.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        this._modulator.stop(time);\n        this._carrier.stop(time);\n    }\n    _restart(time) {\n        this._modulator.restart(time);\n        this._carrier.restart(time);\n        return this;\n    }\n    get type() {\n        return this._carrier.type;\n    }\n    set type(type) {\n        this._carrier.type = type;\n    }\n    get baseType() {\n        return this._carrier.baseType;\n    }\n    set baseType(baseType) {\n        this._carrier.baseType = baseType;\n    }\n    get partialCount() {\n        return this._carrier.partialCount;\n    }\n    set partialCount(partialCount) {\n        this._carrier.partialCount = partialCount;\n    }\n    /**\n     * The type of the modulator oscillator\n     */\n    get modulationType() {\n        return this._modulator.type;\n    }\n    set modulationType(type) {\n        this._modulator.type = type;\n    }\n    get phase() {\n        return this._carrier.phase;\n    }\n    set phase(phase) {\n        this._carrier.phase = phase;\n        this._modulator.phase = phase;\n    }\n    get partials() {\n        return this._carrier.partials;\n    }\n    set partials(partials) {\n        this._carrier.partials = partials;\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.harmonicity.dispose();\n        this._carrier.dispose();\n        this._modulator.dispose();\n        this._modulationNode.dispose();\n        this.modulationIndex.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=FMOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { WaveShaper } from \"../../signal/WaveShaper.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PulseOscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n        super(options);\n        this.name = \"PulseOscillator\";\n        /**\n         * gate the width amount\n         */\n        this._widthGate = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        /**\n         * Threshold the signal to turn it into a square\n         */\n        this._thresh = new WaveShaper({\n            context: this.context,\n            mapping: (val) => (val <= 0 ? -1 : 1),\n        });\n        this.width = new Signal({\n            context: this.context,\n            units: \"audioRange\",\n            value: options.width,\n        });\n        this._triangle = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: \"triangle\",\n        });\n        this.frequency = this._triangle.frequency;\n        this.detune = this._triangle.detune;\n        // connections\n        this._triangle.chain(this._thresh, this.output);\n        this.width.chain(this._widthGate, this._thresh);\n        readOnly(this, [\"width\", \"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            phase: 0,\n            type: \"pulse\",\n            width: 0.2,\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._triangle.start(time);\n        this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._triangle.stop(time);\n        // the width is still connected to the output.\n        // that needs to be stopped also\n        this._widthGate.gain.cancelScheduledValues(time);\n        this._widthGate.gain.setValueAtTime(0, time);\n    }\n    _restart(time) {\n        this._triangle.restart(time);\n        this._widthGate.gain.cancelScheduledValues(time);\n        this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n    get phase() {\n        return this._triangle.phase;\n    }\n    set phase(phase) {\n        this._triangle.phase = phase;\n    }\n    /**\n     * The type of the oscillator. Always returns \"pulse\".\n     */\n    get type() {\n        return \"pulse\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pulse\".\n     */\n    get baseType() {\n        return \"pulse\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n    get partials() {\n        return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n    get partialCount() {\n        return 0;\n    }\n    /**\n     * *Internal use* The carrier oscillator type is fed through the\n     * waveshaper node to create the pulse. Using different carrier oscillators\n     * changes oscillator's behavior.\n     */\n    set carrierType(type) {\n        this._triangle.type = type;\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up method.\n     */\n    dispose() {\n        super.dispose();\n        this._triangle.dispose();\n        this.width.dispose();\n        this._widthGate.dispose();\n        this._thresh.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PulseOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp, readOnly } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n        super(options);\n        this.name = \"FatOscillator\";\n        /**\n         * The array of oscillators\n         */\n        this._oscillators = [];\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        this._spread = options.spread;\n        this._type = options.type;\n        this._phase = options.phase;\n        this._partials = options.partials;\n        this._partialCount = options.partialCount;\n        // set the count initially\n        this.count = options.count;\n        readOnly(this, [\"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            count: 3,\n            spread: 20,\n            type: \"sawtooth\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._forEach((osc) => osc.start(time));\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._forEach((osc) => osc.stop(time));\n    }\n    _restart(time) {\n        this._forEach((osc) => osc.restart(time));\n    }\n    /**\n     * Iterate over all of the oscillators\n     */\n    _forEach(iterator) {\n        for (let i = 0; i < this._oscillators.length; i++) {\n            iterator(this._oscillators[i], i);\n        }\n    }\n    /**\n     * The type of the oscillator\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._type = type;\n        this._forEach((osc) => (osc.type = type));\n    }\n    /**\n     * The detune spread between the oscillators. If \"count\" is\n     * set to 3 oscillators and the \"spread\" is set to 40,\n     * the three oscillators would be detuned like this: [-20, 0, 20]\n     * for a total detune spread of 40 cents.\n     * @example\n     * const fatOsc = new Tone.FatOscillator().toDestination().start();\n     * fatOsc.spread = 70;\n     */\n    get spread() {\n        return this._spread;\n    }\n    set spread(spread) {\n        this._spread = spread;\n        if (this._oscillators.length > 1) {\n            const start = -spread / 2;\n            const step = spread / (this._oscillators.length - 1);\n            this._forEach((osc, i) => (osc.detune.value = start + step * i));\n        }\n    }\n    /**\n     * The number of detuned oscillators. Must be an integer greater than 1.\n     * @example\n     * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n     * // use 4 sawtooth oscillators\n     * fatOsc.count = 4;\n     */\n    get count() {\n        return this._oscillators.length;\n    }\n    set count(count) {\n        assertRange(count, 1);\n        if (this._oscillators.length !== count) {\n            // dispose the previous oscillators\n            this._forEach((osc) => osc.dispose());\n            this._oscillators = [];\n            for (let i = 0; i < count; i++) {\n                const osc = new Oscillator({\n                    context: this.context,\n                    volume: -6 - count * 1.1,\n                    type: this._type,\n                    phase: this._phase + (i / count) * 360,\n                    partialCount: this._partialCount,\n                    onstop: i === 0 ? () => this.onstop(this) : noOp,\n                });\n                if (this.type === \"custom\") {\n                    osc.partials = this._partials;\n                }\n                this.frequency.connect(osc.frequency);\n                this.detune.connect(osc.detune);\n                osc.detune.overridden = false;\n                osc.connect(this.output);\n                this._oscillators[i] = osc;\n            }\n            // set the spread\n            this.spread = this._spread;\n            if (this.state === \"started\") {\n                this._forEach((osc) => osc.start());\n            }\n        }\n    }\n    get phase() {\n        return this._phase;\n    }\n    set phase(phase) {\n        this._phase = phase;\n        this._forEach((osc, i) => (osc.phase = this._phase + (i / this.count) * 360));\n    }\n    get baseType() {\n        return this._oscillators[0].baseType;\n    }\n    set baseType(baseType) {\n        this._forEach((osc) => (osc.baseType = baseType));\n        this._type = this._oscillators[0].type;\n    }\n    get partials() {\n        return this._oscillators[0].partials;\n    }\n    set partials(partials) {\n        this._partials = partials;\n        this._partialCount = this._partials.length;\n        if (partials.length) {\n            this._type = \"custom\";\n            this._forEach((osc) => (osc.partials = partials));\n        }\n    }\n    get partialCount() {\n        return this._oscillators[0].partialCount;\n    }\n    set partialCount(partialCount) {\n        this._partialCount = partialCount;\n        this._forEach((osc) => (osc.partialCount = partialCount));\n        this._type = this._oscillators[0].type;\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.detune.dispose();\n        this._forEach((osc) => osc.dispose());\n        return this;\n    }\n}\n//# sourceMappingURL=FatOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\nimport { PulseOscillator } from \"./PulseOscillator.js\";\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * return Tone.Offline(() => {\n * \tconst pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PWMOscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n        super(options);\n        this.name = \"PWMOscillator\";\n        this.sourceType = \"pwm\";\n        /**\n         * Scale the oscillator so it doesn't go silent\n         * at the extreme values.\n         */\n        this._scale = new Multiply({\n            context: this.context,\n            value: 2,\n        });\n        this._pulse = new PulseOscillator({\n            context: this.context,\n            frequency: options.modulationFrequency,\n        });\n        // change the pulse oscillator type\n        this._pulse.carrierType = \"sine\";\n        this.modulationFrequency = this._pulse.frequency;\n        this._modulator = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n        });\n        this.frequency = this._modulator.frequency;\n        this.detune = this._modulator.detune;\n        // connections\n        this._modulator.chain(this._scale, this._pulse.width);\n        this._pulse.connect(this.output);\n        readOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            modulationFrequency: 0.4,\n            phase: 0,\n            type: \"pwm\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._modulator.start(time);\n        this._pulse.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._modulator.stop(time);\n        this._pulse.stop(time);\n    }\n    /**\n     * restart the oscillator\n     */\n    _restart(time) {\n        this._modulator.restart(time);\n        this._pulse.restart(time);\n    }\n    /**\n     * The type of the oscillator. Always returns \"pwm\".\n     */\n    get type() {\n        return \"pwm\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pwm\".\n     */\n    get baseType() {\n        return \"pwm\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n    get partials() {\n        return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n    get partialCount() {\n        return 0;\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n    get phase() {\n        return this._modulator.phase;\n    }\n    set phase(phase) {\n        this._modulator.phase = phase;\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._pulse.dispose();\n        this._scale.dispose();\n        this._modulator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PWMOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { AMOscillator } from \"./AMOscillator.js\";\nimport { FatOscillator } from \"./FatOscillator.js\";\nimport { FMOscillator } from \"./FMOscillator.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport { generateWaveform, } from \"./OscillatorInterface.js\";\nimport { PulseOscillator } from \"./PulseOscillator.js\";\nimport { PWMOscillator } from \"./PWMOscillator.js\";\nconst OmniOscillatorSourceMap = {\n    am: AMOscillator,\n    fat: FatOscillator,\n    fm: FMOscillator,\n    oscillator: Oscillator,\n    pulse: PulseOscillator,\n    pwm: PWMOscillator,\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator extends Source {\n    constructor() {\n        const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        super(options);\n        this.name = \"OmniOscillator\";\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n        // set the options\n        this.set(options);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._oscillator.start(time);\n    }\n    /**\n     * start the oscillator\n     */\n    _stop(time) {\n        this._oscillator.stop(time);\n    }\n    _restart(time) {\n        this._oscillator.restart(time);\n        return this;\n    }\n    /**\n     * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n     * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n     * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n     * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n     * when it's not.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n     * omniOsc.type = \"pwm\";\n     * // modulationFrequency is parameter which is available\n     * // only when the type is \"pwm\".\n     * omniOsc.modulationFrequency.value = 0.5;\n     */\n    get type() {\n        let prefix = \"\";\n        if ([\"am\", \"fm\", \"fat\"].some((p) => this._sourceType === p)) {\n            prefix = this._sourceType;\n        }\n        return (prefix + this._oscillator.type);\n    }\n    set type(type) {\n        if (type.substr(0, 2) === \"fm\") {\n            this._createNewOscillator(\"fm\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 2) === \"am\") {\n            this._createNewOscillator(\"am\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 3) === \"fat\") {\n            this._createNewOscillator(\"fat\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(3);\n        }\n        else if (type === \"pwm\") {\n            this._createNewOscillator(\"pwm\");\n            this._oscillator = this._oscillator;\n        }\n        else if (type === \"pulse\") {\n            this._createNewOscillator(\"pulse\");\n        }\n        else {\n            this._createNewOscillator(\"oscillator\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type;\n        }\n    }\n    /**\n     * The value is an empty array when the type is not \"custom\".\n     * This is not available on \"pwm\" and \"pulse\" oscillator types.\n     * @see {@link Oscillator.partials}\n     */\n    get partials() {\n        return this._oscillator.partials;\n    }\n    set partials(partials) {\n        if (!this._getOscType(this._oscillator, \"pulse\") &&\n            !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partials = partials;\n        }\n    }\n    get partialCount() {\n        return this._oscillator.partialCount;\n    }\n    set partialCount(partialCount) {\n        if (!this._getOscType(this._oscillator, \"pulse\") &&\n            !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partialCount = partialCount;\n        }\n    }\n    set(props) {\n        // make sure the type is set first\n        if (Reflect.has(props, \"type\") && props.type) {\n            this.type = props.type;\n        }\n        // then set the rest\n        super.set(props);\n        return this;\n    }\n    /**\n     * connect the oscillator to the frequency and detune signals\n     */\n    _createNewOscillator(oscType) {\n        if (oscType !== this._sourceType) {\n            this._sourceType = oscType;\n            const OscConstructor = OmniOscillatorSourceMap[oscType];\n            // short delay to avoid clicks on the change\n            const now = this.now();\n            if (this._oscillator) {\n                const oldOsc = this._oscillator;\n                oldOsc.stop(now);\n                // dispose the old one\n                this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n            }\n            this._oscillator = new OscConstructor({\n                context: this.context,\n            });\n            this.frequency.connect(this._oscillator.frequency);\n            this.detune.connect(this._oscillator.detune);\n            this._oscillator.connect(this.output);\n            this._oscillator.onstop = () => this.onstop(this);\n            if (this.state === \"started\") {\n                this._oscillator.start(now);\n            }\n        }\n    }\n    get phase() {\n        return this._oscillator.phase;\n    }\n    set phase(phase) {\n        this._oscillator.phase = phase;\n    }\n    /**\n     * The source type of the oscillator.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n     * console.log(omniOsc.sourceType); // 'fm'\n     */\n    get sourceType() {\n        return this._sourceType;\n    }\n    set sourceType(sType) {\n        // the basetype defaults to sine\n        let baseType = \"sine\";\n        if (this._oscillator.type !== \"pwm\" &&\n            this._oscillator.type !== \"pulse\") {\n            baseType = this._oscillator.type;\n        }\n        // set the type\n        if (sType === \"fm\") {\n            this.type = (\"fm\" + baseType);\n        }\n        else if (sType === \"am\") {\n            this.type = (\"am\" + baseType);\n        }\n        else if (sType === \"fat\") {\n            this.type = (\"fat\" + baseType);\n        }\n        else if (sType === \"oscillator\") {\n            this.type = baseType;\n        }\n        else if (sType === \"pulse\") {\n            this.type = \"pulse\";\n        }\n        else if (sType === \"pwm\") {\n            this.type = \"pwm\";\n        }\n    }\n    _getOscType(osc, sourceType) {\n        return osc instanceof OmniOscillatorSourceMap[sourceType];\n    }\n    /**\n     * The base type of the oscillator.\n     * @see {@link Oscillator.baseType}\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n     * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n     */\n    get baseType() {\n        return this._oscillator.baseType;\n    }\n    set baseType(baseType) {\n        if (!this._getOscType(this._oscillator, \"pulse\") &&\n            !this._getOscType(this._oscillator, \"pwm\") &&\n            baseType !== \"pulse\" &&\n            baseType !== \"pwm\") {\n            this._oscillator.baseType = baseType;\n        }\n    }\n    /**\n     * The width of the oscillator when sourceType === \"pulse\".\n     * @see {@link PWMOscillator}\n     */\n    get width() {\n        if (this._getOscType(this._oscillator, \"pulse\")) {\n            return this._oscillator.width;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The number of detuned oscillators when sourceType === \"fat\".\n     * @see {@link FatOscillator.count}\n     */\n    get count() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.count;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set count(count) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n            this._oscillator.count = count;\n        }\n    }\n    /**\n     * The detune spread between the oscillators when sourceType === \"fat\".\n     * @see {@link FatOscillator.count}\n     */\n    get spread() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.spread;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set spread(spread) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n            this._oscillator.spread = spread;\n        }\n    }\n    /**\n     * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n     * @see {@link AMOscillator} or {@link FMOscillator}\n     */\n    get modulationType() {\n        if (this._getOscType(this._oscillator, \"fm\") ||\n            this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.modulationType;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set modulationType(mType) {\n        if ((this._getOscType(this._oscillator, \"fm\") ||\n            this._getOscType(this._oscillator, \"am\")) &&\n            isString(mType)) {\n            this._oscillator.modulationType = mType;\n        }\n    }\n    /**\n     * The modulation index when the sourceType === \"fm\"\n     * @see {@link FMOscillator}.\n     */\n    get modulationIndex() {\n        if (this._getOscType(this._oscillator, \"fm\")) {\n            return this._oscillator.modulationIndex;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n     * @see {@link AMOscillator} or {@link FMOscillator}\n     */\n    get harmonicity() {\n        if (this._getOscType(this._oscillator, \"fm\") ||\n            this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.harmonicity;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n     * see {@link PWMOscillator}\n     * @min 0.1\n     * @max 5\n     */\n    get modulationFrequency() {\n        if (this._getOscType(this._oscillator, \"pwm\")) {\n            return this._oscillator.modulationFrequency;\n        }\n        else {\n            return undefined;\n        }\n    }\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this.detune.dispose();\n        this.frequency.dispose();\n        this._oscillator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=OmniOscillator.js.map","import { assertRange } from \"./Debug.js\";\n/**\n * Assert that the number is in the given range.\n */\nexport function range(min, max = Infinity) {\n    const valueMap = new WeakMap();\n    return function (target, propertyKey) {\n        Reflect.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                return valueMap.get(this);\n            },\n            set: function (newValue) {\n                assertRange(newValue, min, max);\n                valueMap.set(this, newValue);\n            },\n        });\n    };\n}\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\nexport function timeRange(min, max = Infinity) {\n    const valueMap = new WeakMap();\n    return function (target, propertyKey) {\n        Reflect.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                return valueMap.get(this);\n            },\n            set: function (newValue) {\n                assertRange(this.toSeconds(newValue), min, max);\n                valueMap.set(this, newValue);\n            },\n        });\n    };\n}\n//# sourceMappingURL=Decorator.js.map","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { isUndef } from \"../../core/util/TypeCheck.js\";\nimport { Source } from \"../Source.js\";\nimport { ToneBufferSource } from \"./ToneBufferSource.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\nimport { timeRange } from \"../../core/util/Decorator.js\";\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source {\n    constructor() {\n        const options = optionsFromArguments(Player.getDefaults(), arguments, [\n            \"url\",\n            \"onload\",\n        ]);\n        super(options);\n        this.name = \"Player\";\n        /**\n         * All of the active buffer source nodes\n         */\n        this._activeSources = new Set();\n        this._buffer = new ToneAudioBuffer({\n            onload: this._onload.bind(this, options.onload),\n            onerror: options.onerror,\n            reverse: options.reverse,\n            url: options.url,\n        });\n        this.autostart = options.autostart;\n        this._loop = options.loop;\n        this._loopStart = options.loopStart;\n        this._loopEnd = options.loopEnd;\n        this._playbackRate = options.playbackRate;\n        this.fadeIn = options.fadeIn;\n        this.fadeOut = options.fadeOut;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            autostart: false,\n            fadeIn: 0,\n            fadeOut: 0,\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            onload: noOp,\n            onerror: noOp,\n            playbackRate: 1,\n            reverse: false,\n        });\n    }\n    /**\n     * Load the audio file as an audio buffer.\n     * Decodes the audio asynchronously and invokes\n     * the callback once the audio buffer loads.\n     * Note: this does not need to be called if a url\n     * was passed in to the constructor. Only use this\n     * if you want to manually load a new url.\n     * @param url The url of the buffer to load. Filetype support depends on the browser.\n     */\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._buffer.load(url);\n            this._onload();\n            return this;\n        });\n    }\n    /**\n     * Internal callback when the buffer is loaded.\n     */\n    _onload(callback = noOp) {\n        callback();\n        if (this.autostart) {\n            this.start();\n        }\n    }\n    /**\n     * Internal callback when the buffer is done playing.\n     */\n    _onSourceEnd(source) {\n        // invoke the onstop function\n        this.onstop(this);\n        // delete the source from the active sources\n        this._activeSources.delete(source);\n        if (this._activeSources.size === 0 &&\n            !this._synced &&\n            this._state.getValueAtTime(this.now()) === \"started\") {\n            // remove the 'implicitEnd' event and replace with an explicit end\n            this._state.cancel(this.now());\n            this._state.setStateAtTime(\"stopped\", this.now());\n        }\n    }\n    /**\n     * Play the buffer at the given startTime. Optionally add an offset\n     * and/or duration which will play the buffer from a position\n     * within the buffer for the given duration.\n     *\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n     */\n    start(time, offset, duration) {\n        super.start(time, offset, duration);\n        return this;\n    }\n    /**\n     * Internal start method\n     */\n    _start(startTime, offset, duration) {\n        // if it's a loop the default offset is the loopStart point\n        if (this._loop) {\n            offset = defaultArg(offset, this._loopStart);\n        }\n        else {\n            // otherwise the default offset is 0\n            offset = defaultArg(offset, 0);\n        }\n        // compute the values in seconds\n        const computedOffset = this.toSeconds(offset);\n        // compute the duration which is either the passed in duration of the buffer.duration - offset\n        const origDuration = duration;\n        duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n        let computedDuration = this.toSeconds(duration);\n        // scale it by the playback rate\n        computedDuration = computedDuration / this._playbackRate;\n        // get the start time\n        startTime = this.toSeconds(startTime);\n        // make the source\n        const source = new ToneBufferSource({\n            url: this._buffer,\n            context: this.context,\n            fadeIn: this.fadeIn,\n            fadeOut: this.fadeOut,\n            loop: this._loop,\n            loopEnd: this._loopEnd,\n            loopStart: this._loopStart,\n            onended: this._onSourceEnd.bind(this),\n            playbackRate: this._playbackRate,\n        }).connect(this.output);\n        // set the looping properties\n        if (!this._loop && !this._synced) {\n            // cancel the previous stop\n            this._state.cancel(startTime + computedDuration);\n            // if it's not looping, set the state change at the end of the sample\n            this._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n                implicitEnd: true,\n            });\n        }\n        // add it to the array of active sources\n        this._activeSources.add(source);\n        // start it\n        if (this._loop && isUndef(origDuration)) {\n            source.start(startTime, computedOffset);\n        }\n        else {\n            // subtract the fade out time\n            source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n        }\n    }\n    /**\n     * Stop playback.\n     */\n    _stop(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeSources.forEach((source) => source.stop(computedTime));\n    }\n    /**\n     * Stop and then restart the player from the beginning (or offset)\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given,\n     * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n     */\n    restart(time, offset, duration) {\n        super.restart(time, offset, duration);\n        return this;\n    }\n    _restart(time, offset, duration) {\n        var _a;\n        (_a = [...this._activeSources].pop()) === null || _a === void 0 ? void 0 : _a.stop(time); // explicitly stop only the most recently created source, to avoid edge case when > 1 source exists and _stop() erroneously sets all stop times past original end offset\n        this._start(time, offset, duration);\n    }\n    /**\n     * Seek to a specific time in the player's buffer. If the\n     * source is no longer playing at that time, it will stop.\n     * @param offset The time to seek to.\n     * @param when The time for the seek event to occur.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n     * \tplayer.start();\n     * \t// seek to the offset in 1 second from now\n     * \tplayer.seek(0.4, \"+1\");\n     * }).toDestination();\n     */\n    seek(offset, when) {\n        const computedTime = this.toSeconds(when);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            const computedOffset = this.toSeconds(offset);\n            // if it's currently playing, stop it\n            this._stop(computedTime);\n            // restart it at the given time\n            this._start(computedTime, computedOffset);\n        }\n        return this;\n    }\n    /**\n     * Set the loop start and end. Will only loop if loop is set to true.\n     * @param loopStart The loop start time\n     * @param loopEnd The loop end time\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n     * // loop between the given points\n     * player.setLoopPoints(0.2, 0.3);\n     * player.loop = true;\n     * player.autostart = true;\n     */\n    setLoopPoints(loopStart, loopEnd) {\n        this.loopStart = loopStart;\n        this.loopEnd = loopEnd;\n        return this;\n    }\n    /**\n     * If loop is true, the loop will start at this position.\n     */\n    get loopStart() {\n        return this._loopStart;\n    }\n    set loopStart(loopStart) {\n        this._loopStart = loopStart;\n        if (this.buffer.loaded) {\n            assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n        }\n        // get the current source\n        this._activeSources.forEach((source) => {\n            source.loopStart = loopStart;\n        });\n    }\n    /**\n     * If loop is true, the loop will end at this position.\n     */\n    get loopEnd() {\n        return this._loopEnd;\n    }\n    set loopEnd(loopEnd) {\n        this._loopEnd = loopEnd;\n        if (this.buffer.loaded) {\n            assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n        }\n        // get the current source\n        this._activeSources.forEach((source) => {\n            source.loopEnd = loopEnd;\n        });\n    }\n    /**\n     * The audio buffer belonging to the player.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    set buffer(buffer) {\n        this._buffer.set(buffer);\n    }\n    /**\n     * If the buffer should loop once it's over.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n     * player.loop = true;\n     * player.autostart = true;\n     */\n    get loop() {\n        return this._loop;\n    }\n    set loop(loop) {\n        // if no change, do nothing\n        if (this._loop === loop) {\n            return;\n        }\n        this._loop = loop;\n        // set the loop of all of the sources\n        this._activeSources.forEach((source) => {\n            source.loop = loop;\n        });\n        if (loop) {\n            // remove the next stopEvent\n            const stopEvent = this._state.getNextState(\"stopped\", this.now());\n            if (stopEvent) {\n                this._state.cancel(stopEvent.time);\n            }\n        }\n    }\n    /**\n     * Normal speed is 1. The pitch will change with the playback rate.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n     * // play at 1/4 speed\n     * player.playbackRate = 0.25;\n     * // play as soon as the buffer is loaded\n     * player.autostart = true;\n     */\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(rate) {\n        this._playbackRate = rate;\n        const now = this.now();\n        // cancel the stop event since it's at a different time now\n        const stopEvent = this._state.getNextState(\"stopped\", now);\n        if (stopEvent && stopEvent.implicitEnd) {\n            this._state.cancel(stopEvent.time);\n            this._activeSources.forEach((source) => source.cancelStop());\n        }\n        // set all the sources\n        this._activeSources.forEach((source) => {\n            source.playbackRate.setValueAtTime(rate, now);\n        });\n    }\n    /**\n     * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so\n     * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n     * player.autostart = true;\n     * player.reverse = true;\n     */\n    get reverse() {\n        return this._buffer.reverse;\n    }\n    set reverse(rev) {\n        this._buffer.reverse = rev;\n    }\n    /**\n     * If the buffer is loaded\n     */\n    get loaded() {\n        return this._buffer.loaded;\n    }\n    dispose() {\n        super.dispose();\n        // disconnect all of the players\n        this._activeSources.forEach((source) => source.dispose());\n        this._activeSources.clear();\n        this._buffer.dispose();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Player.prototype, \"fadeIn\", void 0);\n__decorate([\n    timeRange(0)\n], Player.prototype, \"fadeOut\", void 0);\n//# sourceMappingURL=Player.js.map","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode, } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck.js\";\nimport { connectSignal, Signal } from \"../../signal/Signal.js\";\nimport { OfflineContext } from \"../../core/context/OfflineContext.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { range, timeRange } from \"../../core/util/Decorator.js\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n        super(options);\n        this.name = \"Envelope\";\n        /**\n         * the signal which is output.\n         */\n        this._sig = new Signal({\n            context: this.context,\n            value: 0,\n        });\n        /**\n         * The output signal of the envelope\n         */\n        this.output = this._sig;\n        /**\n         * Envelope has no input\n         */\n        this.input = undefined;\n        this.attack = options.attack;\n        this.decay = options.decay;\n        this.sustain = options.sustain;\n        this.release = options.release;\n        this.attackCurve = options.attackCurve;\n        this.releaseCurve = options.releaseCurve;\n        this.decayCurve = options.decayCurve;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            attack: 0.01,\n            attackCurve: \"linear\",\n            decay: 0.1,\n            decayCurve: \"exponential\",\n            release: 1,\n            releaseCurve: \"exponential\",\n            sustain: 0.5,\n        });\n    }\n    /**\n     * Read the current value of the envelope. Useful for\n     * synchronizing visual output to the envelope.\n     */\n    get value() {\n        return this.getValueAtTime(this.now());\n    }\n    /**\n     * Get the curve\n     * @param  curve\n     * @param  direction  In/Out\n     * @return The curve name\n     */\n    _getCurve(curve, direction) {\n        if (isString(curve)) {\n            return curve;\n        }\n        else {\n            // look up the name in the curves array\n            let curveName;\n            for (curveName in EnvelopeCurves) {\n                if (EnvelopeCurves[curveName][direction] === curve) {\n                    return curveName;\n                }\n            }\n            // return the custom curve\n            return curve;\n        }\n    }\n    /**\n     * Assign a the curve to the given name using the direction\n     * @param  name\n     * @param  direction In/Out\n     * @param  curve\n     */\n    _setCurve(name, direction, curve) {\n        // check if it's a valid type\n        if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n            const curveDef = EnvelopeCurves[curve];\n            if (isObject(curveDef)) {\n                if (name !== \"_decayCurve\") {\n                    this[name] = curveDef[direction];\n                }\n            }\n            else {\n                this[name] = curveDef;\n            }\n        }\n        else if (isArray(curve) && name !== \"_decayCurve\") {\n            this[name] = curve;\n        }\n        else {\n            throw new Error(\"Envelope: invalid curve: \" + curve);\n        }\n    }\n    /**\n     * The shape of the attack.\n     * Can be any of these strings:\n     * * \"linear\"\n     * * \"exponential\"\n     * * \"sine\"\n     * * \"cosine\"\n     * * \"bounce\"\n     * * \"ripple\"\n     * * \"step\"\n     *\n     * Can also be an array which describes the curve. Values\n     * in the array are evenly subdivided and linearly\n     * interpolated over the duration of the attack.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope(0.4).toDestination();\n     * \tenv.attackCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n    get attackCurve() {\n        return this._getCurve(this._attackCurve, \"In\");\n    }\n    set attackCurve(curve) {\n        this._setCurve(\"_attackCurve\", \"In\", curve);\n    }\n    /**\n     * The shape of the release. See the attack curve types.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\trelease: 0.8\n     * \t}).toDestination();\n     * \tenv.triggerAttack();\n     * \t// release curve could also be defined by an array\n     * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n     * \tenv.triggerRelease(0.2);\n     * }, 1, 1);\n     */\n    get releaseCurve() {\n        return this._getCurve(this._releaseCurve, \"Out\");\n    }\n    set releaseCurve(curve) {\n        this._setCurve(\"_releaseCurve\", \"Out\", curve);\n    }\n    /**\n     * The shape of the decay either \"linear\" or \"exponential\"\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\tsustain: 0.1,\n     * \t\tdecay: 0.5\n     * \t}).toDestination();\n     * \tenv.decayCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n    get decayCurve() {\n        return this._getCurve(this._decayCurve, \"Out\");\n    }\n    set decayCurve(curve) {\n        this._setCurve(\"_decayCurve\", \"Out\", curve);\n    }\n    /**\n     * Trigger the attack/decay portion of the ADSR envelope.\n     * @param  time When the attack should start.\n     * @param velocity The velocity of the envelope scales the vales.\n     *                             number between 0-1\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n     * env.triggerAttack(\"+0.5\", 0.2);\n     */\n    triggerAttack(time, velocity = 1) {\n        this.log(\"triggerAttack\", time, velocity);\n        time = this.toSeconds(time);\n        const originalAttack = this.toSeconds(this.attack);\n        let attack = originalAttack;\n        const decay = this.toSeconds(this.decay);\n        // check if it's not a complete attack\n        const currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            // subtract the current value from the attack time\n            const attackRate = 1 / attack;\n            const remainingDistance = 1 - currentValue;\n            // the attack is now the remaining time\n            attack = remainingDistance / attackRate;\n        }\n        // attack\n        if (attack < this.sampleTime) {\n            this._sig.cancelScheduledValues(time);\n            // case where the attack time is 0 should set instantly\n            this._sig.setValueAtTime(velocity, time);\n        }\n        else if (this._attackCurve === \"linear\") {\n            this._sig.linearRampTo(velocity, attack, time);\n        }\n        else if (this._attackCurve === \"exponential\") {\n            this._sig.targetRampTo(velocity, attack, time);\n        }\n        else {\n            this._sig.cancelAndHoldAtTime(time);\n            let curve = this._attackCurve;\n            // find the starting position in the curve\n            for (let i = 1; i < curve.length; i++) {\n                // the starting index is between the two values\n                if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n                    curve = this._attackCurve.slice(i);\n                    // the first index is the current value\n                    curve[0] = currentValue;\n                    break;\n                }\n            }\n            this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n        }\n        // decay\n        if (decay && this.sustain < 1) {\n            const decayValue = velocity * this.sustain;\n            const decayStart = time + attack;\n            this.log(\"decay\", decayStart);\n            if (this._decayCurve === \"linear\") {\n                this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n            }\n            else {\n                this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n            }\n        }\n        return this;\n    }\n    /**\n     * Triggers the release of the envelope.\n     * @param  time When the release portion of the envelope should start.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator({\n     * \ttype: \"sawtooth\"\n     * }).connect(env).start();\n     * env.triggerAttack();\n     * // trigger the release half a second after the attack\n     * env.triggerRelease(\"+0.5\");\n     */\n    triggerRelease(time) {\n        this.log(\"triggerRelease\", time);\n        time = this.toSeconds(time);\n        const currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            const release = this.toSeconds(this.release);\n            if (release < this.sampleTime) {\n                this._sig.setValueAtTime(0, time);\n            }\n            else if (this._releaseCurve === \"linear\") {\n                this._sig.linearRampTo(0, release, time);\n            }\n            else if (this._releaseCurve === \"exponential\") {\n                this._sig.targetRampTo(0, release, time);\n            }\n            else {\n                assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n                this._sig.cancelAndHoldAtTime(time);\n                this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n            }\n        }\n        return this;\n    }\n    /**\n     * Get the scheduled value at the given time. This will\n     * return the unconverted (raw) value.\n     * @example\n     * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n     * env.triggerAttackRelease(2);\n     * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n     */\n    getValueAtTime(time) {\n        return this._sig.getValueAtTime(time);\n    }\n    /**\n     * triggerAttackRelease is shorthand for triggerAttack, then waiting\n     * some duration, then triggerRelease.\n     * @param duration The duration of the sustain.\n     * @param time When the attack should be triggered.\n     * @param velocity The velocity of the envelope.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the release 0.5 seconds after the attack\n     * env.triggerAttackRelease(0.5);\n     */\n    triggerAttackRelease(duration, time, velocity = 1) {\n        time = this.toSeconds(time);\n        this.triggerAttack(time, velocity);\n        this.triggerRelease(time + this.toSeconds(duration));\n        return this;\n    }\n    /**\n     * Cancels all scheduled envelope changes after the given time.\n     */\n    cancel(after) {\n        this._sig.cancelScheduledValues(this.toSeconds(after));\n        return this;\n    }\n    /**\n     * Connect the envelope to a destination node.\n     */\n    connect(destination, outputNumber = 0, inputNumber = 0) {\n        connectSignal(this, destination, outputNumber, inputNumber);\n        return this;\n    }\n    /**\n     * Render the envelope curve to an array of the given length.\n     * Good for visualizing the envelope curve. Rescales the duration of the\n     * envelope to fit the length.\n     */\n    asArray() {\n        return __awaiter(this, arguments, void 0, function* (length = 1024) {\n            const duration = length / this.context.sampleRate;\n            const context = new OfflineContext(1, duration, this.context.sampleRate);\n            // normalize the ADSR for the given duration with 20% sustain time\n            const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n            const envelopeDuration = attackPortion + this.toSeconds(this.release);\n            const sustainTime = envelopeDuration * 0.1;\n            const totalDuration = envelopeDuration + sustainTime;\n            // @ts-ignore\n            const clone = new this.constructor(Object.assign(this.get(), {\n                attack: (duration * this.toSeconds(this.attack)) / totalDuration,\n                decay: (duration * this.toSeconds(this.decay)) / totalDuration,\n                release: (duration * this.toSeconds(this.release)) / totalDuration,\n                context,\n            }));\n            clone._sig.toDestination();\n            clone.triggerAttackRelease((duration * (attackPortion + sustainTime)) / totalDuration, 0);\n            const buffer = yield context.render();\n            return buffer.getChannelData(0);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._sig.dispose();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"attack\", void 0);\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"decay\", void 0);\n__decorate([\n    range(0, 1)\n], Envelope.prototype, \"sustain\", void 0);\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves = (() => {\n    const curveLen = 128;\n    let i;\n    let k;\n    // cosine curve\n    const cosineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        cosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n    }\n    // ripple curve\n    const rippleCurve = [];\n    const rippleCurveFreq = 6.4;\n    for (i = 0; i < curveLen - 1; i++) {\n        k = i / (curveLen - 1);\n        const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n        rippleCurve[i] = sineWave / 10 + k * 0.83;\n    }\n    rippleCurve[curveLen - 1] = 1;\n    // stairs curve\n    const stairsCurve = [];\n    const steps = 5;\n    for (i = 0; i < curveLen; i++) {\n        stairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n    }\n    // in-out easing curve\n    const sineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n    // a bounce curve\n    const bounceCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        const freq = Math.pow(k, 3) * 4 + 0.2;\n        const val = Math.cos(freq * Math.PI * 2 * k);\n        bounceCurve[i] = Math.abs(val * (1 - k));\n    }\n    /**\n     * Invert a value curve to make it work for the release\n     */\n    function invertCurve(curve) {\n        const out = new Array(curve.length);\n        for (let j = 0; j < curve.length; j++) {\n            out[j] = 1 - curve[j];\n        }\n        return out;\n    }\n    /**\n     * reverse the curve\n     */\n    function reverseCurve(curve) {\n        return curve.slice(0).reverse();\n    }\n    /**\n     * attack and release curve arrays\n     */\n    return {\n        bounce: {\n            In: invertCurve(bounceCurve),\n            Out: bounceCurve,\n        },\n        cosine: {\n            In: cosineCurve,\n            Out: reverseCurve(cosineCurve),\n        },\n        exponential: \"exponential\",\n        linear: \"linear\",\n        ripple: {\n            In: rippleCurve,\n            Out: invertCurve(rippleCurve),\n        },\n        sine: {\n            In: sineCurve,\n            Out: invertCurve(sineCurve),\n        },\n        step: {\n            In: stairsCurve,\n            Out: invertCurve(stairsCurve),\n        },\n    };\n})();\n//# sourceMappingURL=Envelope.js.map","import { Volume } from \"../component/channel/Volume.js\";\nimport { ToneAudioNode, } from \"../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n/**\n * Base-class for all instruments\n */\nexport class Instrument extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Instrument.getDefaults(), arguments);\n        super(options);\n        /**\n         * Keep track of all events scheduled to the transport\n         * when the instrument is 'synced'\n         */\n        this._scheduledEvents = [];\n        /**\n         * If the instrument is currently synced\n         */\n        this._synced = false;\n        this._original_triggerAttack = this.triggerAttack;\n        this._original_triggerRelease = this.triggerRelease;\n        /**\n         * The release which is scheduled to the timeline.\n         */\n        this._syncedRelease = (time) => this._original_triggerRelease(time);\n        this._volume = this.output = new Volume({\n            context: this.context,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            volume: 0,\n        });\n    }\n    /**\n     * Sync the instrument to the Transport. All subsequent calls of\n     * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.\n     * @example\n     * const fmSynth = new Tone.FMSynth().toDestination();\n     * fmSynth.volume.value = -6;\n     * fmSynth.sync();\n     * // schedule 3 notes when the transport first starts\n     * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n     * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n     * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n     * // start the transport to hear the notes\n     * Tone.Transport.start();\n     */\n    sync() {\n        if (this._syncState()) {\n            this._syncMethod(\"triggerAttack\", 1);\n            this._syncMethod(\"triggerRelease\", 0);\n            this.context.transport.on(\"stop\", this._syncedRelease);\n            this.context.transport.on(\"pause\", this._syncedRelease);\n            this.context.transport.on(\"loopEnd\", this._syncedRelease);\n        }\n        return this;\n    }\n    /**\n     * set _sync\n     */\n    _syncState() {\n        let changed = false;\n        if (!this._synced) {\n            this._synced = true;\n            changed = true;\n        }\n        return changed;\n    }\n    /**\n     * Wrap the given method so that it can be synchronized\n     * @param method Which method to wrap and sync\n     * @param  timePosition What position the time argument appears in\n     */\n    _syncMethod(method, timePosition) {\n        const originalMethod = (this[\"_original_\" + method] = this[method]);\n        this[method] = (...args) => {\n            const time = args[timePosition];\n            const id = this.context.transport.schedule((t) => {\n                args[timePosition] = t;\n                originalMethod.apply(this, args);\n            }, time);\n            this._scheduledEvents.push(id);\n        };\n    }\n    /**\n     * Unsync the instrument from the Transport\n     */\n    unsync() {\n        this._scheduledEvents.forEach((id) => this.context.transport.clear(id));\n        this._scheduledEvents = [];\n        if (this._synced) {\n            this._synced = false;\n            this.triggerAttack = this._original_triggerAttack;\n            this.triggerRelease = this._original_triggerRelease;\n            this.context.transport.off(\"stop\", this._syncedRelease);\n            this.context.transport.off(\"pause\", this._syncedRelease);\n            this.context.transport.off(\"loopEnd\", this._syncedRelease);\n        }\n        return this;\n    }\n    /**\n     * Trigger the attack and then the release after the duration.\n     * @param  note     The note to trigger.\n     * @param  duration How long the note should be held for before\n     *                         triggering the release. This value must be greater than 0.\n     * @param time  When the note should be triggered.\n     * @param  velocity The velocity the note should be triggered at.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger \"C4\" for the duration of an 8th note\n     * synth.triggerAttackRelease(\"C4\", \"8n\");\n     */\n    triggerAttackRelease(note, duration, time, velocity) {\n        const computedTime = this.toSeconds(time);\n        const computedDuration = this.toSeconds(duration);\n        this.triggerAttack(note, computedTime, velocity);\n        this.triggerRelease(computedTime + computedDuration);\n        return this;\n    }\n    /**\n     * clean up\n     * @returns {Instrument} this\n     */\n    dispose() {\n        super.dispose();\n        this._volume.dispose();\n        this.unsync();\n        this._scheduledEvents = [];\n        return this;\n    }\n}\n//# sourceMappingURL=Instrument.js.map","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { Instrument } from \"../instrument/Instrument.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport class Monophonic extends Instrument {\n    constructor() {\n        const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n        super(options);\n        this.portamento = options.portamento;\n        this.onsilence = options.onsilence;\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            detune: 0,\n            onsilence: noOp,\n            portamento: 0,\n        });\n    }\n    /**\n     * Trigger the attack of the note optionally with a given velocity.\n     * @param  note The note to trigger.\n     * @param  time When the note should start.\n     * @param  velocity The velocity determines how \"loud\" the note will be.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger the note a half second from now at half velocity\n     * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n     */\n    triggerAttack(note, time, velocity = 1) {\n        this.log(\"triggerAttack\", note, time, velocity);\n        const seconds = this.toSeconds(time);\n        this._triggerEnvelopeAttack(seconds, velocity);\n        this.setNote(note, seconds);\n        return this;\n    }\n    /**\n     * Trigger the release portion of the envelope.\n     * @param  time If no time is given, the release happens immediately.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // trigger the release a second from now\n     * synth.triggerRelease(\"+1\");\n     */\n    triggerRelease(time) {\n        this.log(\"triggerRelease\", time);\n        const seconds = this.toSeconds(time);\n        this._triggerEnvelopeRelease(seconds);\n        return this;\n    }\n    /**\n     * Set the note at the given time. If no time is given, the note\n     * will set immediately.\n     * @param note The note to change to.\n     * @param  time The time when the note should be set.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // change to F#6 in one quarter note from now.\n     * synth.setNote(\"F#6\", \"+4n\");\n     */\n    setNote(note, time) {\n        const computedTime = this.toSeconds(time);\n        const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n        if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n            const portTime = this.toSeconds(this.portamento);\n            this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n        }\n        else {\n            this.frequency.setValueAtTime(computedFrequency, computedTime);\n        }\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Monophonic.prototype, \"portamento\", void 0);\n//# sourceMappingURL=Monophonic.js.map","import { Gain } from \"../../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Envelope } from \"./Envelope.js\";\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst ampEnv = new Tone.AmplitudeEnvelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 1.0,\n * \t\trelease: 0.8\n * \t}).toDestination();\n * \t// create an oscillator and connect it\n * \tconst osc = new Tone.Oscillator().connect(ampEnv).start();\n * \t// trigger the envelopes attack and release \"8t\" apart\n * \tampEnv.triggerAttackRelease(\"8t\");\n * }, 1.5, 1);\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n    constructor() {\n        super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\n            \"attack\",\n            \"decay\",\n            \"sustain\",\n            \"release\",\n        ]));\n        this.name = \"AmplitudeEnvelope\";\n        this._gainNode = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        this.output = this._gainNode;\n        this.input = this._gainNode;\n        this._sig.connect(this._gainNode.gain);\n        this.output = this._gainNode;\n        this.input = this._gainNode;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._gainNode.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AmplitudeEnvelope.js.map","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope.js\";\nimport { Envelope } from \"../component/envelope/Envelope.js\";\nimport { ToneAudioNode, } from \"../core/context/ToneAudioNode.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator.js\";\nimport { Source } from \"../source/Source.js\";\nimport { Monophonic } from \"./Monophonic.js\";\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth extends Monophonic {\n    constructor() {\n        const options = optionsFromArguments(Synth.getDefaults(), arguments);\n        super(options);\n        this.name = \"Synth\";\n        this.oscillator = new OmniOscillator(Object.assign({\n            context: this.context,\n            detune: options.detune,\n            onstop: () => this.onsilence(this),\n        }, options.oscillator));\n        this.frequency = this.oscillator.frequency;\n        this.detune = this.oscillator.detune;\n        this.envelope = new AmplitudeEnvelope(Object.assign({\n            context: this.context,\n        }, options.envelope));\n        // connect the oscillators to the output\n        this.oscillator.chain(this.envelope, this.output);\n        readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Monophonic.getDefaults(), {\n            envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n                attack: 0.005,\n                decay: 0.1,\n                release: 1,\n                sustain: 0.3,\n            }),\n            oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [\n                ...Object.keys(Source.getDefaults()),\n                \"frequency\",\n                \"detune\",\n            ]), {\n                type: \"triangle\",\n            }),\n        });\n    }\n    /**\n     * start the attack portion of the envelope\n     * @param time the time the attack should start\n     * @param velocity the velocity of the note (0-1)\n     */\n    _triggerEnvelopeAttack(time, velocity) {\n        // the envelopes\n        this.envelope.triggerAttack(time, velocity);\n        this.oscillator.start(time);\n        // if there is no release portion, stop the oscillator\n        if (this.envelope.sustain === 0) {\n            const computedAttack = this.toSeconds(this.envelope.attack);\n            const computedDecay = this.toSeconds(this.envelope.decay);\n            this.oscillator.stop(time + computedAttack + computedDecay);\n        }\n    }\n    /**\n     * start the release portion of the envelope\n     * @param time the time the release should start\n     */\n    _triggerEnvelopeRelease(time) {\n        this.envelope.triggerRelease(time);\n        this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n    }\n    getLevelAtTime(time) {\n        time = this.toSeconds(time);\n        return this.envelope.getValueAtTime(time);\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this.oscillator.dispose();\n        this.envelope.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Synth.js.map","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Monophonic } from \"./Monophonic.js\";\nimport { Synth } from \"./Synth.js\";\nimport { range, timeRange } from \"../core/util/Decorator.js\";\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth {\n    constructor() {\n        const options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n        super(options);\n        this.name = \"MembraneSynth\";\n        /**\n         * Portamento is ignored in this synth. use pitch decay instead.\n         */\n        this.portamento = 0;\n        this.pitchDecay = options.pitchDecay;\n        this.octaves = options.octaves;\n        readOnly(this, [\"oscillator\", \"envelope\"]);\n    }\n    static getDefaults() {\n        return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n            envelope: {\n                attack: 0.001,\n                attackCurve: \"exponential\",\n                decay: 0.4,\n                release: 1.4,\n                sustain: 0.01,\n            },\n            octaves: 10,\n            oscillator: {\n                type: \"sine\",\n            },\n            pitchDecay: 0.05,\n        });\n    }\n    setNote(note, time) {\n        const seconds = this.toSeconds(time);\n        const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n        const maxNote = hertz * this.octaves;\n        this.oscillator.frequency.setValueAtTime(maxNote, seconds);\n        this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        return this;\n    }\n}\n__decorate([\n    range(0)\n], MembraneSynth.prototype, \"octaves\", void 0);\n__decorate([\n    timeRange(0)\n], MembraneSynth.prototype, \"pitchDecay\", void 0);\n//# sourceMappingURL=MembraneSynth.js.map","/**\n * All of the classes or functions which are loaded into the AudioWorkletGlobalScope\n */\nconst workletContext = new Set();\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\nexport function addToWorklet(classOrFunction) {\n    workletContext.add(classOrFunction);\n}\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\nexport function registerProcessor(name, classDesc) {\n    const processor = /* javascript */ `registerProcessor(\"${name}\", ${classDesc})`;\n    workletContext.add(processor);\n}\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\nexport function getWorkletGlobalScope() {\n    return Array.from(workletContext).join(\"\\n\");\n}\n//# sourceMappingURL=WorkletGlobalScope.js.map","import { addToWorklet } from \"./WorkletGlobalScope.js\";\nconst toneAudioWorkletProcessor = /* javascript */ `\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it's disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === \"dispose\") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n`;\naddToWorklet(toneAudioWorkletProcessor);\n//# sourceMappingURL=ToneAudioWorkletProcessor.worklet.js.map","import \"./ToneAudioWorkletProcessor.worklet.js\";\nimport { addToWorklet } from \"./WorkletGlobalScope.js\";\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\naddToWorklet(singleIOProcess);\n//# sourceMappingURL=SingleIOProcessor.worklet.js.map","import { addToWorklet } from \"./WorkletGlobalScope.js\";\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\naddToWorklet(delayLine);\n//# sourceMappingURL=DelayLine.worklet.js.map","import \"../../core/worklet/SingleIOProcessor.worklet.js\";\nimport \"../../core/worklet/DelayLine.worklet.js\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope.js\";\nexport const workletName = \"feedback-comb-filter\";\nconst feedbackCombFilter = /* javascript */ `\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"delayTime\",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}, {\n\t\t\t\tname: \"feedback\",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n`;\nregisterProcessor(workletName, feedbackCombFilter);\n//# sourceMappingURL=FeedbackCombFilter.worklet.js.map","import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers.js\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions.js\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument } from \"../instrument/Instrument.js\";\nimport { ToneBufferSource, } from \"../source/buffer/ToneBufferSource.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\nimport { assert } from \"../core/util/Debug.js\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use {@link Player}.\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument {\n    constructor() {\n        const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n        super(options);\n        this.name = \"Sampler\";\n        /**\n         * The object of all currently playing BufferSources\n         */\n        this._activeSources = new Map();\n        const urlMap = {};\n        Object.keys(options.urls).forEach((note) => {\n            const noteNumber = parseInt(note, 10);\n            assert(isNote(note) || (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n            if (isNote(note)) {\n                // convert the note name to MIDI\n                const mid = new FrequencyClass(this.context, note).toMidi();\n                urlMap[mid] = options.urls[note];\n            }\n            else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n                // otherwise if it's numbers assume it's midi\n                urlMap[noteNumber] = options.urls[noteNumber];\n            }\n        });\n        this._buffers = new ToneAudioBuffers({\n            urls: urlMap,\n            onload: options.onload,\n            baseUrl: options.baseUrl,\n            onerror: options.onerror,\n        });\n        this.attack = options.attack;\n        this.release = options.release;\n        this.curve = options.curve;\n        // invoke the callback if it's already loaded\n        if (this._buffers.loaded) {\n            // invoke onload deferred\n            Promise.resolve().then(options.onload);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            attack: 0,\n            baseUrl: \"\",\n            curve: \"exponential\",\n            onload: noOp,\n            onerror: noOp,\n            release: 0.1,\n            urls: {},\n        });\n    }\n    /**\n     * Returns the difference in steps between the given midi note at the closets sample.\n     */\n    _findClosest(midi) {\n        // searches within 8 octaves of the given midi note\n        const MAX_INTERVAL = 96;\n        let interval = 0;\n        while (interval < MAX_INTERVAL) {\n            // check above and below\n            if (this._buffers.has(midi + interval)) {\n                return -interval;\n            }\n            else if (this._buffers.has(midi - interval)) {\n                return interval;\n            }\n            interval++;\n        }\n        throw new Error(`No available buffers for note: ${midi}`);\n    }\n    /**\n     * @param  notes\tThe note to play, or an array of notes.\n     * @param  time     When to play the note\n     * @param  velocity The velocity to play the sample back.\n     */\n    triggerAttack(notes, time, velocity = 1) {\n        this.log(\"triggerAttack\", notes, time, velocity);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach((note) => {\n            const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n            const midi = Math.round(midiFloat);\n            const remainder = midiFloat - midi;\n            // find the closest note pitch\n            const difference = this._findClosest(midi);\n            const closestNote = midi - difference;\n            const buffer = this._buffers.get(closestNote);\n            const playbackRate = intervalToFrequencyRatio(difference + remainder);\n            // play that note\n            const source = new ToneBufferSource({\n                url: buffer,\n                context: this.context,\n                curve: this.curve,\n                fadeIn: this.attack,\n                fadeOut: this.release,\n                playbackRate,\n            }).connect(this.output);\n            source.start(time, 0, buffer.duration / playbackRate, velocity);\n            // add it to the active sources\n            if (!isArray(this._activeSources.get(midi))) {\n                this._activeSources.set(midi, []);\n            }\n            this._activeSources.get(midi).push(source);\n            // remove it when it's done\n            source.onended = () => {\n                if (this._activeSources && this._activeSources.has(midi)) {\n                    const sources = this._activeSources.get(midi);\n                    const index = sources.indexOf(source);\n                    if (index !== -1) {\n                        sources.splice(index, 1);\n                    }\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * @param  notes\tThe note to release, or an array of notes.\n     * @param  time     \tWhen to release the note.\n     */\n    triggerRelease(notes, time) {\n        this.log(\"triggerRelease\", notes, time);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach((note) => {\n            const midi = new FrequencyClass(this.context, note).toMidi();\n            // find the note\n            if (this._activeSources.has(midi) &&\n                this._activeSources.get(midi).length) {\n                const sources = this._activeSources.get(midi);\n                time = this.toSeconds(time);\n                sources.forEach((source) => {\n                    source.stop(time);\n                });\n                this._activeSources.set(midi, []);\n            }\n        });\n        return this;\n    }\n    /**\n     * Release all currently active notes.\n     * @param  time     \tWhen to release the notes.\n     */\n    releaseAll(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeSources.forEach((sources) => {\n            while (sources.length) {\n                const source = sources.shift();\n                source.stop(computedTime);\n            }\n        });\n        return this;\n    }\n    sync() {\n        if (this._syncState()) {\n            this._syncMethod(\"triggerAttack\", 1);\n            this._syncMethod(\"triggerRelease\", 1);\n        }\n        return this;\n    }\n    /**\n     * Invoke the attack phase, then after the duration, invoke the release.\n     * @param  notes\tThe note to play and release, or an array of notes.\n     * @param  duration The time the note should be held\n     * @param  time     When to start the attack\n     * @param  velocity The velocity of the attack\n     */\n    triggerAttackRelease(notes, duration, time, velocity = 1) {\n        const computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"notes must be an array when duration is array\");\n            notes.forEach((note, index) => {\n                const d = duration[Math.min(index, duration.length - 1)];\n                this.triggerRelease(note, computedTime + this.toSeconds(d));\n            });\n        }\n        else {\n            this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n        }\n        return this;\n    }\n    /**\n     * Add a note to the sampler.\n     * @param  note      The buffer's pitch.\n     * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     */\n    add(note, url, callback) {\n        assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n        if (isNote(note)) {\n            // convert the note name to MIDI\n            const mid = new FrequencyClass(this.context, note).toMidi();\n            this._buffers.add(mid, url, callback);\n        }\n        else {\n            // otherwise if it's numbers assume it's midi\n            this._buffers.add(note, url, callback);\n        }\n        return this;\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n    get loaded() {\n        return this._buffers.loaded;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._buffers.dispose();\n        this._activeSources.forEach((sources) => {\n            sources.forEach((source) => source.dispose());\n        });\n        this._activeSources.clear();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Sampler.prototype, \"attack\", void 0);\n__decorate([\n    timeRange(0)\n], Sampler.prototype, \"release\", void 0);\n//# sourceMappingURL=Sampler.js.map","import { Param } from \"../../core/context/Param.js\";\nimport { ToneAudioNode, } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @example\n * return Tone.Offline(() => {\n * // move the input signal from right to left\n * \tconst panner = new Tone.Panner(1).toDestination();\n * \tpanner.pan.rampTo(-1, 0.5);\n * \tconst osc = new Tone.Oscillator(100).connect(panner).start();\n * }, 0.5, 2);\n * @category Component\n */\nexport class Panner extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Panner.getDefaults(), arguments, [\n            \"pan\",\n        ]);\n        super(options);\n        this.name = \"Panner\";\n        /**\n         * the panner node\n         */\n        this._panner = this.context.createStereoPanner();\n        this.input = this._panner;\n        this.output = this._panner;\n        this.pan = new Param({\n            context: this.context,\n            param: this._panner.pan,\n            value: options.pan,\n            minValue: -1,\n            maxValue: 1,\n        });\n        // this is necessary for standardized-audio-context\n        // doesn't make any difference for the native AudioContext\n        // https://github.com/chrisguttandin/standardized-audio-context/issues/647\n        this._panner.channelCount = options.channelCount;\n        this._panner.channelCountMode = \"explicit\";\n        // initial value\n        readOnly(this, \"pan\");\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            pan: 0,\n            channelCount: 1,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._panner.disconnect();\n        this.pan.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Panner.js.map","import \"../core/worklet/SingleIOProcessor.worklet.js\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope.js\";\nexport const workletName = \"bit-crusher\";\nexport const bitCrusherWorklet = /* javascript */ `\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n`;\nregisterProcessor(workletName, bitCrusherWorklet);\n//# sourceMappingURL=BitCrusher.worklet.js.map","import { Gain } from \"../../core/context/Gain.js\";\nimport { ToneAudioNode, } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Solo.getDefaults(), arguments, [\n            \"solo\",\n        ]);\n        super(options);\n        this.name = \"Solo\";\n        this.input = this.output = new Gain({\n            context: this.context,\n        });\n        if (!Solo._allSolos.has(this.context)) {\n            Solo._allSolos.set(this.context, new Set());\n        }\n        Solo._allSolos.get(this.context).add(this);\n        // set initially\n        this.solo = options.solo;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            solo: false,\n        });\n    }\n    /**\n     * Isolates this instance and mutes all other instances of Solo.\n     * Only one instance can be soloed at a time. A soloed\n     * instance will report `solo=false` when another instance is soloed.\n     */\n    get solo() {\n        return this._isSoloed();\n    }\n    set solo(solo) {\n        if (solo) {\n            this._addSolo();\n        }\n        else {\n            this._removeSolo();\n        }\n        Solo._allSolos.get(this.context).forEach((instance) => instance._updateSolo());\n    }\n    /**\n     * If the current instance is muted, i.e. another instance is soloed\n     */\n    get muted() {\n        return this.input.gain.value === 0;\n    }\n    /**\n     * Add this to the soloed array\n     */\n    _addSolo() {\n        if (!Solo._soloed.has(this.context)) {\n            Solo._soloed.set(this.context, new Set());\n        }\n        Solo._soloed.get(this.context).add(this);\n    }\n    /**\n     * Remove this from the soloed array\n     */\n    _removeSolo() {\n        if (Solo._soloed.has(this.context)) {\n            Solo._soloed.get(this.context).delete(this);\n        }\n    }\n    /**\n     * Is this on the soloed array\n     */\n    _isSoloed() {\n        return (Solo._soloed.has(this.context) &&\n            Solo._soloed.get(this.context).has(this));\n    }\n    /**\n     * Returns true if no one is soloed\n     */\n    _noSolos() {\n        // either does not have any soloed added\n        return (!Solo._soloed.has(this.context) ||\n            // or has a solo set but doesn't include any items\n            (Solo._soloed.has(this.context) &&\n                Solo._soloed.get(this.context).size === 0));\n    }\n    /**\n     * Solo the current instance and unsolo all other instances.\n     */\n    _updateSolo() {\n        if (this._isSoloed()) {\n            this.input.gain.value = 1;\n        }\n        else if (this._noSolos()) {\n            // no one is soloed\n            this.input.gain.value = 1;\n        }\n        else {\n            this.input.gain.value = 0;\n        }\n    }\n    dispose() {\n        super.dispose();\n        Solo._allSolos.get(this.context).delete(this);\n        this._removeSolo();\n        return this;\n    }\n}\n/**\n * Hold all of the solo'ed tracks belonging to a specific context\n */\nSolo._allSolos = new Map();\n/**\n * Hold the currently solo'ed instance(s)\n */\nSolo._soloed = new Map();\n//# sourceMappingURL=Solo.js.map","import { readOnly } from \"../../core/util/Interface.js\";\nimport { ToneAudioNode, } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Panner } from \"./Panner.js\";\nimport { Volume } from \"./Volume.js\";\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\nexport class PanVol extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(PanVol.getDefaults(), arguments, [\n            \"pan\",\n            \"volume\",\n        ]);\n        super(options);\n        this.name = \"PanVol\";\n        this._panner = this.input = new Panner({\n            context: this.context,\n            pan: options.pan,\n            channelCount: options.channelCount,\n        });\n        this.pan = this._panner.pan;\n        this._volume = this.output = new Volume({\n            context: this.context,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        // connections\n        this._panner.connect(this._volume);\n        this.mute = options.mute;\n        readOnly(this, [\"pan\", \"volume\"]);\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            pan: 0,\n            volume: 0,\n            channelCount: 1,\n        });\n    }\n    /**\n     * Mute/unmute the volume\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    dispose() {\n        super.dispose();\n        this._panner.dispose();\n        this.pan.dispose();\n        this._volume.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PanVol.js.map","import { ToneAudioNode, } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Solo } from \"./Solo.js\";\nimport { PanVol } from \"./PanVol.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls.\n * @see {@link PanVol} and {@link Solo}\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\nexport class Channel extends ToneAudioNode {\n    constructor() {\n        const options = optionsFromArguments(Channel.getDefaults(), arguments, [\n            \"volume\",\n            \"pan\",\n        ]);\n        super(options);\n        this.name = \"Channel\";\n        this._solo = this.input = new Solo({\n            solo: options.solo,\n            context: this.context,\n        });\n        this._panVol = this.output = new PanVol({\n            context: this.context,\n            pan: options.pan,\n            volume: options.volume,\n            mute: options.mute,\n            channelCount: options.channelCount,\n        });\n        this.pan = this._panVol.pan;\n        this.volume = this._panVol.volume;\n        this._solo.connect(this._panVol);\n        readOnly(this, [\"pan\", \"volume\"]);\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            pan: 0,\n            volume: 0,\n            mute: false,\n            solo: false,\n            channelCount: 1,\n        });\n    }\n    /**\n     * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances\n     */\n    get solo() {\n        return this._solo.solo;\n    }\n    set solo(solo) {\n        this._solo.solo = solo;\n    }\n    /**\n     * If the current instance is muted, i.e. another instance is soloed,\n     * or the channel is muted\n     */\n    get muted() {\n        return this._solo.muted || this.mute;\n    }\n    /**\n     * Mute/unmute the volume\n     */\n    get mute() {\n        return this._panVol.mute;\n    }\n    set mute(mute) {\n        this._panVol.mute = mute;\n    }\n    /**\n     * Get the gain node belonging to the bus name. Create it if\n     * it doesn't exist\n     * @param name The bus name\n     */\n    _getBus(name) {\n        if (!Channel.buses.has(name)) {\n            Channel.buses.set(name, new Gain({ context: this.context }));\n        }\n        return Channel.buses.get(name);\n    }\n    /**\n     * Send audio to another channel using a string. `send` is a lot like\n     * {@link connect}, except it uses a string instead of an object. This can\n     * be useful in large applications to decouple sections since {@link send}\n     * and {@link receive} can be invoked separately in order to connect an object\n     * @param name The channel name to send the audio\n     * @param volume The amount of the signal to send.\n     * \tDefaults to 0db, i.e. send the entire signal\n     * @returns Returns the gain node of this connection.\n     */\n    send(name, volume = 0) {\n        const bus = this._getBus(name);\n        const sendKnob = new Gain({\n            context: this.context,\n            units: \"decibels\",\n            gain: volume,\n        });\n        this.connect(sendKnob);\n        sendKnob.connect(bus);\n        return sendKnob;\n    }\n    /**\n     * Receive audio from a channel which was connected with {@link send}.\n     * @param name The channel name to receive audio from.\n     */\n    receive(name) {\n        const bus = this._getBus(name);\n        bus.connect(this);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._panVol.dispose();\n        this.pan.dispose();\n        this.volume.dispose();\n        this._solo.dispose();\n        return this;\n    }\n}\n/**\n * Store the send/receive channels by name.\n */\nChannel.buses = new Map();\n//# sourceMappingURL=Channel.js.map","export { getContext, setContext } from \"./core/Global.js\";\nexport * from \"./classes.js\";\nexport * from \"./version.js\";\nimport { getContext } from \"./core/Global.js\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer.js\";\nexport { start } from \"./core/Global.js\";\nexport { supported } from \"./core/context/AudioContext.js\";\n/**\n * The current audio context time of the global {@link BaseContext}.\n * @see {@link Context.now}\n * @category Core\n */\nexport function now() {\n    return getContext().now();\n}\n/**\n * The current audio context time of the global {@link Context} without the {@link Context.lookAhead}\n * @see {@link Context.immediate}\n * @category Core\n */\nexport function immediate() {\n    return getContext().immediate();\n}\n/**\n * The Transport object belonging to the global Tone.js Context.\n * @see {@link TransportClass}\n * @category Core\n * @deprecated Use {@link getTransport} instead\n */\nexport const Transport = getContext().transport;\n/**\n * The Transport object belonging to the global Tone.js Context.\n * @see {@link TransportClass}\n * @category Core\n */\nexport function getTransport() {\n    return getContext().transport;\n}\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * @see {@link DestinationClass}\n * @category Core\n * @deprecated Use {@link getDestination} instead\n */\nexport const Destination = getContext().destination;\n/**\n * @deprecated Use {@link getDestination} instead\n */\nexport const Master = getContext().destination;\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * @see {@link DestinationClass}\n * @category Core\n */\nexport function getDestination() {\n    return getContext().destination;\n}\n/**\n * The {@link ListenerClass} belonging to the global Tone.js Context.\n * @category Core\n * @deprecated Use {@link getListener} instead\n */\nexport const Listener = getContext().listener;\n/**\n * The {@link ListenerClass} belonging to the global Tone.js Context.\n * @category Core\n */\nexport function getListener() {\n    return getContext().listener;\n}\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * @see {@link DrawClass}\n * @category Core\n * @deprecated Use {@link getDraw} instead\n */\nexport const Draw = getContext().draw;\n/**\n * Get the singleton attached to the global context.\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * @see {@link DrawClass}\n * @category Core\n */\nexport function getDraw() {\n    return getContext().draw;\n}\n/**\n * A reference to the global context\n * @see {@link Context}\n * @deprecated Use {@link getContext} instead\n */\nexport const context = getContext();\n/**\n * Promise which resolves when all of the loading promises are resolved.\n * Alias for static {@link ToneAudioBuffer.loaded} method.\n * @category Core\n */\nexport function loaded() {\n    return ToneAudioBuffer.loaded();\n}\n// this fills in name changes from 13.x to 14.x\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers.js\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource.js\";\n/** @deprecated Use {@link ToneAudioBuffer} */\nexport const Buffer = ToneAudioBuffer;\n/** @deprecated Use {@link ToneAudioBuffers} */\nexport const Buffers = ToneAudioBuffers;\n/** @deprecated Use {@link ToneBufferSource} */\nexport const BufferSource = ToneBufferSource;\n//# sourceMappingURL=index.js.map"],"names":["version","createExtendedExponentialRampToValueAutomationEvent","value","endTime","insertTime","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","target","timeConstant","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","getExponentialRampValueAtTime","getLinearRampValueAtTime","interpolateValue","theoreticIndex","lowerIndex","upperIndex","getValueCurveValueAtTime","isSetTargetAutomationEvent","AutomationEventList","eventTime","removedAutomationEvent","lastAutomationEvent","startValue","truncatedAutomationEvent","ratio","length","fraction","i","factor","previousAutomationEvent","persistentAutomationEvent","remainingAutomationEvents","firstRemainingAutomationEvent","indexOfNextEvent","indexOfCurrentEvent","createCancelAndHoldAutomationEvent","cancelTime","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","createAbortError","createAddActiveInputConnectionToAudioNode","insertElementInSet","activeInputs","source","output","input","eventListener","ignoreDuplicates","activeInputConnection","createAddAudioNodeConnections","audioNodeConnectionsStore","audioNode","audioNodeRenderer","nativeAudioNode","createAddAudioParamConnections","audioParamConnectionsStore","audioParam","audioParamRenderer","ACTIVE_AUDIO_NODE_STORE","AUDIO_NODE_CONNECTIONS_STORE","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","handler","isConstructible","constructible","proxy","IMPORT_STATEMENT_REGEX","splitImportStatements","url","importStatements","sourceWithoutImportStatements","result","unresolvedUrl","importStatementWithResolvedUrl","verifyParameterDescriptors","parameterDescriptors","verifyProcessorCtor","processorCtor","createAddAudioWorkletModule","cacheTestResult","createNotSupportedError","evaluateSource","exposeCurrentFrameAndCurrentTime","fetchSource","getNativeContext","getOrCreateBackupOfflineAudioContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","ongoingRequests","resolvedRequests","testAudioWorkletProcessorPostMessageSupport","window","context","moduleURL","options","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","nativeContext","promise","absoluteUrl","wrappedSource","evaluateAudioWorkletGlobalScope","name","nodeNameToProcessorConstructorMap","isSupportingPostMessage","currentIndex","blob","backupOfflineAudioContext","nativeContextOrBackupOfflineAudioContext","updatedResolvedRequestsOfContext","updatedOngoingRequestsOfContext","getValueForKey","map","key","pickElementFromSet","set","predicate","matchingElements","matchingElement","deletePassiveInputConnectionToAudioNode","passiveInputs","passiveInputConnections","matchingConnection","passiveInputConnection","getEventListenersOfAudioNode","setInternalStateToActive","isAudioWorkletNode","setInternalStateToPassive","setInternalStateToPassiveWhenNecessary","connections","createAddConnectionToAudioNode","addActiveInputConnectionToAudioNode","addPassiveInputConnectionToAudioNode","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnectionToAudioNode","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioNodeTailTime","getNativeAudioNode","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","tailTimeTimeoutIds","destination","isOffline","outputs","eventListeners","isActive","nativeDestinationAudioNode","nativeSourceAudioNode","partialConnection","tailTime","tailTimeTimeoutId","outputConnection","createAddPassiveInputConnectionToAudioNode","createAddSilentConnection","createNativeGainNode","nativeAudioScheduledSourceNode","nativeGainNode","disconnect","createAddUnrenderedAudioWorkletNode","getUnrenderedAudioWorkletNodes","audioWorkletNode","DEFAULT_OPTIONS","createAnalyserNodeConstructor","audionNodeConstructor","createAnalyserNodeRenderer","createIndexSizeError","createNativeAnalyserNode","mergedOptions","nativeAnalyserNode","analyserNodeRenderer","maxDecibels","minDecibels","array","isOwnedByContext","createAnalyserNodeRendererFactory","renderInputsOfAudioNode","renderedNativeAnalyserNodes","createAnalyserNode","nativeOfflineAudioContext","renderedNativeAnalyserNode","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","err","createAudioBufferConstructor","audioBufferStore","nativeAudioBufferConstructor","nativeOfflineAudioContextConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","AudioBuffer","numberOfChannels","sampleRate","instance","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","createAudioBufferSourceNodeConstructor","audioNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","createNativeAudioBufferSourceNode","wrapEventListener","nativeAudioBufferSourceNode","audioBufferSourceNodeRenderer","wrappedListener","nativeOnEnded","when","offset","resetInternalStateToPassive","createAudioBufferSourceNodeRendererFactory","connectAudioParam","renderAutomation","renderedNativeAudioBufferSourceNodes","start","stop","createAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","renderedNativeAudioBufferSourceNode","isAudioBufferSourceNode","isBiquadFilterNode","isConstantSourceNode","isGainNode","isOscillatorNode","isStereoPannerNode","getAudioParamConnections","deactivateActiveAudioNodeInputConnections","trace","audioParams","audioParamConnections","deactivateAudioGraph","isValidLatencyHint","latencyHint","createAudioContextConstructor","baseAudioContextConstructor","createUnknownError","mediaElementAudioSourceNodeConstructor","mediaStreamAudioDestinationNodeConstructor","mediaStreamAudioSourceNodeConstructor","mediaStreamTrackAudioSourceNodeConstructor","nativeAudioContextConstructor","nativeAudioContext","revokeState","mediaElement","mediaStream","mediaStreamTrack","resolve","reject","resolvePromise","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","channelCount","nativeAudioDestinationNode","audioDestinationNodeRenderer","renderedNativeAudioDestinationNodes","createAudioDestinationNode","renderedNativeAudioDestinationNode","createAudioListenerFactory","createNativeChannelMergerNode","createNativeConstantSourceNode","createNativeScriptProcessorNode","getFirstSample","overwriteAccessors","nativeListener","createFakeAudioParams","buffer","channelMergerNode","isScriptProcessorNodeCreated","lastOrientation","lastPosition","createScriptProcessorNode","scriptProcessorNode","inputBuffer","orientation","positon","createSetOrientation","createSetPosition","createFakeAudioParam","initialValue","setValue","constantSourceNode","get","cancelAndHoldAtTime","args","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setTargetAtTime","setValueAtTime","setValueCurveAtTime","forwardX","forwardY","forwardZ","positionX","positionY","positionZ","upX","upY","upZ","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","element","lmnt","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioParam","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","fakeNativeDestinationAudioNode","deleteActiveInputConnection","activeInputConnections","deleteActiveInputConnectionToAudioParam","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioParam","getNativeAudioParam","testAudioNodeDisconnectMethodSupport","analyzer","dummy","ones","channelData","event","chnnlDt","sample","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","count","isNativeAudioNode","nativeAudioNodeOrAudioParam","wrapAudioNodeDisconnectMethod","connect","returnValue","connectionsToDestination","connection","destinationOrOutput","filteredConnections","addConnectionToAudioParamOfAudioContext","nativeAudioParam","deleteInputConnectionOfAudioNode","deleteInputConnectionOfAudioParam","deleteInputsOfAudioNode","listener","deleteInputsOfAudioParam","deleteAnyConnection","audioNodeConnectionsOfSource","destinations","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","createIncrementCycleCounter","createInvalidAccessError","decrementCycleCounter","detectCycles","eventTargetConstructor","isNativeAudioContext","isNativeAudioParam","isPassive","createAudioParamFactory","addAudioParamConnections","audioParamAudioNodeStore","audioParamStore","createAudioParamRenderer","setValueAtTimeUntilPossible","isAudioParamOfOfflineAudioContext","maxValue","minValue","automationEventList","previousLastEvent","currentLastEvent","currentTime","convertedValues","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","ReadOnlyMap","parameters","callback","thisArg","createAudioWorkletNodeConstructor","addUnrenderedAudioWorkletNode","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","getBackupOfflineAudioContext","sanitizeAudioWorkletNodeOptions","setActiveAudioWorkletNodeInputs","testAudioWorkletNodeOptionsClonability","_a","processorConstructor","nativeAudioWorkletNode","audioWorkletNodeRenderer","nm","nativeOnProcessorError","copyFromChannel","parent","channelNumber","bufferOffset","slicedInput","copyToChannel","createNestedArrays","x","y","arrays","j","getAudioWorkletProcessor","nodeToProcessorMap","processBuffer","renderedBuffer","outputChannelCount","numberOfInputChannels","numberOfOutputChannels","sum","processedBuffer","audioNodeConnections","audioWorkletProcessor","inputs","prmtrs","k","potentiallyEmptyInputs","activeSourceFlag","outputChannelSplitterNodeOutput","error","createAudioWorkletNodeRendererFactory","connectMultipleOutputs","createNativeChannelSplitterNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","renderNativeOfflineAudioContext","renderedNativeAudioNodes","processedBufferPromise","createAudioNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","outputChannelSplitterNode","outputChannelMergerNodes","outputGainNode","numberOfParameters","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","gainNode","audioBufferSourceNode","outputChannelMergerNode","renderedNativeAudioWorkletNodeOrGainNode","createBaseAudioContextConstructor","addAudioWorkletModule","analyserNodeConstructor","audioBufferConstructor","audioBufferSourceNodeConstructor","biquadFilterNodeConstructor","channelMergerNodeConstructor","channelSplitterNodeConstructor","constantSourceNodeConstructor","convolverNodeConstructor","decodeAudioData","delayNodeConstructor","dynamicsCompressorNodeConstructor","gainNodeConstructor","iIRFilterNodeConstructor","minimalBaseAudioContextConstructor","oscillatorNodeConstructor","pannerNodeConstructor","periodicWaveConstructor","stereoPannerNodeConstructor","waveShaperNodeConstructor","_nativeContext","numberOfInputs","numberOfOutputs","maxDelayTime","feedforward","feedback","real","imag","constraints","audioData","successCallback","errorCallback","createBiquadFilterNodeConstructor","createBiquadFilterNodeRenderer","createNativeBiquadFilterNode","setAudioNodeTailTime","nativeBiquadFilterNode","biquadFilterNodeRenderer","frequencyHz","magResponse","phaseResponse","createBiquadFilterNodeRendererFactory","renderedNativeBiquadFilterNodes","createBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","renderedNativeBiquadFilterNode","createCacheTestResult","ongoingTests","testResults","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createChannelMergerNodeConstructor","createChannelMergerNodeRenderer","nativeChannelMergerNode","channelMergerNodeRenderer","createChannelMergerNodeRendererFactory","renderedNativeAudioNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRenderer","sanitizeChannelSplitterOptions","nativeChannelSplitterNode","channelSplitterNodeRenderer","createChannelSplitterNodeRendererFactory","createConnectAudioParam","renderInputsOfAudioParam","createConnectMultipleOutputs","outputAudioNodes","outputAudioNode","createConnectedNativeAudioBufferSourceNodeFactory","createConstantSourceNodeConstructor","createConstantSourceNodeRendererFactory","nativeConstantSourceNode","constantSourceNodeRenderer","renderedNativeConstantSourceNodes","createConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","renderedNativeConstantSourceNode","createConvertNumberToUnsignedLong","unit32Array","createConvolverNodeConstructor","createConvolverNodeRenderer","createNativeConvolverNode","nativeConvolverNode","convolverNodeRenderer","createConvolverNodeRendererFactory","renderedNativeConvolverNodes","createConvolverNode","renderedNativeConvolverNode","createCreateNativeOfflineAudioContext","createDataCloneError","detachArrayBuffer","arrayBuffer","port1","port2","closeAndResolve","createDecodeAudioData","createEncodingError","detachedArrayBuffers","isNativeContext","testPromiseSupport","anyContext","complete","fail","createDecrementCycleCounter","cycleCounters","cycleCounter","nativeDestinationAudioParam","createDelayNodeConstructor","createDelayNodeRenderer","createNativeDelayNode","nativeDelayNode","delayNodeRenderer","createDelayNodeRendererFactory","renderedNativeDelayNodes","createDelayNode","nativeDelayNodeIsOwnedByContext","renderedNativeDelayNode","createDeleteActiveInputConnectionToAudioNode","createDeleteUnrenderedAudioWorkletNode","isDelayNode","createDetectCycles","chain","nextLink","mergedCycles","nestedCycles","getOutputAudioNodeAtIndex","createDisconnectMultipleOutputs","createDynamicsCompressorNodeConstructor","createDynamicsCompressorNodeRenderer","createNativeDynamicsCompressorNode","nativeDynamicsCompressorNode","dynamicsCompressorNodeRenderer","previousChannelCount","createDynamicsCompressorNodeRendererFactory","renderedNativeDynamicsCompressorNodes","createDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","renderedNativeDynamicsCompressorNode","createEvaluateSource","head","script","originalOnErrorHandler","removeErrorEventListenerAndRevokeUrl","message","src","lineno","colno","createEventTargetConstructor","_nativeEventTarget","type","wrappedEventListener","createExposeCurrentFrameAndCurrentTime","fn","createFetchSource","response","createGainNodeConstructor","createGainNodeRenderer","gainNodeRenderer","createGainNodeRendererFactory","renderedNativeGainNodes","createGainNode","nativeGainNodeIsOwnedByContext","renderedNativeGainNode","createGetActiveAudioWorkletNodeInputs","activeAudioWorkletNodeInputsStore","createGetAudioNodeRenderer","createGetAudioNodeTailTime","audioNodeTailTimeStore","createGetAudioParamRenderer","createGetBackupOfflineAudioContext","backupOfflineAudioContextStore","createGetNativeContext","contextStore","createGetOrCreateBackupOfflineAudioContext","createGetUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodeStore","unrenderedAudioWorkletNodes","wrapIIRFilterNodeGetFrequencyResponseMethod","nativeIIRFilterNode","getFrequencyResponse","createIIRFilterNodeConstructor","createNativeIIRFilterNode","createIIRFilterNodeRenderer","iirFilterNodeRenderer","filterBuffer","feedbackLength","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","filterFullBuffer","convertedFeedback","convertedFeedforward","filteredBuffer","createIIRFilterNodeRendererFactory","filteredBufferPromise","nativeIIRFilterNodeIsOwnedByContext","createIncrementCycleCounterFactory","createIsAnyAudioContext","anything","createIsAnyAudioNode","audioNodeStore","createIsAnyAudioParam","createIsAnyOfflineAudioContext","createIsNativeAudioContext","createIsNativeAudioNode","createIsNativeAudioParam","createIsNativeContext","createIsNativeOfflineAudioContext","createIsSecureContext","createMediaElementAudioSourceNodeConstructor","createNativeMediaElementAudioSourceNode","nativeMediaElementAudioSourceNode","createMediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioDestinationNode","nativeMediaStreamAudioDestinationNode","createMediaStreamAudioSourceNodeConstructor","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","createNativeMediaStreamTrackAudioSourceNode","nativeMediaStreamTrackAudioSourceNode","createMinimalBaseAudioContextConstructor","audioDestinationNodeConstructor","createAudioListener","nativeOnStateChange","uint32Array","createMonitorConnections","whenConnected","whenDisconnected","wasDisconnected","wasConnected","isDisconnected","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","wrapAnalyserNodeGetFloatTimeDomainDataMethod","byteTimeDomainData","createNativeAnalyserNodeFactory","createNativeAudioBufferConstructor","assignNativeAudioNodeAudioParamValue","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","isScheduled","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","createNativeAudioBufferSourceNodeFactory","addSilentConnection","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","createNativeAudioContextConstructor","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","createNativeAudioWorkletNodeConstructor","testClonabilityOfAudioWorkletNodeOptions","audioWorkletNodeOptions","createNativeAudioWorkletNodeFactory","createNativeAudioWorkletNodeFaker","monitorConnections","baseLatency","patchedEventListeners","onprocessorerror","addEventListener","unpatchedEventListener","patchedEventListener","removeEventListener","computeBufferSize","cloneAudioWorkletNodeOptions","data","createAudioWorkletProcessorPromise","clonedAudioWorkletNodeOptions","createAudioWorkletProcessor","audioWorkletProcessorPromise","createNativeAudioWorkletNodeFakerFactory","getActiveAudioWorkletNodeInputs","messageChannel","bufferSize","parameterMap","channelInterpretation","nativeAudioWorkletNodeFaker","_","onmessage","dWrkltPrcssr","disconnectOutputsGraph","activeInputIndexes","outputBuffer","isConnected","disconnectFakeGraph","connectFakeGraph","createNativeChannelMergerNodeFactory","wrapChannelMergerNode","wrapChannelSplitterNode","channelSplitterNode","createNativeConstantSourceNodeFactory","createNativeConstantSourceNodeFaker","interceptConnections","original","interceptor","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","nativeConstantSourceNodeFaker","createNativeConvolverNodeFactory","createNativeDynamicsCompressorNodeFactory","createNativeIIRFilterNodeFactory","createNativeIIRFilterNodeFaker","divide","a","b","denominator","multiply","evaluatePolynomial","coefficient","z","createNativeIIRFilterNodeFakerFactory","channelCountMode","bufferIndexes","xBuffers","yBuffers","nyquist","omega","numerator","audioStreamTracks","filteredAudioStreamTracks","createNativeMediaStreamTrackAudioSourceNodeFactory","createNativeOfflineAudioContextConstructor","createNativeOscillatorNodeFactory","nativeOscillatorNode","createNativePannerNodeFactory","createNativePannerNodeFaker","nativePannerNode","createNativePannerNodeFakerFactory","createNativeWaveShaperNode","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","refDistance","rolloffFactor","pannerNode","SINGLE_CHANNEL_OPTIONS","inputGainNode","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePeriodicWaveFactory","disableNormalization","convertedImag","convertedReal","nativePeriodicWave","createNativeStereoPannerNodeFactory","createNativeStereoPannerNodeFaker","nativeStereoPannerNode","createNativeStereoPannerNodeFakerFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraphForMono","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForStereo","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraph","pan","connectGraph","disconnectGraph","nativeStereoPannerNodeFakerFactory","createNativeWaveShaperNodeFactory","createConnectedNativeAudioBufferSourceNode","createNativeWaveShaperNodeFaker","isDCCurve","nativeWaveShaperNode","curve","disconnectNativeAudioBufferSourceNode","createNativeWaveShaperNodeFakerFactory","oversample","negativeWaveShaperNode","positiveWaveShaperNode","invertGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","createOfflineAudioContextConstructor","createNativeOfflineAudioContext","startRendering","delayStateChangeEvent","createOscillatorNodeConstructor","createNativeOscillatorNode","createOscillatorNodeRenderer","oscillatorNodeRenderer","periodicWave","createOscillatorNodeRendererFactory","renderedNativeOscillatorNodes","createOscillatorNode","nativeOscillatorNodeIsOwnedByContext","renderedNativeOscillatorNode","createPannerNodeConstructor","createNativePannerNode","createPannerNodeRenderer","pannerNodeRenderer","createPannerNodeRendererFactory","renderedBufferPromise","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","renderedNativeGainNodeOrNativePannerNode","createPeriodicWaveConstructor","createNativePeriodicWave","periodicWaveStore","sanitizePeriodicWaveOptions","PeriodicWave","createRenderAutomation","getAudioParamRenderer","createRenderInputsOfAudioNode","getAudioNodeRenderer","allRenderingPromises","renderingPromises","createRenderInputsOfAudioParam","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","createSetActiveAudioWorkletNodeInputs","createSetAudioNodeTailTime","createStartRendering","createStereoPannerNodeConstructor","createNativeStereoPannerNode","createStereoPannerNodeRenderer","stereoPannerNodeRenderer","createStereoPannerNodeRendererFactory","renderedNativeStereoPannerNodes","createStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","renderedNativeStereoPannerNode","createTestAudioBufferConstructorSupport","createTestAudioWorkletProcessorPostMessageSupport","offlineAudioContext","isEmittingMessageEvents","isEmittingProcessorErrorEvents","oscillator","createTestOfflineAudioContextCurrentTimeSupport","createWaveShaperNodeConstructor","createWaveShaperNodeRenderer","waveShaperNodeRenderer","createWaveShaperNodeRendererFactory","renderedNativeWaveShaperNodes","createWaveShaperNode","renderedNativeWaveShaperNode","createWindow","createWrapAudioBufferCopyChannelMethods","convertNumberToUnsignedLong","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","nullifiedBuffer","createWrapChannelMergerNode","object","property","createGetter","createSetter","prototype","wrapAudioBufferSourceNodeStartMethodOffsetClamping","clampedOffset","disconnectGainNode","isStopped","descriptor","createConstantSourceNodeRenderer","isSecureContext","audioContextConstructor","audioWorkletNodeConstructor","offlineAudioContextConstructor","isAnyAudioContext","isAnyAudioNode","isAnyAudioParam","isAnyOfflineAudioContext","isUndef","arg","isDefined","isFunction","isNumber","isObject","isBoolean","isArray","isString","isNote","assert","statement","assertRange","gte","lte","assertContextRunning","warn","isInsideScheduledCallback","printedScheduledWarning","enterScheduledCallback","insideCallback","assertUsedScheduleTime","defaultLogger","log","createAudioContext","stdAudioContext","createOfflineAudioContext","channels","stdOfflineAudioContext","theWindow","hasAudioContext","createAudioWorkletNode","stdAudioWorkletNode","Ticker","updateInterval","contextSampleRate","blobUrl","worker","interval","isAudioParam","isOfflineAudioContext","isAudioContext","isAudioBuffer","noCopy","deepMerge","sources","deepEquals","arrayA","arrayB","optionsFromArguments","defaults","argsArray","keys","objKey","opts","getDefaultsFromInstance","defaultArg","given","fallback","omitFromObject","obj","omit","prop","Tone","EPSILON","GT","GTE","EQ","LT","clamp","min","max","Timeline","lastValue","diff","param","len","after","beginning","end","midPoint","nextEvent","testEvent","lowerBound","upperBound","notifyNewContext","onContextInit","cb","initializeContext","ctx","notifyCloseContext","onContextClose","closeContext","Emitter","eventName","boundCallback","eventList","constr","BaseContext","Context","_b","feedForward","stream","l","d","__awaiter","val","arr","constant","now","timeout","id","intervalFn","DummyContext","_numberOfChannels","_length","_sampleRate","_numberOfInputs","_numberOfOutputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_element","_audioData","_name","_options","_url","_fn","_timeout","_id","_interval","_val","_d","readOnly","str","writable","noOp","ToneAudioBuffer","getContext","doneLoading","isMultidimensional","multiChannelArray","chanNum","outputArray","numChannels","channelArray","ret","c","startSamples","endSamples","retBuffer","rev","baseUrl","extensions","extension","OfflineContext","asynchronous","yieldEvery","done","dummyContext","globalContext","setContext","disposeOld","printString","dbToGain","db","gainToDb","gain","intervalToFrequencyRatio","A4","getA4","setA4","freq","ftom","frequency","ftomf","mtof","midi","TimeBaseClass","units","dot","numericValue","scalar","m","q","s","total","typeName","quantity","expr","matching","beats","seconds","ticks","TimeClass","capture","quantTo","subdiv","percent","subdivision","testNotations","power","closest","closestSeconds","notation","notationSeconds","quarterTime","quarters","measures","sixteenths","sixteenthString","Time","FrequencyClass","pitch","octave","noteNumber","noteToScaleIndex","intervals","scaleIndexToNote","TransportTimeClass","ToneWithContext","props","attribute","member","StateTimeline","initial","state","Param","computedTime","before","previous","previousVal","beforeValue","currentVal","rampTime","scaling","startingValue","segTime","valueAtTime","previousEvent","subdivisions","t0","v0","v1","t","t1","ToneAudioNode","node","nodeList","outputNum","inputNum","nodes","connectSeries","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","Gain","OneShotSource","fadeInTime","fadeOutTime","additionalTail","disposeCallback","ToneConstantSource","Signal","connectSignal","convert","overridden","signal","TickParam","computedValue","prevEvent","segments","rampVal","ticksUntilTime","computedVal","segmentDur","val0","val1","onTheLineEvent","currentTick","tick","delta","sol1","sol2","computedDuration","startTicks","TickSignal","TickSource","stopEvent","memoizedEvent","tmpEvent","lastState","elapsedTicks","eventToMemoize","e","periodStartTime","offsetEvent","elapsedSeconds","absoluteTicks","lastStateEvent","maxStartTime","ticksAtStart","nextTickTime","Clock","Volume","mute","DestinationClass","ListenerClass","ToneAudioBuffers","onerror","TicksClass","DrawClass","IntervalTimeline","IntervalNode","results","replacement","balance","temp","isLeftChild","pivotNode","allNodes","low","high","point","TimelineValue","SignalOperator","WaveShaper","mapping","normalized","oversampling","isOverSampleType","Pow","exponent","TransportEvent","transport","tickDuration","TransportRepeatEvent","TransportClass","tickTime","progress","amount","eventId","item","timeline","computedAfter","offsetTicks","timeSig","startPosition","endPosition","loop","remainingTick","ppq","transportPos","remainingTicks","sourceValue","scaleFactor","scaleBefore","reciprocal","scaleAfter","ratioSignal","syncedSignal","Source","sched","stateEvent","startOffset","ToneBufferSource","computedOffset","loopEnd","loopStart","loopDuration","computedDur","generateWaveform","ToneOscillatorNode","Oscillator","description","oscProps","isBasicType","cache","partials","wave","baseType","p","partial","fullPartials","v","phase","periodicWaveSize","partialCount","n","piFactor","twoPi","testPositions","AudioToGain","Multiply","AMOscillator","FMOscillator","PulseOscillator","FatOscillator","osc","iterator","spread","step","PWMOscillator","OmniOscillatorSourceMap","OmniOscillator","prefix","oscType","OscConstructor","oldOsc","sType","sourceType","mType","range","valueMap","propertyKey","newValue","timeRange","Player","origDuration","rate","__decorate","Envelope","direction","curveName","EnvelopeCurves","curveDef","velocity","attack","decay","currentValue","attackRate","decayValue","decayStart","release","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","cosineCurve","rippleCurve","rippleCurveFreq","sineWave","stairsCurve","steps","sineCurve","bounceCurve","invertCurve","out","reverseCurve","Instrument","changed","method","timePosition","originalMethod","note","Monophonic","computedFrequency","portTime","AmplitudeEnvelope","Synth","computedAttack","computedDecay","MembraneSynth","hertz","maxNote","workletContext","addToWorklet","classOrFunction","registerProcessor","classDesc","processor","toneAudioWorkletProcessor","singleIOProcess","delayLine","workletName","feedbackCombFilter","Sampler","urlMap","mid","notes","midiFloat","remainder","difference","closestNote","playbackRate","Panner","bitCrusherWorklet","Solo","solo","PanVol","Channel","volume","bus","sendKnob"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346]}