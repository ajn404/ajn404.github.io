{"version":3,"file":"index.BHYS6RGL.js","sources":["../../node_modules/.pnpm/three-stdlib@2.36.0_three@0.160.1/node_modules/three-stdlib/utils/BufferGeometryUtils.js","../../node_modules/.pnpm/@react-three+drei@9.122.0_@react-three+fiber@8.18.0_@types+react@18.3.21_react-dom@18.3.1_rea_ol2zxzpl3eb2iz24jitbgx25da/node_modules/@react-three/drei/core/Center.js","../../node_modules/.pnpm/react-composer@5.0.3_react@18.3.1/node_modules/react-composer/es/index.js","../../node_modules/.pnpm/@react-three+drei@9.122.0_@react-three+fiber@8.18.0_@types+react@18.3.21_react-dom@18.3.1_rea_ol2zxzpl3eb2iz24jitbgx25da/node_modules/@react-three/drei/helpers/deprecated.js","../../node_modules/.pnpm/@react-three+drei@9.122.0_@react-three+fiber@8.18.0_@types+react@18.3.21_react-dom@18.3.1_rea_ol2zxzpl3eb2iz24jitbgx25da/node_modules/@react-three/drei/core/Instances.js","../../node_modules/.pnpm/@react-three+drei@9.122.0_@react-three+fiber@8.18.0_@types+react@18.3.21_react-dom@18.3.1_rea_ol2zxzpl3eb2iz24jitbgx25da/node_modules/@react-three/drei/core/RoundedBox.js","../../node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.21_react@18.3.1/node_modules/zustand/esm/vanilla.mjs","../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js","../../node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.3.1/node_modules/use-sync-external-store/shim/with-selector.js","../../node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.21_react@18.3.1/node_modules/zustand/esm/index.mjs","../../node_modules/.pnpm/tunnel-rat@0.1.2_@types+react@18.3.21_react@18.3.1/node_modules/tunnel-rat/dist/index.js","../../node_modules/.pnpm/@react-three+drei@9.122.0_@react-three+fiber@8.18.0_@types+react@18.3.21_react-dom@18.3.1_rea_ol2zxzpl3eb2iz24jitbgx25da/node_modules/@react-three/drei/web/View.js","../../src/components/react/store/useStore.ts","../../src/components/react/Origami/material.tsx","../../node_modules/.pnpm/@gsap+react@2.1.2_gsap@3.13.0_react@18.3.1/node_modules/@gsap/react/src/index.js","../../src/components/react/Origami/Rings.tsx","../../src/components/react/Origami/Loop.tsx","../../src/components/react/Origami/Coins.tsx","../../src/components/react/Origami/Core.tsx","../../src/components/react/Origami/Rubik.tsx","../../src/components/react/Origami/Travel.tsx","../../src/components/react/Origami/Stagger.tsx","../../src/components/react/Origami/Balance.tsx","../../src/components/react/Origami/Pulse.tsx","../../src/components/react/Origami/Pie.tsx","../../src/components/react/Origami/Cradle.tsx","../../src/components/react/Origami/Arrows.tsx","../../src/components/react/Origami/index.tsx"],"sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n//# sourceMappingURL=BufferGeometryUtils.js.map\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { Box3, Vector3, Sphere } from 'three';\nimport * as React from 'react';\n\nconst Center = /* @__PURE__ */React.forwardRef(function Center({\n  children,\n  disable,\n  disableX,\n  disableY,\n  disableZ,\n  left,\n  right,\n  top,\n  bottom,\n  front,\n  back,\n  onCentered,\n  precise = true,\n  cacheKey = 0,\n  ...props\n}, fRef) {\n  const ref = React.useRef(null);\n  const outer = React.useRef(null);\n  const inner = React.useRef(null);\n  React.useLayoutEffect(() => {\n    outer.current.matrixWorld.identity();\n    const box3 = new Box3().setFromObject(inner.current, precise);\n    const center = new Vector3();\n    const sphere = new Sphere();\n    const width = box3.max.x - box3.min.x;\n    const height = box3.max.y - box3.min.y;\n    const depth = box3.max.z - box3.min.z;\n    box3.getCenter(center);\n    box3.getBoundingSphere(sphere);\n    const vAlign = top ? height / 2 : bottom ? -height / 2 : 0;\n    const hAlign = left ? -width / 2 : right ? width / 2 : 0;\n    const dAlign = front ? depth / 2 : back ? -depth / 2 : 0;\n    outer.current.position.set(disable || disableX ? 0 : -center.x + hAlign, disable || disableY ? 0 : -center.y + vAlign, disable || disableZ ? 0 : -center.z + dAlign);\n\n    // Only fire onCentered if the bounding box has changed\n    if (typeof onCentered !== 'undefined') {\n      onCentered({\n        parent: ref.current.parent,\n        container: ref.current,\n        width,\n        height,\n        depth,\n        boundingBox: box3,\n        boundingSphere: sphere,\n        center: center,\n        verticalAlignment: vAlign,\n        horizontalAlignment: hAlign,\n        depthAlignment: dAlign\n      });\n    }\n  }, [cacheKey, onCentered, top, left, front, disable, disableX, disableY, disableZ, precise, right, bottom, back]);\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"group\", {\n    ref: outer\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    ref: inner\n  }, children)));\n});\n\nexport { Center };\n","import { cloneElement } from 'react';\nimport PropTypes from 'prop-types';\n\nexport default function Composer(props) {\n  return renderRecursive(props.children, props.components);\n}\n\nComposer.propTypes = {\n  children: PropTypes.func.isRequired,\n  components: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.func])).isRequired\n};\n\n/**\n * Recursively build up elements from props.components and accumulate `results` along the way.\n * @param {function} render\n * @param {Array.<ReactElement|Function>} remaining\n * @param {Array} [results]\n * @returns {ReactElement}\n */\nfunction renderRecursive(render, remaining, results) {\n  results = results || [];\n  // Once components is exhausted, we can render out the results array.\n  if (!remaining[0]) {\n    return render(results);\n  }\n\n  // Continue recursion for remaining items.\n  // results.concat([value]) ensures [...results, value] instead of [...results, ...value]\n  function nextRender(value) {\n    return renderRecursive(render, remaining.slice(1), results.concat([value]));\n  }\n\n  // Each props.components entry is either an element or function [element factory]\n  return typeof remaining[0] === 'function' ? // When it is a function, produce an element by invoking it with \"render component values\".\n  remaining[0]({ results: results, render: nextRender }) : // When it is an element, enhance the element's props with the render prop.\n  cloneElement(remaining[0], { children: nextRender });\n}","/**\n * Sets `BufferAttribute.updateRange` since r159.\n */\nconst setUpdateRange = (attribute, updateRange) => {\n  if ('updateRanges' in attribute) {\n    // r159\n    // @ts-ignore\n    attribute.updateRanges[0] = updateRange;\n  } else {\n    attribute.updateRange = updateRange;\n  }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */\n\nexport { LinearEncoding, sRGBEncoding, setUpdateRange };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport Composer from 'react-composer';\nimport { setUpdateRange } from '../helpers/deprecated.js';\n\nfunction isFunctionChild(value) {\n  return typeof value === 'function';\n}\nconst _instanceLocalMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst _instanceWorldMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst _instanceIntersects = [];\nconst _mesh = /* @__PURE__ */new THREE.Mesh();\nclass PositionMesh extends THREE.Group {\n  constructor() {\n    super();\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  }\n\n  // This will allow the virtual instance have bounds\n  get geometry() {\n    var _this$instance$curren;\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  }\n\n  // And this will allow the virtual instance to receive events\n  raycast(raycaster, intersects) {\n    const parent = this.instance.current;\n    if (!parent) return;\n    if (!parent.geometry || !parent.material) return;\n    _mesh.geometry = parent.geometry;\n    const matrixWorld = parent.matrixWorld;\n    const instanceId = parent.userData.instances.indexOf(this.instanceKey);\n    // If the instance wasn't found or exceeds the parents draw range, bail out\n    if (instanceId === -1 || instanceId > parent.count) return;\n    // calculate the world matrix for each instance\n    parent.getMatrixAt(instanceId, _instanceLocalMatrix);\n    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n    // the mesh represents this single instance\n    _mesh.matrixWorld = _instanceWorldMatrix;\n    // raycast side according to instance material\n    if (parent.material instanceof THREE.Material) _mesh.material.side = parent.material.side;else _mesh.material.side = parent.material[0].side;\n    _mesh.raycast(raycaster, _instanceIntersects);\n    // process the result of raycast\n    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n      const intersect = _instanceIntersects[i];\n      intersect.instanceId = instanceId;\n      intersect.object = this;\n      intersects.push(intersect);\n    }\n    _instanceIntersects.length = 0;\n  }\n}\nconst globalContext = /* @__PURE__ */React.createContext(null);\nconst parentMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst instanceMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst tempMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst translation = /* @__PURE__ */new THREE.Vector3();\nconst rotation = /* @__PURE__ */new THREE.Quaternion();\nconst scale = /* @__PURE__ */new THREE.Vector3();\nconst isInstancedBufferAttribute = attr => attr.isInstancedBufferAttribute;\nconst Instance = /* @__PURE__ */React.forwardRef(({\n  context,\n  children,\n  ...props\n}, ref) => {\n  React.useMemo(() => extend({\n    PositionMesh\n  }), []);\n  const group = React.useRef();\n  React.useImperativeHandle(ref, () => group.current, []);\n  const {\n    subscribe,\n    getParent\n  } = React.useContext(context || globalContext);\n  React.useLayoutEffect(() => subscribe(group), []);\n  return /*#__PURE__*/React.createElement(\"positionMesh\", _extends({\n    instance: getParent(),\n    instanceKey: group,\n    ref: group\n  }, props), children);\n});\nconst Instances = /* @__PURE__ */React.forwardRef(({\n  context,\n  children,\n  range,\n  limit = 1000,\n  frames = Infinity,\n  ...props\n}, ref) => {\n  const [{\n    localContext,\n    instance\n  }] = React.useState(() => {\n    const localContext = /*#__PURE__*/React.createContext(null);\n    return {\n      localContext,\n      instance: /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(Instance, _extends({\n        context: localContext\n      }, props, {\n        ref: ref\n      })))\n    };\n  });\n  const parentRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => parentRef.current, []);\n  const [instances, setInstances] = React.useState([]);\n  const [[matrices, colors]] = React.useState(() => {\n    const mArray = new Float32Array(limit * 16);\n    for (let i = 0; i < limit; i++) tempMatrix.identity().toArray(mArray, i * 16);\n    return [mArray, new Float32Array([...new Array(limit * 3)].map(() => 1))];\n  });\n  React.useEffect(() => {\n    // We might be a frame too late? ðŸ¤·â€â™‚ï¸\n    parentRef.current.instanceMatrix.needsUpdate = true;\n  });\n  let iterations = 0;\n  let count = 0;\n  const attributes = React.useRef([]);\n  React.useLayoutEffect(() => {\n    attributes.current = Object.entries(parentRef.current.geometry.attributes).filter(([_name, value]) => isInstancedBufferAttribute(value));\n  });\n  useFrame(() => {\n    if (frames === Infinity || iterations < frames) {\n      parentRef.current.updateMatrix();\n      parentRef.current.updateMatrixWorld();\n      parentMatrix.copy(parentRef.current.matrixWorld).invert();\n      count = Math.min(limit, range !== undefined ? range : limit, instances.length);\n      parentRef.current.count = count;\n      setUpdateRange(parentRef.current.instanceMatrix, {\n        offset: 0,\n        count: count * 16\n      });\n      setUpdateRange(parentRef.current.instanceColor, {\n        offset: 0,\n        count: count * 3\n      });\n      for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i].current;\n        // Multiply the inverse of the InstancedMesh world matrix or else\n        // Instances will be double-transformed if <Instances> isn't at identity\n        instance.matrixWorld.decompose(translation, rotation, scale);\n        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);\n        instanceMatrix.toArray(matrices, i * 16);\n        parentRef.current.instanceMatrix.needsUpdate = true;\n        instance.color.toArray(colors, i * 3);\n        parentRef.current.instanceColor.needsUpdate = true;\n      }\n      iterations++;\n    }\n  });\n  const api = React.useMemo(() => ({\n    getParent: () => parentRef,\n    subscribe: ref => {\n      setInstances(instances => [...instances, ref]);\n      return () => setInstances(instances => instances.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return /*#__PURE__*/React.createElement(\"instancedMesh\", _extends({\n    userData: {\n      instances,\n      limit,\n      frames\n    },\n    matrixAutoUpdate: false,\n    ref: parentRef,\n    args: [null, null, 0],\n    raycast: () => null\n  }, props), /*#__PURE__*/React.createElement(\"instancedBufferAttribute\", {\n    attach: \"instanceMatrix\",\n    count: matrices.length / 16,\n    array: matrices,\n    itemSize: 16,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"instancedBufferAttribute\", {\n    attach: \"instanceColor\",\n    count: colors.length / 3,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), isFunctionChild(children) ? /*#__PURE__*/React.createElement(localContext.Provider, {\n    value: api\n  }, children(instance)) : context ? /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children) : /*#__PURE__*/React.createElement(globalContext.Provider, {\n    value: api\n  }, children));\n});\nconst Merged = /* @__PURE__ */React.forwardRef(function Merged({\n  meshes,\n  children,\n  ...props\n}, ref) {\n  const isArray = Array.isArray(meshes);\n  // Filter out meshes from collections, which may contain non-meshes\n  if (!isArray) for (const key of Object.keys(meshes)) if (!meshes[key].isMesh) delete meshes[key];\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: ref\n  }, /*#__PURE__*/React.createElement(Composer, {\n    components: (isArray ? meshes : Object.values(meshes)).map(({\n      geometry,\n      material\n    }) => /*#__PURE__*/React.createElement(Instances, _extends({\n      key: geometry.uuid,\n      geometry: geometry,\n      material: material\n    }, props)))\n  }, args => isArray ? children(...args) : children(Object.keys(meshes).filter(key => meshes[key].isMesh).reduce((acc, key, i) => ({\n    ...acc,\n    [key]: args[i]\n  }), {}))));\n});\n\n/** Idea and implementation for global instances and instanced attributes by\n/*  Matias Gonzalez Fernandez https://x.com/matiNotFound\n/*  and Paul Henschel https://x.com/0xca0a\n*/\nfunction createInstances() {\n  const context = /*#__PURE__*/React.createContext(null);\n  return [/*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Instances, _extends({\n    ref: fref,\n    context: context\n  }, props))), /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React.createElement(Instance, _extends({\n    ref: fref,\n    context: context\n  }, props)))];\n}\nconst InstancedAttribute = /*#__PURE__*/React.forwardRef(({\n  name,\n  defaultValue,\n  normalized,\n  usage = THREE.DynamicDrawUsage\n}, fref) => {\n  const ref = React.useRef(null);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    const parent = ref.current.__r3f.parent;\n    parent.geometry.attributes[name] = ref.current;\n    const value = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n    const array = Array.from({\n      length: parent.userData.limit\n    }, () => value).flat();\n    ref.current.array = new Float32Array(array);\n    ref.current.itemSize = value.length;\n    ref.current.count = array.length / ref.current.itemSize;\n    return () => {\n      delete parent.geometry.attributes[name];\n    };\n  }, [name]);\n  let iterations = 0;\n  useFrame(() => {\n    const parent = ref.current.__r3f.parent;\n    if (parent.userData.frames === Infinity || iterations < parent.userData.frames) {\n      for (let i = 0; i < parent.userData.instances.length; i++) {\n        const instance = parent.userData.instances[i].current;\n        const value = instance[name];\n        if (value !== undefined) {\n          ref.current.set(Array.isArray(value) ? value : typeof value.toArray === 'function' ? value.toArray() : [value], i * ref.current.itemSize);\n          ref.current.needsUpdate = true;\n        }\n      }\n      iterations++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"instancedBufferAttribute\", {\n    ref: ref,\n    usage: usage,\n    normalized: normalized\n  });\n});\n\nexport { Instance, InstancedAttribute, Instances, Merged, PositionMesh, createInstances };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Shape } from 'three';\nimport { toCreasedNormals } from 'three-stdlib';\n\nconst eps = 0.00001;\nfunction createShape(width, height, radius0) {\n  const shape = new Shape();\n  const radius = radius0 - eps;\n  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\n  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);\n  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n  return shape;\n}\nconst RoundedBox = /* @__PURE__ */React.forwardRef(function RoundedBox({\n  args: [width = 1, height = 1, depth = 1] = [],\n  radius = 0.05,\n  steps = 1,\n  smoothness = 4,\n  bevelSegments = 4,\n  creaseAngle = 0.4,\n  children,\n  ...rest\n}, ref) {\n  const shape = React.useMemo(() => createShape(width, height, radius), [width, height, radius]);\n  const params = React.useMemo(() => ({\n    depth: depth - radius * 2,\n    bevelEnabled: true,\n    bevelSegments: bevelSegments * 2,\n    steps,\n    bevelSize: radius - eps,\n    bevelThickness: radius,\n    curveSegments: smoothness\n  }), [depth, radius, smoothness]);\n  const geomRef = React.useRef(null);\n  React.useLayoutEffect(() => {\n    if (geomRef.current) {\n      geomRef.current.center();\n      toCreasedNormals(geomRef.current, creaseAngle);\n    }\n  }, [shape, params]);\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref\n  }, rest), /*#__PURE__*/React.createElement(\"extrudeGeometry\", {\n    ref: geomRef,\n    args: [shape, params]\n  }), children);\n});\n\nexport { RoundedBox };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\"),\n  shim = require(\"use-sync-external-store/shim\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useSyncExternalStore = shim.useSyncExternalStore,\n  useRef = React.useRef,\n  useEffect = React.useEffect,\n  useMemo = React.useMemo,\n  useDebugValue = React.useDebugValue;\nexports.useSyncExternalStoreWithSelector = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n  selector,\n  isEqual\n) {\n  var instRef = useRef(null);\n  if (null === instRef.current) {\n    var inst = { hasValue: !1, value: null };\n    instRef.current = inst;\n  } else inst = instRef.current;\n  instRef = useMemo(\n    function () {\n      function memoizedSelector(nextSnapshot) {\n        if (!hasMemo) {\n          hasMemo = !0;\n          memoizedSnapshot = nextSnapshot;\n          nextSnapshot = selector(nextSnapshot);\n          if (void 0 !== isEqual && inst.hasValue) {\n            var currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSnapshot))\n              return (memoizedSelection = currentSelection);\n          }\n          return (memoizedSelection = nextSnapshot);\n        }\n        currentSelection = memoizedSelection;\n        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n        var nextSelection = selector(nextSnapshot);\n        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n          return (memoizedSnapshot = nextSnapshot), currentSelection;\n        memoizedSnapshot = nextSnapshot;\n        return (memoizedSelection = nextSelection);\n      }\n      var hasMemo = !1,\n        memoizedSnapshot,\n        memoizedSelection,\n        maybeGetServerSnapshot =\n          void 0 === getServerSnapshot ? null : getServerSnapshot;\n      return [\n        function () {\n          return memoizedSelector(getSnapshot());\n        },\n        null === maybeGetServerSnapshot\n          ? void 0\n          : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n      ];\n    },\n    [getSnapshot, getServerSnapshot, selector, isEqual]\n  );\n  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n  useEffect(\n    function () {\n      inst.hasValue = !0;\n      inst.value = value;\n    },\n    [value]\n  );\n  useDebugValue(value);\n  return value;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","import React from 'react';\nimport { create } from 'zustand';\n\nvar _window$document, _window$navigator;\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative') ? React.useLayoutEffect : React.useEffect;\n\nfunction tunnel() {\n  const useStore = create(set => ({\n    current: new Array(),\n    version: 0,\n    set\n  }));\n  return {\n    In: ({\n      children\n    }) => {\n      const set = useStore(state => state.set);\n      const version = useStore(state => state.version);\n      /* When this component mounts, we increase the store's version number.\n      This will cause all existing rats to re-render (just like if the Out component\n      were mapping items to a list.) The re-rendering will cause the final \n      order of rendered components to match what the user is expecting. */\n\n      useIsomorphicLayoutEffect(() => {\n        set(state => ({\n          version: state.version + 1\n        }));\n      }, []);\n      /* Any time the children _or_ the store's version number change, insert\n      the specified React children into the list of rats. */\n\n      useIsomorphicLayoutEffect(() => {\n        set(({\n          current\n        }) => ({\n          current: [...current, children]\n        }));\n        return () => set(({\n          current\n        }) => ({\n          current: current.filter(c => c !== children)\n        }));\n      }, [children, version]);\n      return null;\n    },\n    Out: () => {\n      const current = useStore(state => state.current);\n      return /*#__PURE__*/React.createElement(React.Fragment, null, current);\n    }\n  };\n}\n\nexport { tunnel as default };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { context, useThree, createPortal, useFrame } from '@react-three/fiber';\nimport tunnel from 'tunnel-rat';\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst col = /* @__PURE__ */new THREE.Color();\nconst tracked = /* @__PURE__ */tunnel();\n\n/**\n * In `@react-three/fiber` after `v8.0.0` but prior to `v8.1.0`, `state.size` contained only dimension\n * information. After `v8.1.0`, position information (`top`, `left`) was added\n *\n * @todo remove this when drei supports v9 and up\n */\n\nfunction isNonLegacyCanvasSize(size) {\n  return 'top' in size;\n}\nfunction computeContainerPosition(canvasSize, trackRect) {\n  const {\n    right,\n    top,\n    left: trackLeft,\n    bottom: trackBottom,\n    width,\n    height\n  } = trackRect;\n  const isOffscreen = trackRect.bottom < 0 || top > canvasSize.height || right < 0 || trackRect.left > canvasSize.width;\n  if (isNonLegacyCanvasSize(canvasSize)) {\n    const canvasBottom = canvasSize.top + canvasSize.height;\n    const bottom = canvasBottom - trackBottom;\n    const left = trackLeft - canvasSize.left;\n    return {\n      position: {\n        width,\n        height,\n        left,\n        top,\n        bottom,\n        right\n      },\n      isOffscreen\n    };\n  }\n  // Fall back on old behavior if r3f < 8.1.0\n  const bottom = canvasSize.height - trackBottom;\n  return {\n    position: {\n      width,\n      height,\n      top,\n      left: trackLeft,\n      bottom,\n      right\n    },\n    isOffscreen\n  };\n}\nfunction prepareSkissor(state, {\n  left,\n  bottom,\n  width,\n  height\n}) {\n  let autoClear;\n  const aspect = width / height;\n  if (isOrthographicCamera(state.camera)) {\n    if (!state.camera.manual) {\n      if (state.camera.left !== width / -2 || state.camera.right !== width / 2 || state.camera.top !== height / 2 || state.camera.bottom !== height / -2) {\n        Object.assign(state.camera, {\n          left: width / -2,\n          right: width / 2,\n          top: height / 2,\n          bottom: height / -2\n        });\n        state.camera.updateProjectionMatrix();\n      }\n    } else {\n      state.camera.updateProjectionMatrix();\n    }\n  } else if (state.camera.aspect !== aspect) {\n    state.camera.aspect = aspect;\n    state.camera.updateProjectionMatrix();\n  }\n  autoClear = state.gl.autoClear;\n  state.gl.autoClear = false;\n  state.gl.setViewport(left, bottom, width, height);\n  state.gl.setScissor(left, bottom, width, height);\n  state.gl.setScissorTest(true);\n  return autoClear;\n}\nfunction finishSkissor(state, autoClear) {\n  // Restore the default state\n  state.gl.setScissorTest(false);\n  state.gl.autoClear = autoClear;\n}\nfunction clear(state) {\n  state.gl.getClearColor(col);\n  state.gl.setClearColor(col, state.gl.getClearAlpha());\n  state.gl.clear(true, true);\n}\nfunction Container({\n  visible = true,\n  canvasSize,\n  scene,\n  index,\n  children,\n  frames,\n  rect,\n  track\n}) {\n  const rootState = useThree();\n  const [isOffscreen, setOffscreen] = React.useState(false);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n      if (track) rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n    if (rect.current) {\n      const {\n        position,\n        isOffscreen: _isOffscreen\n      } = computeContainerPosition(canvasSize, rect.current);\n      if (isOffscreen !== _isOffscreen) setOffscreen(_isOffscreen);\n      if (visible && !isOffscreen && rect.current) {\n        const autoClear = prepareSkissor(state, position);\n        // When children are present render the portalled scene, otherwise the default scene\n        state.gl.render(children ? state.scene : scene, state.camera);\n        finishSkissor(state, autoClear);\n      }\n    }\n  }, index);\n  React.useLayoutEffect(() => {\n    const curRect = rect.current;\n    if (curRect && (!visible || !isOffscreen)) {\n      // If the view is not visible clear it once, but stop rendering afterwards!\n      const {\n        position\n      } = computeContainerPosition(canvasSize, curRect);\n      const autoClear = prepareSkissor(rootState, position);\n      clear(rootState);\n      finishSkissor(rootState, autoClear);\n    }\n  }, [visible, isOffscreen]);\n  React.useEffect(() => {\n    if (!track) return;\n    const curRect = rect.current;\n    // Connect the event layer to the tracking element\n    const old = rootState.get().events.connected;\n    rootState.setEvents({\n      connected: track.current\n    });\n    return () => {\n      if (curRect) {\n        const {\n          position\n        } = computeContainerPosition(canvasSize, curRect);\n        const autoClear = prepareSkissor(rootState, position);\n        clear(rootState);\n        finishSkissor(rootState, autoClear);\n      }\n      rootState.setEvents({\n        connected: old\n      });\n    };\n  }, [track]);\n  React.useEffect(() => {\n    if (isNonLegacyCanvasSize(canvasSize)) return;\n    console.warn('Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. ' + 'Upgrade to @react-three/fiber ^8.1.0 for support.\\n See https://github.com/pmndrs/drei/issues/944');\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: () => null\n  }));\n}\nconst CanvasView = /* @__PURE__ */React.forwardRef(({\n  track,\n  visible = true,\n  index = 1,\n  id,\n  style,\n  className,\n  frames = Infinity,\n  children,\n  ...props\n}, fref) => {\n  var _rect$current, _rect$current2, _rect$current3, _rect$current4;\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const [ready, toggle] = React.useReducer(() => true, false);\n  const compute = React.useCallback((event, state) => {\n    if (rect.current && track && track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect, track]);\n  React.useEffect(() => {\n    var _track$current2;\n    // We need the tracking elements bounds beforehand in order to inject it into the portal\n    if (track) rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect();\n    // And now we can proceed\n    toggle();\n  }, [track]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: fref\n  }, props), ready && createPortal(/*#__PURE__*/React.createElement(Container, {\n    visible: visible,\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: (_rect$current = rect.current) == null ? void 0 : _rect$current.width,\n      height: (_rect$current2 = rect.current) == null ? void 0 : _rect$current2.height,\n      // @ts-ignore\n      top: (_rect$current3 = rect.current) == null ? void 0 : _rect$current3.top,\n      // @ts-ignore\n      left: (_rect$current4 = rect.current) == null ? void 0 : _rect$current4.left\n    }\n  }));\n});\nconst HtmlView = /* @__PURE__ */React.forwardRef(({\n  as: El = 'div',\n  id,\n  visible,\n  className,\n  style,\n  index = 1,\n  track,\n  frames = Infinity,\n  children,\n  ...props\n}, fref) => {\n  const uuid = React.useId();\n  const ref = React.useRef(null);\n  React.useImperativeHandle(fref, () => ref.current);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(El, _extends({\n    ref: ref,\n    id: id,\n    className: className,\n    style: style\n  }, props)), /*#__PURE__*/React.createElement(tracked.In, null, /*#__PURE__*/React.createElement(CanvasView, {\n    visible: visible,\n    key: uuid,\n    track: ref,\n    frames: frames,\n    index: index\n  }, children)));\n});\nconst View = /* @__PURE__ */(() => {\n  const _View = /*#__PURE__*/React.forwardRef((props, fref) => {\n    // If we're inside a canvas we should be able to access the context store\n    const store = React.useContext(context);\n    // If that's not the case we render a tunnel\n    if (!store) return /*#__PURE__*/React.createElement(HtmlView, _extends({\n      ref: fref\n    }, props));\n    // Otherwise a plain canvas-view\n    else return /*#__PURE__*/React.createElement(CanvasView, _extends({\n      ref: fref\n    }, props));\n  });\n  _View.Port = () => /*#__PURE__*/React.createElement(tracked.Out, null);\n  return _View;\n})();\n\nexport { View };\n","import { create } from \"zustand\";\n\nconst textures = [\n  \"/assets/texture/1.webp\",\n  \"/assets/texture/2.webp\",\n  \"/assets/texture/3.webp\",\n];\n\ninterface Store {\n  index: number;\n  texture: string;\n  setIndex: (num: number) => void;\n}\n\nexport const useStore = create<Store>(set => ({\n  index: 2,\n  texture: textures[2],\n  setIndex: (num: number) => set({ index: num, texture: textures[num] }),\n}));\n","import { useTexture } from \"@react-three/drei\";\nimport type { MeshMatcapMaterialProps } from \"@react-three/fiber\";\nimport { forwardRef } from \"react\";\nimport { MeshMatcapMaterial } from \"three\";\nimport { useStore } from \"../store/useStore\";\n\nexport const CustomeMaterial = forwardRef<\n  MeshMatcapMaterial,\n  MeshMatcapMaterialProps\n>((props, ref) => {\n  const matcap = useStore(x => x.texture);\n  const texture = useTexture(matcap);\n  return (\n    <meshMatcapMaterial\n      {...props}\n      ref={ref}\n      matcap={texture}\n    ></meshMatcapMaterial>\n  );\n});\n","/*!\n * @gsap/react 2.1.2\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\nimport { useEffect, useLayoutEffect, useRef } from \"react\";\nimport gsap from \"gsap\";\n\nlet useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? useLayoutEffect : useEffect,\n    isConfig = value => value && !Array.isArray(value) && typeof(value) === \"object\",\n    emptyArray = [],\n    defaultConfig = {},\n    _gsap = gsap; // accommodates situations where different versions of GSAP may be loaded, so a user can gsap.registerPlugin(useGSAP);\n\nexport const useGSAP = (callback, dependencies = emptyArray) => {\n  let config = defaultConfig;\n  if (isConfig(callback)) {\n    config = callback;\n    callback = null;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  } else if (isConfig(dependencies)) {\n    config = dependencies;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  }\n  (callback && typeof callback !== \"function\") && console.warn(\"First parameter must be a function or config object\");\n  const { scope, revertOnUpdate } = config,\n        mounted = useRef(false),\n        context = useRef(_gsap.context(() => { }, scope)),\n        contextSafe = useRef((func) => context.current.add(null, func)),\n        deferCleanup = dependencies && dependencies.length && !revertOnUpdate;\n  deferCleanup && useIsomorphicLayoutEffect(() => {\n    mounted.current = true;\n    return () => context.current.revert();\n  }, emptyArray);\n  useIsomorphicLayoutEffect(() => {\n    callback && context.current.add(callback, scope);\n    if (!deferCleanup || !mounted.current) { // React renders bottom-up, thus there could be hooks with dependencies that run BEFORE the component mounts, thus cleanup wouldn't occur since a hook with an empty dependency Array would only run once the component mounts.\n      return () => context.current.revert();\n    }\n  }, dependencies);\n  return { context: context.current, contextSafe: contextSafe.current };\n};\nuseGSAP.register = core => { _gsap = core; };\nuseGSAP.headless = true; // doesn't require the window to be registered.\n","import { Center } from \"@react-three/drei\";\n\nimport { useCallback, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item1 = () => {\n  const refList = useRef<THREE.Mesh[]>([]);\n\n  const getRef = useCallback((mesh: THREE.Mesh) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  useGSAP(() => {\n    if (refList.current.length === 0) return;\n\n    gsap\n      .timeline({\n        repeat: -1,\n        repeatDelay: 0.5,\n      })\n      .to(\n        refList.current.map(item => item.rotation),\n        {\n          y: `+=${Math.PI * 2}`,\n          x: `-=${Math.PI * 2}`,\n          duration: 1.5,\n          stagger: {\n            each: 0.15,\n          },\n        }\n      );\n  }, []);\n  return (\n    <Center>\n      <group>\n        {Array.from({ length: 4 }).map((_, index) => {\n          return (\n            <mesh key={index} ref={getRef}>\n              <torusGeometry args={[(index + 1) * 0.5, 0.1]}></torusGeometry>\n              <CustomeMaterial></CustomeMaterial>\n            </mesh>\n          );\n        })}\n      </group>\n    </Center>\n  );\n};\n","import { Center, Instance, Instances } from \"@react-three/drei\";\nimport { useCallback, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item2 = () => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  const refList = useRef<THREE.Mesh[]>([]);\n\n  const getRef = useCallback((mesh: THREE.Mesh) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  useGSAP(() => {\n    gsap\n      .timeline()\n      .to(\n        refList.current.map(item => item.rotation),\n        {\n          y: `+=${Math.PI * 2}`,\n          repeat: -1,\n          duration: 6,\n\n          ease: \"none\",\n        }\n      )\n      .to(\n        groupRef.current.rotation,\n        {\n          z: Math.PI * 2,\n          duration: 24,\n          ease: \"none\",\n          repeat: -1,\n        },\n        0\n      );\n  }, []);\n\n  const radius = 3;\n\n  return (\n    <Center>\n      <group rotation={[0, 0, 0]}>\n        <group rotation={[0, 0, 0]} scale={0.6} ref={groupRef}>\n          <Instances>\n            <boxGeometry args={[1, 0.2, 1]}></boxGeometry>\n            <CustomeMaterial></CustomeMaterial>\n            {Array.from({ length: 20 }).map((_, index) => {\n              return (\n                <group\n                  key={index}\n                  rotation={[0, 0, (index / 20) * 2 * Math.PI]}\n                  position={[\n                    Math.cos((index / 20) * 2 * Math.PI) * radius,\n                    Math.sin((index / 20) * 2 * Math.PI) * radius,\n                    0,\n                  ]}\n                >\n                  <Instance ref={getRef} />\n                </group>\n              );\n            })}\n          </Instances>\n        </group>\n      </group>\n    </Center>\n  );\n};\n","import { Center, Instance, Instances } from \"@react-three/drei\";\nimport { useRef } from \"react\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { type GroupProps, useFrame } from \"@react-three/fiber\";\n\nconst radius = 3;\nconst count = 8;\n\nfunction Item(props: GroupProps) {\n  const ref = useRef<THREE.Group>(null);\n\n  useFrame(() => {\n    if (ref.current) {\n      ref.current.rotation.x += 0.01;\n      ref.current.rotation.y += 0.01;\n      ref.current.rotation.z += 0.01;\n    }\n  });\n\n  return (\n    <group {...props}>\n      <group ref={ref} rotation={[0, Math.PI / count, Math.PI / 2]}>\n        <Instance />\n      </group>\n    </group>\n  );\n}\n\nexport const Item3 = () => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  useFrame(() => {\n    if (groupRef.current) {\n      groupRef.current.rotation.z -= 0.01;\n    }\n  });\n\n  return (\n    <Center>\n      <group>\n        <group scale={0.6} ref={groupRef}>\n          <Instances>\n            <cylinderGeometry args={[1, 1, 0.1, 64]}></cylinderGeometry>\n            <CustomeMaterial></CustomeMaterial>\n            {Array.from({ length: 8 }).map((_, index) => {\n              return (\n                <Item\n                  position={[\n                    radius *\n                      Math.cos((index * 2 * Math.PI) / count + Math.PI / 4),\n                    radius *\n                      Math.sin((index * 2 * Math.PI) / count + Math.PI / 4),\n                    0,\n                  ]}\n                  rotation={[0, 0, (index * 2 * Math.PI) / count]}\n                  key={index}\n                ></Item>\n              );\n            })}\n          </Instances>\n        </group>\n      </group>\n    </Center>\n  );\n};\n","import { Center } from \"@react-three/drei\";\nimport { useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item4 = () => {\n  const ring1Ref = useRef<THREE.Mesh>(null);\n  const ring2Ref = useRef<THREE.Mesh>(null);\n  const cone1Ref = useRef<THREE.Mesh>(null);\n  const cone2Ref = useRef<THREE.Mesh>(null);\n  const groupRef = useRef<THREE.Group>(null);\n\n  useGSAP(() => {\n    if (\n      ring1Ref.current &&\n      ring2Ref.current &&\n      cone1Ref.current &&\n      cone2Ref.current &&\n      groupRef.current\n    ) {\n      gsap\n        .timeline({\n          repeat: -1,\n        })\n        .to(\n          ring1Ref.current.rotation,\n          {\n            z: `+=${Math.PI * 2}`,\n            x: `+=${Math.PI * 2}`,\n\n            duration: 4,\n            ease: \"none\",\n          },\n          0\n        )\n        .to(\n          ring2Ref.current.rotation,\n          {\n            z: `-=${Math.PI * 2}`,\n            x: `-=${Math.PI * 2}`,\n\n            ease: \"none\",\n            duration: 4,\n          },\n          0\n        )\n        .to(\n          groupRef.current.rotation,\n          {\n            y: Math.PI * 2,\n            duration: 4,\n            ease: \"none\",\n          },\n          0\n        );\n    }\n  }, []);\n  return (\n    <Center ref={groupRef}>\n      <mesh ref={ring1Ref}>\n        <torusGeometry args={[2.1, 0.1]}></torusGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n      <mesh ref={ring2Ref} rotation={[Math.PI / 2, 0, 0]}>\n        <torusGeometry args={[1.8, 0.1]}></torusGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n      <group scale={0.8}>\n        <mesh position={[0, 1, 0]} rotation={[0, 0, 0]} ref={cone1Ref}>\n          <coneGeometry args={[1, 1.41, 4]}></coneGeometry>\n          <CustomeMaterial></CustomeMaterial>\n        </mesh>\n        <mesh position={[0, -1, 0]} rotation={[-Math.PI, 0, 0]} ref={cone2Ref}>\n          <coneGeometry args={[1, 1.41, 4]}></coneGeometry>\n          <CustomeMaterial></CustomeMaterial>\n        </mesh>\n      </group>\n    </Center>\n  );\n};\n","import { Center, Instance, Instances } from \"@react-three/drei\";\nimport { useMemo, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item5 = () => {\n  const groupRef = useRef<THREE.Group>(null);\n  const firstLayerRef = useRef<THREE.Group>(null);\n  const secondLayerRef = useRef<THREE.Group>(null);\n  const thirdLayerRef = useRef<THREE.Group>(null);\n\n  const blockSize = 1;\n  const gap = 0.1;\n  const distance = blockSize + gap;\n\n  const layers = useMemo(() => {\n    const layer1 = [];\n    const layer2 = [];\n    const layer3 = [];\n\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        for (let z = -1; z <= 1; z++) {\n          if (z === -1) {\n            layer1.push(\n              new THREE.Vector3(x * distance, y * distance, z * distance)\n            );\n          } else if (z === 0) {\n            layer2.push(\n              new THREE.Vector3(x * distance, y * distance, z * distance)\n            );\n          } else {\n            layer3.push(\n              new THREE.Vector3(x * distance, y * distance, z * distance)\n            );\n          }\n        }\n      }\n    }\n\n    return [layer1, layer2, layer3];\n  }, [distance]);\n\n  useGSAP(() => {\n    if (\n      firstLayerRef.current &&\n      secondLayerRef.current &&\n      thirdLayerRef.current &&\n      groupRef.current\n    ) {\n      gsap\n        .timeline({\n          repeat: -1,\n        })\n        .to(firstLayerRef.current.rotation, {\n          z: Math.PI,\n          duration: 1.5,\n        })\n        .to(\n          secondLayerRef.current.rotation,\n          {\n            z: Math.PI,\n            duration: 1.5,\n            delay: 0.15,\n          },\n          \"<\"\n        )\n        .to(\n          thirdLayerRef.current.rotation,\n          {\n            z: Math.PI,\n            duration: 1.5,\n            delay: 0.25,\n          },\n          \"<\"\n        )\n        .to(\n          groupRef.current.rotation,\n          {\n            y: Math.PI * 2,\n            duration: 1.75,\n          },\n          0\n        );\n    }\n  }, []);\n\n  return (\n    <Center>\n      <group rotation={[0, 0, Math.PI / 8]} scale={1.2}>\n        <group rotation={[0, Math.PI / 2, 0]} scale={0.6} ref={groupRef}>\n          <Instances>\n            <boxGeometry args={[1, 1, 1]}></boxGeometry>\n            <CustomeMaterial></CustomeMaterial>\n\n            <group ref={firstLayerRef}>\n              {layers[0].map((item, index) => {\n                return <Instance key={index} position={item} />;\n              })}\n            </group>\n            <group ref={secondLayerRef}>\n              {layers[1].map((item, index) => {\n                return <Instance key={index} position={item} />;\n              })}\n            </group>\n            <group ref={thirdLayerRef}>\n              {layers[2].map((item, index) => {\n                return <Instance key={index} position={item} />;\n              })}\n            </group>\n          </Instances>\n        </group>\n      </group>\n    </Center>\n  );\n};\n","import { useMemo, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nclass SemiCircleCurve extends THREE.Curve<THREE.Vector3> {\n  scale: number;\n  constructor(scale = 1) {\n    super();\n    this.scale = scale;\n  }\n\n  getPoint(t: number) {\n    const radians = t * Math.PI;\n    const x = Math.cos(radians) * this.scale;\n    const y = Math.sin(radians) * this.scale;\n    return new THREE.Vector3(x, y, 0);\n  }\n}\n\nexport const Item6 = () => {\n  const path = useMemo(() => {\n    return new SemiCircleCurve(2);\n  }, []);\n\n  const path2 = useMemo(() => {\n    return new SemiCircleCurve(2.02);\n  }, []);\n\n  const ballRef = useRef<THREE.Mesh>(null);\n  const tubeRef = useRef<THREE.Mesh>(null);\n  const t = useRef(0);\n\n  useGSAP(() => {\n    console.log(\"gsap\", ballRef);\n\n    if (!ballRef.current) return;\n    if (!tubeRef.current) return;\n\n    gsap\n      .timeline({})\n      .to(t, {\n        current: 2,\n        duration: 1.5,\n        ease: \"none\",\n        repeat: -1,\n        onUpdate: () => {\n          if (!ballRef.current) return;\n\n          const point = path2.getPoint(t.current);\n          ballRef.current.position.set(point.x, point.y, point.z);\n        },\n      })\n      .to(\n        tubeRef.current.rotation,\n        {\n          z: -Math.PI,\n          ease: \"back.out\",\n          duration: 1.5,\n          repeat: -1,\n        },\n        0\n      );\n  }, []);\n\n  return (\n    <group scale={0.8}>\n      <mesh ref={ballRef} position={[0, 2, 0]}>\n        <sphereGeometry args={[0.7]}></sphereGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n\n      <mesh rotation={[0, 0, Math.PI]} ref={tubeRef}>\n        <tubeGeometry args={[path, 20, 0.8, 8, false]}></tubeGeometry>\n        <CustomeMaterial side={THREE.DoubleSide}></CustomeMaterial>\n      </mesh>\n    </group>\n  );\n};\n","import { Center, RoundedBox } from \"@react-three/drei\";\nimport { useCallback, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item7 = () => {\n  const refList = useRef<THREE.Mesh[]>([]);\n\n  const getRef = useCallback((mesh: THREE.Mesh) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  useGSAP(() => {\n    if (refList.current.length === 0) return;\n\n    gsap.to(\n      refList.current.map(i => i.rotation),\n      {\n        y: `+=${Math.PI / 2}`,\n        repeat: -1,\n        ease: \"back\",\n        stagger: {\n          each: 0.1,\n        },\n        duration: 1,\n      }\n    );\n  }, []);\n\n  return (\n    <Center scale={3} rotation={[Math.PI / 10, Math.PI / 4, 0]}>\n      {Array.from({ length: 5 }).map((_, index) => {\n        return (\n          <RoundedBox\n            ref={getRef}\n            args={[1, 0.1, 1]}\n            key={index}\n            radius={0.02}\n            position={[0, (index - 1) * 0.1, 0]}\n          >\n            <CustomeMaterial></CustomeMaterial>\n          </RoundedBox>\n        );\n      })}\n    </Center>\n  );\n};\n","import { Center } from \"@react-three/drei\";\nimport { useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item8 = () => {\n  const ref1 = useRef<THREE.Mesh>(null);\n  const ref2 = useRef<THREE.Mesh>(null);\n  const groupRef = useRef<THREE.Group>(null);\n\n  useGSAP(() => {\n    if (!ref1.current || !ref2.current || !groupRef.current) return;\n\n    gsap\n      .timeline({\n        defaults: {\n          ease: \"elastic\",\n          repeat: -1,\n        },\n      })\n      .to(ref1.current.position, {\n        keyframes: [\n          {\n            x: -1.5,\n            duration: 2,\n          },\n          {\n            x: 1.5,\n            duration: 2,\n          },\n        ],\n        repeat: -1,\n      })\n      .to(\n        ref2.current.position,\n        {\n          keyframes: [\n            {\n              x: 1.5,\n              duration: 2,\n            },\n            {\n              x: -1.5,\n              duration: 2,\n            },\n          ],\n          repeat: -1,\n        },\n\n        0\n      )\n      .to(\n        groupRef.current.rotation,\n        {\n          z: `${Math.PI}`,\n          duration: 4,\n        },\n        0\n      );\n  }, []);\n\n  return (\n    <Center ref={groupRef}>\n      <mesh position={[1.5, 1, 0]} rotation={[Math.PI / 2, 0, 0]} ref={ref1}>\n        <cylinderGeometry args={[0.5, 0.5]}></cylinderGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n\n      <mesh>\n        <boxGeometry args={[4, 0.4, 1]}></boxGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n\n      <mesh position={[-1.5, -1, 0]} rotation={[Math.PI / 2, 0, 0]} ref={ref2}>\n        <cylinderGeometry args={[0.5, 0.5]}></cylinderGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n    </Center>\n  );\n};\n","import { Center, Instance, Instances } from \"@react-three/drei\";\nimport { useCallback, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item9 = () => {\n  const refList = useRef<THREE.Mesh[]>([]);\n\n  const getRef = useCallback((mesh: THREE.Mesh) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  useGSAP(() => {\n    if (refList.current.length === 0) return;\n\n    refList.current.forEach((mesh, index) => {\n      if (mesh) {\n        gsap.to(mesh.scale, {\n          x: 0.3,\n          z: 0.3,\n          delay: 0.25 * index,\n          repeat: -1,\n          yoyo: true,\n          ease: \"sine.inOut\",\n          duration: 1,\n        });\n      }\n    });\n  }, []);\n  return (\n    <Center>\n      <group rotation={[0, 0, Math.PI / 4]}>\n        <group rotation={[0, 0, Math.PI / 2]}>\n          <Instances>\n            <cylinderGeometry args={[1, 1, 0.2, 64]}></cylinderGeometry>\n            <CustomeMaterial></CustomeMaterial>\n            {Array.from({ length: 10 }).map((_, index) => {\n              return (\n                <Instance\n                  ref={getRef}\n                  key={index}\n                  position={[0, 0.5 * index, 2]}\n                />\n              );\n            })}\n          </Instances>\n        </group>\n      </group>\n    </Center>\n  );\n};\n","import { Center, Instance, Instances } from \"@react-three/drei\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item10 = () => {\n  const refList = useRef<THREE.Group[]>([]);\n\n  const geometry = useMemo(() => {\n    const shape = new THREE.Shape();\n\n    // Outer arc\n    shape.absarc(0, 0, 1, 0, Math.PI / 2, false);\n    shape.lineTo(Math.cos(Math.PI / 2) * 0.5, Math.sin(Math.PI / 2) * 0.5);\n\n    // Inner arc\n    shape.absarc(0, 0, 0.2, Math.PI / 2, 0, true);\n    shape.lineTo(1, 0);\n\n    const extrudeSettings = {\n      steps: 1,\n      depth: 0.3,\n      bevelEnabled: false,\n    };\n\n    return new THREE.ExtrudeGeometry(shape, extrudeSettings);\n  }, []);\n\n  const getRef = useCallback((mesh: THREE.Group) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  useGSAP(() => {\n    if (refList.current.length === 0) return;\n\n    gsap\n      .timeline({\n        repeat: -1,\n\n        repeatDelay: 0.5,\n      })\n\n      .to(\n        refList.current.map(item => item.position),\n        {\n          x: index => {\n            return `+=${Math.sin((index / 4) * 2 * Math.PI) * 0.5}`;\n          },\n          z: index => {\n            return `+=${Math.cos((index / 4) * 2 * Math.PI) * 0.5}`;\n          },\n          duration: 1.5,\n          ease: \"power1.out\",\n        }\n      )\n      .to(\n        refList.current.map(item => item.rotation),\n        {\n          z: `+=${Math.PI}`,\n          duration: 2,\n        },\n        0\n      )\n      .to(\n        refList.current.map(item => item.position),\n        {\n          x: 0,\n          z: 0,\n          duration: 1.5,\n        },\n        1\n      );\n  }, []);\n  return (\n    <Center scale={1.6}>\n      <group rotation={[Math.PI / 2, 0, 0]}>\n        <group>\n          <Instances geometry={geometry}>\n            <CustomeMaterial side={THREE.DoubleSide}></CustomeMaterial>\n            {Array.from({ length: 4 }).map((_, index) => {\n              return (\n                <group\n                  ref={getRef}\n                  key={index}\n                  rotation={[0, (index * Math.PI) / 2, 0]}\n                >\n                  <Instance rotation={[Math.PI / 2, 0, 0]} />\n                </group>\n              );\n            })}\n          </Instances>\n        </group>\n      </group>\n    </Center>\n  );\n};\n","import { Instance, Instances } from \"@react-three/drei\";\nimport { useFrame } from \"@react-three/fiber\";\nimport { useRef, useMemo, useCallback } from \"react\";\nimport * as THREE from \"three\";\nimport { CustomeMaterial } from \"./material\";\n\n// Inspired by https://www.shadertoy.com/view/sdsXWr\nexport const Item11 = () => {\n  const refList = useRef<THREE.Mesh[]>([]);\n\n  const getRef = useCallback((mesh: THREE.Mesh) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  const rotate = useMemo(\n    () => (a: number) => {\n      const s = Math.sin(a);\n      const c = Math.cos(a);\n      return new THREE.Matrix3().set(c, -s, 0, s, c, 0, 0, 0, 1);\n    },\n    []\n  );\n\n  useFrame(({ clock }) => {\n    if (refList.current.length === 0) return;\n\n    const time = clock.getElapsedTime();\n    const angle = Math.sin(time * 4);\n    const angle1 = Math.min(0, angle * 0.5);\n    const angle5 = Math.max(0, angle * 0.5);\n\n    const positions = [\n      {\n        sphere: refList.current[0],\n        vector: new THREE.Vector3(-4, -4, 0),\n        angle: angle1,\n      },\n      {\n        sphere: refList.current[1],\n        vector: new THREE.Vector3(-2, -4, 0),\n        angle: (angle + angle1) * 0.05,\n      },\n      {\n        sphere: refList.current[2],\n        vector: new THREE.Vector3(0, -4, 0),\n        angle: angle5 * 0.05,\n      },\n      {\n        sphere: refList.current[3],\n        vector: new THREE.Vector3(2, -4, 0),\n        angle: (angle + angle5) * 0.05,\n      },\n      {\n        sphere: refList.current[4],\n        vector: new THREE.Vector3(4, -4, 0),\n        angle: angle5,\n      },\n    ];\n\n    positions.forEach(({ sphere, vector, angle }) => {\n      const newPosition = vector.applyMatrix3(rotate(angle));\n      newPosition.y += 3;\n      sphere.position.copy(newPosition);\n    });\n  });\n\n  return (\n    <group scale={0.55}>\n      <Instances>\n        <sphereGeometry args={[1, 32, 32]} />\n        <CustomeMaterial />\n        {Array.from({ length: 5 }).map((_, index) => (\n          <Instance\n            ref={getRef}\n            key={index}\n            position={[(index - 2) * 2, 0, 0]}\n          />\n        ))}\n      </Instances>\n    </group>\n  );\n};\n","import { Instance, Instances } from \"@react-three/drei\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport gsap from \"gsap\";\nimport { CustomeMaterial } from \"./material\";\nimport * as THREE from \"three\";\nimport { useGSAP } from \"@gsap/react\";\n\nexport const Item12 = () => {\n  const refList = useRef<THREE.Mesh[]>([]);\n  const groupRef = useRef<THREE.Group>(null);\n\n  const getRef = useCallback((mesh: THREE.Mesh) => {\n    if (mesh && !refList.current.includes(mesh)) {\n      refList.current.push(mesh);\n    }\n  }, []);\n\n  const arrow = useMemo(() => {\n    const shape = new THREE.Shape();\n    shape.moveTo(0, 0);\n    shape.lineTo(1, 1);\n    shape.lineTo(0.5, 1);\n    shape.lineTo(0.5, 2);\n    shape.lineTo(-0.5, 2);\n    shape.lineTo(-0.5, 1);\n    shape.lineTo(-1, 1);\n    shape.lineTo(0, 0);\n\n    const extrudeSettings = {\n      depth: 0.5,\n      bevelEnabled: false,\n    };\n\n    return new THREE.ExtrudeGeometry(shape, extrudeSettings);\n  }, []);\n\n  useGSAP(() => {\n    if (refList.current.length === 0 || !groupRef.current) return;\n\n    gsap\n      .timeline({})\n      .from(\n        refList.current.map(item => item.rotation),\n        {\n          x: index => {\n            return index === 1 ? Math.PI * 2 : index === 3 ? -Math.PI * 2 : 0;\n          },\n          y: index => {\n            return index === 0 ? Math.PI * 2 : index === 2 ? -Math.PI * 2 : 0;\n          },\n          duration: 5,\n          repeat: -1,\n          ease: \"none\",\n        }\n      )\n      .to(\n        groupRef.current.rotation,\n        {\n          z: Math.PI * 2,\n          duration: 10,\n          repeat: -1,\n          ease: \"none\",\n        },\n        0\n      );\n  }, []);\n\n  const arrows = useMemo(() => {\n    return [\n      { position: [0, 2, -0.25], rotation: [0, 0, 0] },\n      { position: [2, 0, -0.25], rotation: [0, 0, -Math.PI / 2] },\n      { position: [0, -2, -0.25], rotation: [0, 0, -Math.PI] },\n      { position: [-2, 0, -0.25], rotation: [0, 0, Math.PI / 2] },\n    ];\n  }, []);\n\n  return (\n    <group scale={0.7} ref={groupRef}>\n      <mesh>\n        <boxGeometry></boxGeometry>\n        <CustomeMaterial></CustomeMaterial>\n      </mesh>\n      <Instances geometry={arrow}>\n        <CustomeMaterial></CustomeMaterial>\n        {arrows.map((item, index) => {\n          return (\n            <Instance\n              ref={getRef}\n              position={[item.position[0], item.position[1], item.position[2]]}\n              rotation={[item.rotation[0], item.rotation[1], item.rotation[2]]}\n              key={index}\n            />\n          );\n        })}\n      </Instances>\n    </group>\n  );\n};\n","import { View } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { type ReactNode, useEffect } from \"react\";\n\nimport { Item1 } from \"./Rings\";\nimport { Item2 } from \"./Loop\";\nimport { Item3 } from \"./Coins\";\nimport { Item4 } from \"./Core\";\nimport { Item5 } from \"./Rubik\";\nimport { Item6 } from \"./Travel\";\nimport { Item7 } from \"./Stagger\";\nimport { Item8 } from \"./Balance\";\nimport { Item9 } from \"./Pulse\";\nimport { Item10 } from \"./Pie\";\nimport { Item11 } from \"./Cradle\";\nimport { Item12 } from \"./Arrows\";\n\nconst Wrapper = ({ name, children }: { name: string; children: ReactNode }) => {\n  return (\n    <div className=\"relative rounded-md cursor-pointer bg-white/10 card p-[1px]\">\n      <View className=\"flex z-[2] bg-[#171717]  aspect-square  relative rounded-t-md\">\n        {children}\n      </View>\n    </div>\n  );\n};\n\nfunction App({ item }: { item?: string }) {\n  const items = [\n    { component: Item1, name: \"Rings\" },\n    { component: Item2, name: \"Loop\" },\n    { component: Item3, name: \"Coins\" },\n    { component: Item4, name: \"Core\" },\n    { component: Item5, name: \"Rubik\" },\n    { component: Item6, name: \"Travel\" },\n    { component: Item7, name: \"Stagger\" },\n    { component: Item8, name: \"Balance\" },\n    { component: Item9, name: \"Pulse\" },\n    { component: Item10, name: \"Pie\" },\n    { component: Item11, name: \"Newton's Cradle\" },\n    { component: Item12, name: \"Arrows\" },\n  ];\n\n  const showedItem = items.find(i => i.name === item) || items[0];\n\n  return (\n    <>\n      {!item && (\n        <div className=\"min-h-screen text-white bg-[#0c0c0c] select-none background hidden md:block\">\n          <div className=\"container p-5 pb-20 mx-auto \">\n            <div className=\"relative mt-5 overflow-hidden\">\n              <div\n                className=\"grid h-full gap-5 overflow-hidden group grid-clos-1 md:grid-cols-2 lg:grid-cols-4\"\n                data-gird\n              >\n                {items.map((item, index) => (\n                  <Wrapper key={index} name={item.name}>\n                    <item.component />\n                  </Wrapper>\n                ))}\n              </div>\n\n              <div className=\"absolute top-0 left-0 z-20 w-screen h-screen  \">\n                <Canvas\n                  camera={{\n                    zoom: 0.8,\n                  }}\n                  className=\"absolute\"\n                  eventSource={document.getElementById(\"root\")!}\n                >\n                  <View.Port />\n                </Canvas>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n      {item && (\n        <>\n          <div\n            className=\"grid h-full gap-5 overflow-hidden group grid-clos-1 md:grid-cols-2 lg:grid-cols-4\"\n            data-gird\n          >\n            <Wrapper name={item}>\n              <showedItem.component />\n            </Wrapper>\n          </div>\n\n          <div className=\"fixed top-0 left-0 z-20 w-full h-screen pointer-events-none \">\n            <Canvas\n              camera={{\n                zoom: 0.8,\n              }}\n              className=\"fixed\"\n              eventSource={document.getElementById(\"root\")!}\n            >\n              <View.Port />\n            </Canvas>\n          </div>\n        </>\n      )}\n    </>\n  );\n}\n\nexport default App;\n"],"names":["toCreasedNormals","geometry","creaseAngle","creaseDot","hashMultiplier","verts","Vector3","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","x","y","z","resultGeometry","posAttr","vertexMap","i","l","i3","a","b","c","normal","n","vert","hash","normalArray","normAttr","BufferAttribute","otherNormals","k","lk","otherNorm","Center","React.forwardRef","children","disable","disableX","disableY","disableZ","left","right","top","bottom","front","back","onCentered","precise","cacheKey","props","fRef","ref","React.useRef","outer","inner","React.useLayoutEffect","box3","Box3","center","sphere","Sphere","width","height","depth","vAlign","hAlign","dAlign","React.useImperativeHandle","React.createElement","_extends","PropTypes","setUpdateRange","attribute","updateRange","isFunctionChild","value","_instanceLocalMatrix","THREE.Matrix4","_instanceWorldMatrix","_instanceIntersects","_mesh","THREE.Mesh","PositionMesh","THREE.Group","THREE.Color","_this$instance$curren","raycaster","intersects","parent","matrixWorld","instanceId","THREE.Material","intersect","globalContext","React.createContext","parentMatrix","instanceMatrix","tempMatrix","translation","THREE.Vector3","rotation","THREE.Quaternion","scale","isInstancedBufferAttribute","attr","Instance","context","React.useMemo","extend","group","subscribe","getParent","React.useContext","Instances","range","limit","frames","localContext","instance","React.useState","parentRef","instances","setInstances","matrices","colors","mArray","React.useEffect","iterations","count","attributes","_name","useFrame","api","item","THREE.DynamicDrawUsage","eps","createShape","radius0","shape","Shape","radius","RoundedBox","steps","smoothness","bevelSegments","rest","params","geomRef","createStoreImpl","createState","state","listeners","setState","partial","replace","nextState","previousState","listener","getState","initialState","__vite_import_meta_env__","createStore","React","require$$0","shim","require$$1","is","objectIs","useSyncExternalStore","useRef","useEffect","useMemo","useDebugValue","withSelector_production","getSnapshot","getServerSnapshot","selector","isEqual","instRef","inst","memoizedSelector","nextSnapshot","hasMemo","memoizedSnapshot","currentSelection","memoizedSelection","nextSelection","maybeGetServerSnapshot","withSelectorModule","ReactExports","useSyncExternalStoreWithSelector","useSyncExternalStoreExports","didWarnAboutEqualityFn","identity","arg","useStore","equalityFn","slice","createImpl","useBoundStore","create","_window$document","_window$navigator","useIsomorphicLayoutEffect","tunnel","set","version","current","isOrthographicCamera","def","col","tracked","isNonLegacyCanvasSize","size","computeContainerPosition","canvasSize","trackRect","trackLeft","trackBottom","isOffscreen","prepareSkissor","autoClear","aspect","finishSkissor","clear","Container","visible","scene","index","rect","track","rootState","useThree","setOffscreen","frameCount","_track$current","position","_isOffscreen","curRect","old","React.Fragment","CanvasView","id","style","className","fref","_rect$current","_rect$current2","_rect$current3","_rect$current4","virtualScene","THREE.Scene","ready","toggle","React.useReducer","compute","React.useCallback","event","_track$current2","createPortal","HtmlView","El","uuid","React.useId","View","_View","textures","num","CustomeMaterial","forwardRef","matcap","texture","useTexture","jsx","useLayoutEffect","isConfig","emptyArray","defaultConfig","_gsap","gsap","useGSAP","callback","dependencies","config","scope","revertOnUpdate","mounted","contextSafe","func","deferCleanup","core","Item1","refList","getRef","useCallback","mesh","_","jsxs","Item2","groupRef","Item","Item3","Item4","ring1Ref","ring2Ref","cone1Ref","cone2Ref","Item5","firstLayerRef","secondLayerRef","thirdLayerRef","distance","layers","layer1","layer2","layer3","SemiCircleCurve","THREE.Curve","radians","Item6","path","path2","ballRef","tubeRef","t","point","THREE.DoubleSide","Item7","Item8","ref1","ref2","Item9","Item10","THREE.Shape","extrudeSettings","THREE.ExtrudeGeometry","Item11","rotate","s","THREE.Matrix3","clock","time","angle","angle1","angle5","vector","newPosition","Item12","arrow","arrows","Wrapper","name","App","items","showedItem","Fragment","Canvas"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,14]}